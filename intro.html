
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Coalgebraic Logic</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=4ec06e9971c5264fbd345897d5258098f11cc577" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=8bf782fb4ee92b3d3646425e50f299c4e1fd152d"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'intro';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="None">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>

  
  <input type="checkbox" class="sidebar-toggle" name="__primary" id="__primary">
  <label class="overlay overlay-primary" for="__primary"></label>

  
  <input type="checkbox" class="sidebar-toggle" name="__secondary" id="__secondary">
  <label class="overlay overlay-secondary" for="__secondary"></label>

  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
      
<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
  </div>

  
  <nav class="bd-header navbar navbar-expand-lg bd-navbar" id="navbar-main"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="#">

  
  
  
  
  
  
  

  
  
    <p class="title logo__title">None</p>
  
</a>
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Introduction to Modal Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Introduction
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Origins in Domain Theory
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        The Landscape
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Powerdomains
                      </a>
                    </li>
                
            <div class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    More
                </button>
                <div class="dropdown-menu">
                    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Neighbourhood Frames
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Coalgebraic (Bi)Similarity
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Basic Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Predicate Liftings
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Monotone Predicate Liftings
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Expressive Predicate Liftings
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Relation Lifting
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Moss’s Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Introduction
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Presenting Functors
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Boolean Logic for Set-Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Semantics of Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Completeness
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Expressivity
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Translations of Logics
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Many-Valued Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Cospan Bisimulation: Overview
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Cospan Bisimulation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Neighbourhood Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Bisimulation for Ordered Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Cospan Bisimulation 2
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Coalgebras over Preorders
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Examples of Poset-Functor
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Montone Neighbourhood Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Logic of Ordered Neighbourhood Coalgebras
                      </a>
                    </li>
                
                </div>
            </div>
            
    </ul>
</nav>
      </div>
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  

</div>
  </nav>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
      
      <div class="navbar-center-item">
        <nav class="navbar-nav">
    <p class="sidebar-header-items__title" role="heading" aria-level="1" aria-label="Site Navigation">
        Site Navigation
    </p>
    <ul id="navbar-main-elements" class="navbar-nav">
        
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Introduction to Modal Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Introduction
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Origins in Domain Theory
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        The Landscape
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Powerdomains
                      </a>
                    </li>
                
            <div class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    More
                </button>
                <div class="dropdown-menu">
                    
                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Neighbourhood Frames
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Coalgebraic (Bi)Similarity
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Basic Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Predicate Liftings
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Monotone Predicate Liftings
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Expressive Predicate Liftings
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Relation Lifting
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Moss’s Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Introduction
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Presenting Functors
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Boolean Logic for Set-Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Semantics of Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Completeness
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Expressivity
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Translations of Logics
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Many-Valued Coalgebraic Logic
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Cospan Bisimulation: Overview
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Cospan Bisimulation
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Neighbourhood Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Bisimulation for Ordered Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Cospan Bisimulation 2
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Coalgebras over Preorders
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Examples of Poset-Functor
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Montone Neighbourhood Coalgebras
                      </a>
                    </li>
                

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="#">
                        Logic of Ordered Neighbourhood Coalgebras
                      </a>
                    </li>
                
                </div>
            </div>
            
    </ul>
</nav>
      </div>
      
      </div>
    

    
    
    <div class="sidebar-header-items__end">
      
      <div class="navbar-end-item">
        <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
</button>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
    
  </div>

  
  <div class="sidebar-start-items sidebar-primary__section">
    <div class="sidebar-start-items__item">
  


<a class="navbar-brand logo" href="#">

  
  
  
  
  
  
  

  
  
    <p class="title logo__title">None</p>
  
</a>
    </div>
    <div class="sidebar-start-items__item">
<form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
    </div>
    <div class="sidebar-start-items__item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1 current active">
                <a class="reference internal" href="#">
                    Introduction
                </a>
            </li>
        </ul>
        <p class="caption" role="heading"><span class="caption-text">Modal Logic</span></p>
<ul class="nav bd-sidenav">

</ul>
<p class="caption" role="heading"><span class="caption-text">Overview or Coalgebraic Logic</span></p>
<ul class="nav bd-sidenav">



</ul>
<p class="caption" role="heading"><span class="caption-text">Paradigmatic Examples</span></p>
<ul class="nav bd-sidenav">


</ul>
<p class="caption" role="heading"><span class="caption-text">Introduction to Coalgebraic Logic</span></p>
<ul class="nav bd-sidenav">







</ul>
<p class="caption" role="heading"><span class="caption-text">Functorial Modal Logic</span></p>
<ul class="nav bd-sidenav">








</ul>
<p class="caption" role="heading"><span class="caption-text">Cospan (Bi)Similarity.md</span></p>
<ul class="nav bd-sidenav">





</ul>
<p class="caption" role="heading"><span class="caption-text">Order-Enriched Coalgebra</span></p>
<ul class="nav bd-sidenav">




</ul>

    </div>
</nav>
    </div>
  </div>
  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

        <div class="bd-content">
          <div class="bd-article-container">
            
            <div class="bd-header-article">
                



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        <label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" data-toggle="tooltip" data-placement="right" title="Toggle primary sidebar">
            <span class="fa-solid fa-bars"></span>
        </label>
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="btn btn-sm"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<div class="dropdown dropdown-repository-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      <li><a href="https://github.com/alexhkurz/coalgebraic-logic-jupyter/" target="_blank"
   class="btn btn-sm dropdown-item"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">repository</span>
</a>
</a>
      
      <li><a href="https://github.com/alexhkurz/coalgebraic-logic-jupyter//issues/new?title=Issue%20on%20page%20%2Fintro.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm dropdown-item"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">open issue</span>
</a>
</a>
      
  </ul>
</div>

    </div>
</div>
            </div>
            
            

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Introduction</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

            <article class="bd-article" role="main">
              
  <section class="tex2jax_ignore mathjax_ignore" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h1>
<p>(under construction … notes from <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/ryrkkYZZc">hackmd</a> moved here now)</p>
<p>Coalgebraic logic, in the wider sense of coalgebraic methods applied to (modal) logic, started in the late 1990ies with Larry Moss’s article <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0168007298000426">Coalgebraic Logic</a> in which he presented what is today considered one of several coalgebraic logics. In these notes I will take the particular view that a modal or coalgebraic <strong>logic is given by a functor</strong> <span class="math notranslate nohighlight">\(L\)</span> on the category of Boolean algebras (or another suitable variety of algebras). To distinguish this approach from other approaches to coalgebraic I sometimes call it functorial modal logic or functorial coalgebraic logic.</p>
<p>These notes consist of the following parts.</p>
<p><strong>Modal Logic</strong> is a very brief introduction to modal logic with pointers to the literature. I will try to write the other parts so that they do not depend too much on Part 1, but it is natural to view coalgebraic logic as an extension and generalisation of modal logic.</p>
<p><strong>Overview of Coalgebraic Logic</strong> shows how the Kripke frames of  Modal Logic and various models of computation of Domain Theory are unified and generalised by the notion of a coalgebra <span class="math notranslate nohighlight">\(X\to TX\)</span> for a functor <span class="math notranslate nohighlight">\(T\)</span>. We review the various parameters along which the theory of coalgebras can be developed.</p>
<p><strong>Paradigmatic Examples</strong> could be a good place to start. The examples are  of interest in their own right and have been studied long before coalgebra became a research area. We look in more detail than above at Kripke frames and powerdomains .. add more on probabilistic transition systems and neighbourhood coalgebras.</p>
<p><strong>Introduction to Coalgebraic Logic</strong> makes use of the concept of a modal logic as a functor mostly as a linguistic device facilitating concise notation. One immediate benefit is that the notion of a <em>modal algebra</em> as an algebra <span class="math notranslate nohighlight">\(LA\to A\)</span> for a functor <span class="math notranslate nohighlight">\(L\)</span> (the <em><strong>L</strong></em>ogic) dualises the notion of coalgebra <span class="math notranslate nohighlight">\(X\to TX\)</span> for a functor <span class="math notranslate nohighlight">\(T\)</span> (the <em><strong>t</strong></em>ype of the <em><strong>t</strong></em>ransition). In fact, we will see that we can create a logic <span class="math notranslate nohighlight">\(L\)</span> from <span class="math notranslate nohighlight">\(T\)</span> by dualising <span class="math notranslate nohighlight">\(T\)</span> in a technically precise sense (provided by Stone duality and category theory) and then presenting the functor <span class="math notranslate nohighlight">\(L\)</span> by modal operators and equations.</p>
<p><strong>Functorial Modal Logic</strong> develops the particular category theoretic methods that allow us to reason about coalgebraic models on the level of abstraction of functors and natural transformations, abstracting as much as possible from the concrete definition of a particular logic. These methods can be used to prove general theorems parametrically in <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(T\)</span> (eg invariance of formulas under bisimilarity, completeness, expressiveness). The connection between <em>abstract</em> and <em>concrete</em> coalgebraic logics is facilitated by the notion of a <em>presentation of a functor by operations and equations</em>.</p>
<p><strong>Cospan (Bi)Similarity</strong> presents a new take on the notion of behavioural equivalence (coalgebraic bisimilarity). While it has been known since Worrell’s PhD Thesis that one can use cospans (aka collages) to describe coalgebraic similarity in the quantale-enriched setting, we show that the quantale-enriched setting contains behavioural equivalence of ordinary coalgebras as a special case.</p>
<p><strong>Ordered Coalgebras</strong> starts the development of coalgebra over enriched categories.</p>
<p><strong>Quantale-Enriched Coalgebra</strong> …</p>
<section id="acknowledgements">
<h2>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">#</a></h2>
<p>These notes have been written in discussions with Adriana Balan, Daniel Briseno, Luke Burns, Justin Dressel, Jim de Groot, Helle Hansen, Peter Jipsen, Nima Motamed, Drew Moshier, Wolfgang Poiger, Bruno Teheux, Yde Venema, Jeremy Wayland and others.</p>
</section>
<section id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">#</a></h2>
<p>(just started)</p>
<div class="docutils container" id="id1">
<dl class="citation">
<dt class="label" id="id3"><span class="brackets">BK16</span></dt>
<dd><p>Octavian Babus and Alexander Kurz. On the logic of generalised metric spaces. In Ichiro Hasuo, editor, <em>Coalgebraic Methods in Computer Science - 13th IFIP WG 1.3 International Workshop, CMCS 2016, Colocated with ETAPS 2016, Eindhoven, The Netherlands, April 2-3, 2016, Revised Selected Papers</em>, volume 9608 of Lecture Notes in Computer Science, 136–155. Springer, 2016. URL: <a class="reference external" href="https://doi.org/10.1007/978-3-319-40370-0\_9">https://doi.org/10.1007/978-3-319-40370-0\_9</a>, <a class="reference external" href="https://doi.org/10.1007/978-3-319-40370-0\_9">doi:10.1007/978-3-319-40370-0\_9</a>.</p>
</dd>
<dt class="label" id="id2"><span class="brackets">BK21</span></dt>
<dd><p>Adriana Balan and Alexander Kurz. An equational approach to enriched distributivity. <em>Revue Roumaine de Mathématiques Pures et Appliquées</em>, 2021. URL: <a class="reference external" href="https://arxiv.org/abs/2112.13290">https://arxiv.org/abs/2112.13290</a>, <a class="reference external" href="https://arxiv.org/abs/2112.13290">arXiv:2112.13290</a>.</p>
</dd>
<dt class="label" id="id6"><span class="brackets">BKV15</span></dt>
<dd><p>Adriana Balan, Alexander Kurz, and Jiri Velebil. Extensions of functors from set to v-cat. In Lawrence S. Moss and Pawel Sobocinski, editors, <em>6th Conference on Algebra and Coalgebra in Computer Science, CALCO 2015, June 24-26, 2015, Nijmegen, The Netherlands</em>, volume 35 of LIPIcs, 17–34. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2015. URL: <a class="reference external" href="https://doi.org/10.4230/LIPIcs.CALCO.2015.17">https://doi.org/10.4230/LIPIcs.CALCO.2015.17</a>, <a class="reference external" href="https://doi.org/10.4230/LIPIcs.CALCO.2015.17">doi:10.4230/LIPIcs.CALCO.2015.17</a>.</p>
</dd>
<dt class="label" id="id5"><span class="brackets">BKV19</span></dt>
<dd><p>Adriana Balan, Alexander Kurz, and Jiri Velebil. Extending set functors to generalised metric spaces. <em>Log. Methods Comput. Sci.</em>, 2019. URL: <a class="reference external" href="https://doi.org/10.23638/LMCS-15(1:5)2019">https://doi.org/10.23638/LMCS-15(1:5)2019</a>, <a class="reference external" href="https://doi.org/10.23638/LMCS-15(1:5)2019">doi:10.23638/LMCS-15(1:5)2019</a>.</p>
</dd>
<dt class="label" id="id12"><span class="brackets">BilkovaDostal13</span></dt>
<dd><p>Marta Bílková and Matej Dostál. Many-valued relation lifting and moss' coalgebraic logic. In Reiko Heckel and Stefan Milius, editors, <em>Algebra and Coalgebra in Computer Science - 5th International Conference, CALCO 2013, Warsaw, Poland, September 3-6, 2013. Proceedings</em>, volume 8089 of Lecture Notes in Computer Science, 66–79. Springer, 2013. URL: <a class="reference external" href="https://doi.org/10.1007/978-3-642-40206-7\_7">https://doi.org/10.1007/978-3-642-40206-7\_7</a>, <a class="reference external" href="https://doi.org/10.1007/978-3-642-40206-7\_7">doi:10.1007/978-3-642-40206-7\_7</a>.</p>
</dd>
<dt class="label" id="id11"><span class="brackets">BilkovaDostal16</span></dt>
<dd><p>Marta Bílková and Matej Dostál. Expressivity of many-valued modal logics, coalgebraically. In Jouko A. Väänänen, Åsa Hirvonen, and Ruy J. G. B. de Queiroz, editors, <em>Logic, Language, Information, and Computation - 23rd International Workshop, WoLLIC 2016, Puebla, Mexico, August 16-19th, 2016. Proceedings</em>, volume 9803 of Lecture Notes in Computer Science, 109–124. Springer, 2016. URL: <a class="reference external" href="https://doi.org/10.1007/978-3-662-52921-8\_8">https://doi.org/10.1007/978-3-662-52921-8\_8</a>, <a class="reference external" href="https://doi.org/10.1007/978-3-662-52921-8\_8">doi:10.1007/978-3-662-52921-8\_8</a>.</p>
</dd>
<dt class="label" id="id10"><span class="brackets">BilkovaDostal22</span></dt>
<dd><p>Marta Bílková and Matej Dostál. Moss' logic for ordered coalgebras. <em>Log. Methods Comput. Sci.</em>, 2022. URL: <a class="reference external" href="https://doi.org/10.46298/lmcs-18(3:18)2022">https://doi.org/10.46298/lmcs-18(3:18)2022</a>, <a class="reference external" href="https://doi.org/10.46298/lmcs-18(3:18)2022">doi:10.46298/lmcs-18(3:18)2022</a>.</p>
</dd>
<dt class="label" id="id9"><span class="brackets">BilkovaKPV11</span></dt>
<dd><p>Marta Bílková, Alexander Kurz, Daniela Petrisan, and Jiri Velebil. Relation liftings on preorders and posets. In Andrea Corradini, Bartek Klin, and Corina Cîrstea, editors, <em>Algebra and Coalgebra in Computer Science - 4th International Conference, CALCO 2011, Winchester, UK, August 30 - September 2, 2011. Proceedings</em>, volume 6859 of Lecture Notes in Computer Science, 115–129. Springer, 2011. URL: <a class="reference external" href="https://doi.org/10.1007/978-3-642-22944-2\_9">https://doi.org/10.1007/978-3-642-22944-2\_9</a>, <a class="reference external" href="https://doi.org/10.1007/978-3-642-22944-2\_9">doi:10.1007/978-3-642-22944-2\_9</a>.</p>
</dd>
<dt class="label" id="id8"><span class="brackets">BilkovaKPV12</span></dt>
<dd><p>Marta Bílková, Alexander Kurz, Daniela Petrisan, and Jiri Velebil. Relation liftings on preorders and posets. <em>CoRR</em>, 2012. URL: <a class="reference external" href="http://arxiv.org/abs/1210.1433">http://arxiv.org/abs/1210.1433</a>, <a class="reference external" href="https://arxiv.org/abs/1210.1433">arXiv:1210.1433</a>.</p>
</dd>
<dt class="label" id="id14"><span class="brackets">JS10</span></dt>
<dd><p>Bart Jacobs and Ana Sokolova. Exemplaric expressivity of modal logics. <em>J. Log. Comput.</em>, 20(5):1041–1068, 2010. URL: <a class="reference external" href="https://doi.org/10.1093/logcom/exn093">https://doi.org/10.1093/logcom/exn093</a>, <a class="reference external" href="https://doi.org/10.1093/logcom/exn093">doi:10.1093/logcom/exn093</a>.</p>
</dd>
<dt class="label" id="id4"><span class="brackets">KKV12</span></dt>
<dd><p>Krzysztof Kapulkin, Alexander Kurz, and Jiri Velebil. Expressiveness of positive coalgebraic logic. In Thomas Bolander, Torben Braüner, Silvio Ghilardi, and Lawrence S. Moss, editors, <em>Advances in Modal Logic 9, papers from the ninth conference on &quot;Advances in Modal Logic,&quot; held in Copenhagen, Denmark, 22-25 August 2012</em>, 368–385. College Publications, 2012. URL: <a class="reference external" href="http://www.aiml.net/volumes/volume9/Kapulkin-Kurz-Velebil.pdf">http://www.aiml.net/volumes/volume9/Kapulkin-Kurz-Velebil.pdf</a>.</p>
</dd>
<dt class="label" id="id15"><span class="brackets">Kli07</span></dt>
<dd><p>Bartek Klin. Coalgebraic modal logic beyond sets. In Marcelo Fiore, editor, <em>Proceedings of the 23rd Conference on the Mathematical Foundations of Programming Semantics, MFPS 2007, New Orleans, LA, USA, April 11-14, 2007</em>, volume 173 of Electronic Notes in Theoretical Computer Science, 177–201. Elsevier, 2007. URL: <a class="reference external" href="https://doi.org/10.1016/j.entcs.2007.02.034">https://doi.org/10.1016/j.entcs.2007.02.034</a>, <a class="reference external" href="https://doi.org/10.1016/j.entcs.2007.02.034">doi:10.1016/j.entcs.2007.02.034</a>.</p>
</dd>
<dt class="label" id="id13"><span class="brackets">LL20</span></dt>
<dd><p>Chun-Yu Lin and Churn-Jung Liau. On coalgebraic many-valued modal logic. <em>CoRR</em>, 2020. URL: <a class="reference external" href="https://arxiv.org/abs/2012.05604">https://arxiv.org/abs/2012.05604</a>, <a class="reference external" href="https://arxiv.org/abs/2012.05604">arXiv:2012.05604</a>.</p>
</dd>
<dt class="label" id="id20"><span class="brackets">Pat04</span></dt>
<dd><p>Dirk Pattinson. Expressive logics for coalgebras via terminal sequence induction. <em>Notre Dame J. Formal Log.</em>, 45(1):19–33, 2004. URL: <a class="reference external" href="https://doi.org/10.1305/ndjfl/1094155277">https://doi.org/10.1305/ndjfl/1094155277</a>, <a class="reference external" href="https://doi.org/10.1305/ndjfl/1094155277">doi:10.1305/ndjfl/1094155277</a>.</p>
</dd>
<dt class="label" id="id17"><span class="brackets">Schroder05</span></dt>
<dd><p>Lutz Schröder. Expressivity of coalgebraic modal logic: the limits and beyond. In Vladimiro Sassone, editor, <em>Foundations of Software Science and Computational Structures, 8th International Conference, FOSSACS 2005, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2005, Edinburgh, UK, April 4-8, 2005, Proceedings</em>, volume 3441 of Lecture Notes in Computer Science, 440–454. Springer, 2005. URL: <a class="reference external" href="https://doi.org/10.1007/978-3-540-31982-5\_28">https://doi.org/10.1007/978-3-540-31982-5\_28</a>, <a class="reference external" href="https://doi.org/10.1007/978-3-540-31982-5\_28">doi:10.1007/978-3-540-31982-5\_28</a>.</p>
</dd>
<dt class="label" id="id16"><span class="brackets">Schroder08</span></dt>
<dd><p>Lutz Schröder. Expressivity of coalgebraic modal logic: the limits and beyond. <em>Theor. Comput. Sci.</em>, 390(2-3):230–247, 2008. URL: <a class="reference external" href="https://doi.org/10.1016/j.tcs.2007.09.023">https://doi.org/10.1016/j.tcs.2007.09.023</a>, <a class="reference external" href="https://doi.org/10.1016/j.tcs.2007.09.023">doi:10.1016/j.tcs.2007.09.023</a>.</p>
</dd>
<dt class="label" id="id19"><span class="brackets">Wor99</span></dt>
<dd><p>James Worrell. Terminal sequences for accessible endofunctors. In Bart Jacobs and Jan J. M. M. Rutten, editors, <em>Coalgebraic Methods in Computer Science, CMCS 1999, Amsterdam, The Netherlands, March 20-21, 1999</em>, volume 19 of Electronic Notes in Theoretical Computer Science, 24–38. Elsevier, 1999. URL: <a class="reference external" href="https://doi.org/10.1016/S1571-0661(05)80267-1">https://doi.org/10.1016/S1571-0661(05)80267-1</a>, <a class="reference external" href="https://doi.org/10.1016/S1571-0661(05)80267-1">doi:10.1016/S1571-0661(05)80267-1</a>.</p>
</dd>
<dt class="label" id="id18"><span class="brackets">Wor05</span></dt>
<dd><p>James Worrell. On the final sequence of a finitary set functor. <em>Theor. Comput. Sci.</em>, 338(1-3):184–199, 2005. URL: <a class="reference external" href="https://doi.org/10.1016/j.tcs.2004.12.009">https://doi.org/10.1016/j.tcs.2004.12.009</a>, <a class="reference external" href="https://doi.org/10.1016/j.tcs.2004.12.009">doi:10.1016/j.tcs.2004.12.009</a>.</p>
</dd>
</dl>
</div>
</section>
<div class="toctree-wrapper compound">
<span id="document-contents/Introduction-to-Modal-Logic"></span><p><span class="math notranslate nohighlight">\(\newcommand{\sem}[1]{[\![#1]\!]}\)</span></p>
<section class="tex2jax_ignore mathjax_ignore" id="introduction-to-modal-logic">
<h2>Introduction to Modal Logic<a class="headerlink" href="#introduction-to-modal-logic" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<section id="motivation">
<h3>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">#</a></h3>
<p>Superficially, modal logic adds to the propositional connectives <span class="math notranslate nohighlight">\(\wedge\)</span> (and), <span class="math notranslate nohighlight">\(\vee\)</span> (or), <span class="math notranslate nohighlight">\(\neg\)</span> (not) two new connectives that allow us to take any formula <span class="math notranslate nohighlight">\(\phi\)</span> and form two new formulas</p>
<div class="math notranslate nohighlight">
\[
\Box\phi\quad\quad\Diamond\phi.
\]</div>
<p>One of the reasons modal logic has been so important is that there are so many possible interpretations for these connectives. For example,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Box\phi\)</span> means necessarily <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\Diamond\phi\)</span> means possibly <span class="math notranslate nohighlight">\(\phi\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\Box\phi\)</span> means always <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\Diamond\phi\)</span> means sometimes <span class="math notranslate nohighlight">\(\phi\)</span>,</p></li>
<li><p><span class="math notranslate nohighlight">\(\Box_i\phi\)</span> means agent <span class="math notranslate nohighlight">\(i\)</span> knows <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\Diamond_i\phi\)</span> means agent <span class="math notranslate nohighlight">\(i\)</span> thinks <span class="math notranslate nohighlight">\(\phi\)</span> is possible.</p></li>
</ul>
<p><strong>(Temporal and Epistemic Logic)</strong> Each of these interpretations created their own field of research. The first one dominated modal logic in the first half of the 20th century. The second one is known as temporal logic and has been playing an important role in computer science (verificiation, model checking) since the 1980ies. The third one is known as epistemic logic and continues to be cutting edge in philosophy, economics, software engineering, AI and other areas.</p>
<p>Besides temporal logic and epistemic logic there is also … (insert more examples) …</p>
<p><strong>(Fragments of First-Order Logic)</strong> Another reason modal logic has been important is as a fragment of first-order logic. As we can see from the examples above, <span class="math notranslate nohighlight">\(\Box\phi\)</span> is a universal quantifier (eg always) and <span class="math notranslate nohighlight">\(\Diamond\phi\)</span> is an existential quantifier (eg sometimes). Consequently, modal logic is a fragment of first-order logic. In fact, modal logic is a fragment of first-order logic in at least two different but interesting ways:</p>
<ul class="simple">
<li><p>Modal logic is a decidable fragment of first-order logic.</p></li>
<li><p>Modal logic is the bisimulation invariant fragment of first-order logic.</p></li>
</ul>
<p>The first point has given rise to various generalisations of modal logic, in particular in the area of automated theorem proving. Search for <a class="reference external" href="https://www.google.com/search?q=%22guarded+fragment%22&amp;oq=%22guarded+fragment%22&amp;aqs=chrome..69i57j0j0i22i30l2.3319j1j4&amp;sourceid=chrome&amp;ie=UTF-8">guarded fragment</a> for references.</p>
<p>In the second point bisimulation refers to a relation of observational or behavioural equivalence of dynamic systems, which are themselves considered as “black boxes”. In fact, bisimulation is the natural notion of behavioural equivalence for non-determinstic transition systems in which the states themselves are not observable but choices are. This leads us to the next item.</p>
<p><strong>(Possible Worlds Semantics)</strong> The idea that something is necessarily true if it is true in all possible worlds is an old one. The turning point for modal logic was the mathematical formalisation of possible world semantics by Kripke:</p>
<ul class="simple">
<li><p>Saul Kripke: <a class="reference external" href="http://www.naturalthinker.net/trl/texts/Kripke,Saul/Kripke%20S.%20-%20A%20Completeness%20Theorem%20in%20Modal%20Logic.pdf">A Completeness Theorem in Modal Logic</a>. 1959.</p></li>
<li><p>Saul Kripke: <a class="reference external" href="http://fitelson.org/142/kripke_1.pdf">Semantical Analysis of Modal Logic I</a>. 1963. I recommend Section 2.1, which also contains the solution to one of the exercises below.</p></li>
<li><p>Saul Kripke: <a class="reference external" href="http://fitelson.org/142/kripke_2.pdf">Semantical Analysis of Modal Logic II</a>. 1965.</p></li>
</ul>
<p>There is a lot to say here, but to present the main ideas as quickly as possible I would proceed as follows (see Chapters 3.1 and 3.2 of the book referenced below).</p>
<p><strong>Definition:</strong> Let <span class="math notranslate nohighlight">\(Prop\)</span> be a set of ‘propositional variables’. The language of modal logic is the smallest set of ‘formulas’ containing <span class="math notranslate nohighlight">\(Prop\)</span> and closed under <span class="math notranslate nohighlight">\(\wedge\)</span> , <span class="math notranslate nohighlight">\(\vee\)</span>, <span class="math notranslate nohighlight">\(\neg\)</span>, <span class="math notranslate nohighlight">\(\Box\)</span>, <span class="math notranslate nohighlight">\(\Diamond\)</span>.</p>
<p><strong>Definition:</strong> Let <span class="math notranslate nohighlight">\(W\)</span> be a set of ‘worlds’ and <span class="math notranslate nohighlight">\(R\subseteq W\times W\)</span>. Let <span class="math notranslate nohighlight">\(\sem{-}:Prop\to 2^W\)</span> be a function assigning sets of worlds to each atomic proposition. Define</p>
<div class="amsmath math notranslate nohighlight" id="equation-3e4bdf94-6d4f-43e9-bdba-2502ef7f155a">
<span class="eqno">(1)<a class="headerlink" href="#equation-3e4bdf94-6d4f-43e9-bdba-2502ef7f155a" title="Permalink to this equation">#</a></span>\[\begin{align}
\sem{\phi\wedge\phi'} &amp;= \sem{\phi}\cap\sem{\phi'}\\
\sem{\phi\vee\phi'} &amp;= \sem{\phi}\cup\sem{\phi'}\\
\sem{\neg\phi} &amp;= W\setminus \sem{\phi}\\
\sem{\Box\phi} &amp;= \{w\in W\mid \forall v\in W\,.\, v\in\sem{\phi}\}\\
\sem{\Diamond\phi} &amp;= \{w\in W\mid \exists v\in W\,.\, v\in\sem{\phi}\}\\
\end{align}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
(W,R)\models \phi
\]</div>
<p>iff <span class="math notranslate nohighlight">\(\sem{\phi}=W\)</span> for all choices of <span class="math notranslate nohighlight">\(\sem{-}:Prop\to 2^W\)</span>.</p>
<p>It is convenient to write</p>
<div class="math notranslate nohighlight">
\[
w\Vdash \phi \quad \stackrel{\rm  def}{\Longleftrightarrow} \quad w\in\sem{\phi}.
\]</div>
<p>The following exercise is a straightforward unvraveling of definitions:</p>
<p><strong>Exercise:</strong> If <span class="math notranslate nohighlight">\(R\)</span> is reflexive, then <span class="math notranslate nohighlight">\((W,R)\models \Box p\to p\)</span>.</p>
<p>A crucial observation that lets us glimpse the power of Kripke’s approach is that the converse is also true.</p>
<p><strong>Prop:</strong> If <span class="math notranslate nohighlight">\((W,R)\models \Box p\to p\)</span>, then <span class="math notranslate nohighlight">\(R\)</span> is reflexive.</p>
<p>The proof is short once you know the trick. Try to find it for yourself before looking at the footnote.<a class="footnote-reference brackets" href="#proof" id="id1">1</a></p>
<p>The proof can be generalised to a method applying to all so-called Sahlqvist formulas and the area of modal logic is known as correspondence theory. We just look at one other basic example:</p>
<p><strong>Exercise:</strong> <span class="math notranslate nohighlight">\((W,R)\models \Box p\to\Box\Box p\)</span> iff <span class="math notranslate nohighlight">\(R\)</span> is transitive.</p>
<p><strong>Remark:</strong> In the early 20th century modal logics where developed by philosophers from a syntactic and proof theoretic point of view. Axioms such as <span class="math notranslate nohighlight">\(\Box p\to p\)</span> and <span class="math notranslate nohighlight">\(\Box\phi\to\Box\Box\phi\)</span> where discovered by reading them as “necessarily p implies p” and “necessarily p implies necessarily necessarily p” and modal logics where characterised by axioms and proof rules. As far as I know the history, it came as a surprise that these axioms had such a neat semantic characterisation.</p>
<p><strong>Exercise:</strong> Interpret <span class="math notranslate nohighlight">\(\Box p\to p\)</span> and <span class="math notranslate nohighlight">\(\Box p\to\Box\Box p\)</span> from the point of view of temporal and epistemic logic.</p>
<section id="further-reading">
<h4>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">#</a></h4>
<p>The paper</p>
<ul class="simple">
<li><p>Halpern, Vardi: <a class="reference external" href="https://www.cs.cornell.edu/home/halpern/papers/manifesto.pdf">Model Checking v. Theorem Proving: A Manifesto</a>. 1991.</p></li>
</ul>
<p>illustrates many of the themes that make modal logic so important for computer science applications.</p>
</section>
</section>
<section id="the-basic-theory-of-modal-logic">
<h3>The Basic Theory of Modal Logic<a class="headerlink" href="#the-basic-theory-of-modal-logic" title="Permalink to this headline">#</a></h3>
<p>We have seen that modal logic comprises several independent areas (temporal logic, epistemic logic, etc) and has important overlaps with others (concurrency, multi-agent systems, automated reasoning, game theory, etc). My intention here is only to sketch out the basic theory that is important in all these fields.</p>
<p>Actually, instead of writing this out myself, I refer to the book “Modal Logic” by Blackburn, de Rijke, Venema.(The book treats also <span class="math notranslate nohighlight">\(n\)</span>-ary relations (the “general case”, as opposed to binary relations). This generalisation is interesting for some applications but should be skipped on a first reading.)</p>
<p>Here is what I would consider essential for a first run through the basics of modal logic.</p>
<ul class="simple">
<li><p>1.2: Modal Languages</p></li>
<li><p>1.3: Models and Frames</p></li>
<li><p>1.5: Semantic Consequence</p></li>
<li><p>1.6: Normal Modal Logics</p></li>
<li><p>2.1: Invariance Results (Def 2.10 and Prop 2.14)</p></li>
<li><p>2.2: Bisimulations (up to Thm 2.20)</p></li>
<li><p>2.3: Finite Models (can be skipped on first reading)</p></li>
<li><p>2.4: The Standard Translation (up to Prop 2.47)</p></li>
<li><p>3.1: Frame Definability (Exle 3.6)</p></li>
<li><p>3.2: Frame Definability and Second-Order Logic (Exle 3.11)</p></li>
</ul>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Blackburn, de Rijke, Venema: “Modal Logic”.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="proof"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(w\in W\)</span>. Let <span class="math notranslate nohighlight">\(\sem{p}=\{v \mid wRv\}\)</span>. We know <span class="math notranslate nohighlight">\(w\Vdash\Box p\)</span> by definition of <span class="math notranslate nohighlight">\(\sem{\Box p}\)</span> and <span class="math notranslate nohighlight">\(w\Vdash \Box p\to p\)</span> by assumption. It follows <span class="math notranslate nohighlight">\(w\Vdash p\)</span>, which implies <span class="math notranslate nohighlight">\(wRw\)</span> by definition of <span class="math notranslate nohighlight">\(\sem{p}\)</span>.</p>
</dd>
</dl>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-contents/Introduction-to-Coalgebraic-Logic"></span><section class="tex2jax_ignore mathjax_ignore" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added)</p>
<p>We assume here that the reader has seen some propositional and modal logic and is interested in how Kripke structures  can be generalised to coalgebras. Coalgebraic logic can be seen as generalising modal logic along the following parameters:</p>
<ul class="simple">
<li><p>a category <span class="math notranslate nohighlight">\(\mathcal X\)</span> whose objects are state spaces,</p></li>
<li><p>a “type” functor <span class="math notranslate nohighlight">\(T:\mathcal X\to\mathcal X\)</span> specifying the type of dynamics,</p></li>
<li><p>a category <span class="math notranslate nohighlight">\(\mathcal A\)</span> whose objects are propositional theories,</p></li>
<li><p>a “logic” functor <span class="math notranslate nohighlight">\(L:\mathcal A \to \mathcal A\)</span> specifying modal operators and their axioms,</p></li>
<li><p>a contravariant adjunction relating the logic <span class="math notranslate nohighlight">\((\mathcal A,L)\)</span> and the semantics <span class="math notranslate nohighlight">\((\mathcal X,T)\)</span>.</p></li>
</ul>
<p>To go through this in detail will take some time. Let us start by sketching how coalgebras generalise Kripke structures.</p>
<p>The notion of coalgebra is parameterised by that of a functor <span class="math notranslate nohighlight">\(T:\mathcal X\to \mathcal X\)</span> on some category of “spaces” <span class="math notranslate nohighlight">\(\mathcal X\)</span>. An object <span class="math notranslate nohighlight">\(X\in\mathcal X\)</span> generalises the set <span class="math notranslate nohighlight">\(X\)</span> of worlds of a Kripke frame, <span class="math notranslate nohighlight">\(T\)</span> represents the type of transitions and the relation <span class="math notranslate nohighlight">\(R\)</span> of a Kripke frame <span class="math notranslate nohighlight">\((X,R)\)</span> is a coalgebra <span class="math notranslate nohighlight">\(X\to TX\)</span> when <span class="math notranslate nohighlight">\(TX=\mathcal PX\)</span> is the set of subsets of <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>Similarly, modal logics can be parameterised by functors <span class="math notranslate nohighlight">\(L\)</span>  accounting for both modal operators such as <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> and axioms such as <span class="math notranslate nohighlight">\(\Box\)</span> preserving meets and <span class="math notranslate nohighlight">\(\Diamond\)</span> preserving joins.</p>
<p>Duality theory can be used to develop the theory of coalgebras together with their modal logics. In fact, often the functors <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(L\)</span> will be dual to each other in a precise mathematical sense, giving rise to automatic soundness, completeness and expressiveness results.</p>
<p>In the following we summarise the basic ingredients necessary to carry out this approach.</p>
<p>The paradigmatic example of the powerset functor <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> is reviewed in some detail in this note on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/r1SJ8lizO">powerdomains</a>.</p>
<section id="idea">
<h3>Idea<a class="headerlink" href="#idea" title="Permalink to this headline">#</a></h3>
<p>We extend a basic dual adjunction between a category <span class="math notranslate nohighlight">\(\mathcal S\)</span> of “spaces” and a category <span class="math notranslate nohighlight">\(\mathcal A\)</span> of “algebras”, to a dual adjunction between coalgebras for a functor <span class="math notranslate nohighlight">\(T\)</span> on <span class="math notranslate nohighlight">\(\mathcal S\)</span> and algebras for a functor <span class="math notranslate nohighlight">\(L\)</span> on <span class="math notranslate nohighlight">\(\mathcal A\)</span>.</p>
<p>In more detail, we have</p>
<ul class="simple">
<li><p>a category <span class="math notranslate nohighlight">\(\mathcal X\)</span> of “spaces”</p></li>
<li><p>a category <span class="math notranslate nohighlight">\(\mathcal A\)</span> of “algebras”</p></li>
<li><p>an adjunction <span class="math notranslate nohighlight">\(S\dashv P: \mathcal X^{op}\to\mathcal A\)</span></p></li>
</ul>
<p>We think of <span class="math notranslate nohighlight">\(P\)</span> as mapping a space <span class="math notranslate nohighlight">\(X\)</span> to its algebra of <strong>p</strong>ropositions or <strong>p</strong>redicates. In many examples, <span class="math notranslate nohighlight">\(P\)</span> is actually the <strong>p</strong>owerset functor.</p>
<p>We think of <span class="math notranslate nohighlight">\(S\)</span> as mapping an algebra <span class="math notranslate nohighlight">\(A\)</span> to its <strong>s</strong>pectrum, or the dual <strong>s</strong>pace of the algebra.</p>
<p>In addition, we have</p>
<ul class="simple">
<li><p>a functor <span class="math notranslate nohighlight">\(T:\mathcal X\to\mathcal X\)</span></p></li>
<li><p>a functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span></p></li>
</ul>
<p>We think of <span class="math notranslate nohighlight">\(T\)</span> as the <strong>t</strong>ype functor of generalised <strong>t</strong>ransition systems and of <span class="math notranslate nohighlight">\(L\)</span> as the functor building a <strong>l</strong>anguage or <strong>l</strong>ogic over some atomic propositions.</p>
<p>We write <span class="math notranslate nohighlight">\(Coalg(T)\)</span> for the category of coalgebras for the functor <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(Alg(L)\)</span> for the category of algebras for the functor <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p><strong>Proposition:</strong> If <span class="math notranslate nohighlight">\(S\dashv P\)</span> are a dual equivalence and <span class="math notranslate nohighlight">\(PT\cong LP\)</span>, then <span class="math notranslate nohighlight">\(Coalg(T)\)</span> is dually equivalent to <span class="math notranslate nohighlight">\(Alg(L)\)</span>.</p>
<p><strong>Example:</strong> The duality of descriptive general frames and Boolean algebras with operators arises in this way.</p>
<p>If <span class="math notranslate nohighlight">\(S\dashv P\)</span> is only a dual adjunction, it lifts to coalgebras/algebras only under special circumstances.</p>
</section>
<section id="the-modal-logic-view">
<h3>The modal logic view<a class="headerlink" href="#the-modal-logic-view" title="Permalink to this headline">#</a></h3>
<p>The above framework is very abstract. When is it legitimate to think of coalgebras as transition systems and of algebras as logics?</p>
<p>The paradigmatic example is the one where</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal X\)</span> is the category of sets</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal A\)</span> is the category of Boolean algebras</p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> is the powerset functor</p></li>
<li><p><span class="math notranslate nohighlight">\(Coalg(T)\)</span> is the category of Kripke frames (transition systems)</p></li>
<li><p><span class="math notranslate nohighlight">\(Alg(L)\)</span> is the category of Boolean algebras with operators</p></li>
</ul>
<p>(Here we have <span class="math notranslate nohighlight">\(PT\cong LP\)</span> only on finite sets.)</p>
<p>If we take instead</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T\)</span> to be the double powerset functor, <span class="math notranslate nohighlight">\(Coalg(T)\)</span> is the category of neighbourhood frames;</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal X\)</span> to be the category of Stone spaces, then <span class="math notranslate nohighlight">\(Coalg(T)\)</span> is the category of descriptive general frames;</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal A\)</span> to be the category of bounded distributive lattices, we obtain positive modal logic.</p></li>
</ul>
<p>So even in the case of classical modal we have already three examples that show how varying the different parameters captures interesting modal logics. Moreover, these parameters can be modified independently of each other, creating quite a large space of possibilities.</p>
<p>But the main interest in coalgebras stems from the discovery made by Jan Rutten and others, that there is a great variety of functors <span class="math notranslate nohighlight">\(T\)</span>.</p>
</section>
<section id="the-coalgebraic-approach-to-modal-logic">
<h3>The coalgebraic approach to modal logic<a class="headerlink" href="#the-coalgebraic-approach-to-modal-logic" title="Permalink to this headline">#</a></h3>
<p>The coalgebraic approach to modal logic is to expand the landscape of modal logics by systematically extending modal logic to a large variety of functors <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>List some examples …</p>
</section>
<section id="the-category-theoretic-view">
<h3>The category theoretic view<a class="headerlink" href="#the-category-theoretic-view" title="Permalink to this headline">#</a></h3>
<p>The category theoretic approach to coalgebras takes an axiomatic point of view. Clearly, we cannot expect all results of modal logic to survive modifcations of the parameters
$<span class="math notranslate nohighlight">\(\mathcal X,\mathcal A,S,P,L,T\)</span>$</p>
<p>On the other hand, the coalgebraic approach has shown that there is indeed a wide variety of instantiations of these parameters that allows us to extend many results of modal logic.</p>
<p>From a category theoretic point of view we can ask the following questions:</p>
<ul class="simple">
<li><p>When does a dual adjunction <span class="math notranslate nohighlight">\(S\dashv P\)</span> extend to coalgebras/algebras?</p></li>
<li><p>What can we say in the special situation where <span class="math notranslate nohighlight">\(S\dashv P\)</span> is an adjunction induced by a dualising object?</p></li>
<li><p>In the special case of the dual adjunction between sets and Boolean algebras, can we axiomatise the functors <span class="math notranslate nohighlight">\(T\)</span> for which the classical results of modal logic continue to hold?</p></li>
<li><p>Are there theorems transferring results from the case where <span class="math notranslate nohighlight">\(\mathcal A\)</span> is Boolean algebras to the case where <span class="math notranslate nohighlight">\(\mathcal A\)</span> is distributive lattices (and classical modal logic to positive modal logic)? Can these results be pushed further to include many-valued logics?</p></li>
<li><p>..</p></li>
</ul>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Jonsson-Tarski</p>
<p>Goldblatt</p>
<p>Abramsky</p>
<p>Bonsangue-Kurz</p>
<p>Kupke-Kurz-Venema</p>
<p>Kurz-Rosicky</p>
<p>Klin</p>
<p>…</p>
<p>to be completed</p>
<p>…</p>
</section>
<section id="further-reading">
<h3>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">#</a></h3>
<p>…</p>
</section>
</section>
<span id="document-contents/The-Origins-of-Coalgebra-in-Domain-Theory"></span><section class="tex2jax_ignore mathjax_ignore" id="origins-in-domain-theory">
<h2>Origins in Domain Theory<a class="headerlink" href="#origins-in-domain-theory" title="Permalink to this headline">#</a></h2>
<p>(sketchy draft … references to be added)</p>
<p>The theory of coalgebras in computer science can be traced back to Scott’s work in the 1970ies on domain theory. In this setting, it often happens, and later was sometimes taken to be axiomatic, that initial algebras and final coalgebras coincide. More explicitely, given a category <span class="math notranslate nohighlight">\(\mathcal C\)</span> of domains and a type constructor (= functor)</p>
<div class="math notranslate nohighlight">
\[T:\mathcal C\to \mathcal C\]</div>
<p>the initial <span class="math notranslate nohighlight">\(T\)</span>-algebra and the final <span class="math notranslate nohighlight">\(T\)</span>-coalgebra are isomorphic and we can take either one as the solution to the domain equation</p>
<div class="math notranslate nohighlight">
\[X\cong TX.\]</div>
<p>Scott had shown the importance of such solutions to the the theory of programming languages by constructing a domain for lambda calculus solving the equation <span class="math notranslate nohighlight">\(X\cong X^X\)</span>. This required a sophistocated construction of the base category <span class="math notranslate nohighlight">\(\mathcal C\)</span>. Researchers soon realised that this method is very powerful and can be applied to a variety of functors <span class="math notranslate nohighlight">\(T\)</span> and categories <span class="math notranslate nohighlight">\(\mathcal C\)</span>. In particular, Scott’s method is also of great interest in situations that are simpler than the one that arises in the semantics of lambda calculus.</p>
<p>For example, the theory of algebraic data types largely concerns itself with polynomial functors <span class="math notranslate nohighlight">\(T\)</span> on the category of sets. Nevertheless, initial algebra semantics, as developed in the 1980ies and 90ies, is a powerful tool with many applications to programming languages.</p>
<p>An important observation is that for most categories, contrary to what happens in Scott’s original setting, initial algebra semantics and final coalgebra semantics fall apart. It was only in the 1990ies that researchers gradually became aware that in such situations the final coalgebra semantics is at least as important for applications to programming languages as the initial algebra semantics.</p>
<p>Roughly speaking, the relationship between initial algebra and final coalgebra semantics is as follows. From the universal properties of inital algebra and final coalgebra it follows that there is a unique arrow</p>
<div class="math notranslate nohighlight">
\[I\to Z\]</div>
<p>from the initial algebra <span class="math notranslate nohighlight">\(TI\to I\)</span> to the final coalgebra <span class="math notranslate nohighlight">\(Z\to TZ\)</span>. Intuitively the initial algebra is the algebra of finite terms, while the final coalgebra is the coalgebra of infinite terms. Finite terms are important to model data and programs. Infinite terms are important to model program behaviour, in particular non-terminating computations.</p>
<p>(to be continued)</p>
</section>
<span id="document-contents/The-Landscape-of-Coalgebraic-Logic"></span><section class="tex2jax_ignore mathjax_ignore" id="the-landscape">
<h2>The Landscape<a class="headerlink" href="#the-landscape" title="Permalink to this headline">#</a></h2>
<p>These notes were prepared for the workshop <a class="reference external" href="https://soroushrrad.wixsite.com/my-site-1/workshop-1">Exploring Baltag’s Universe</a> celebrating <a class="reference external" href="https://sites.google.com/site/thealexandrubaltagsite/research/publications">Alexandru Baltag’s</a> 55th birthday.</p>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h3>
<p>I met Alexandru first in 1997 in the pages of the book “Vicious Circles” by Barwise and Moss, from which I quote the introduction of the section that contains some of the earliest results in the area of coalgebra and modal logic:</p>
<p>![](https://hackmd.io/_uploads/BJpkRix6F.png =500x)</p>
<p>For some time this Alexandru Baltag remained a mythical person.  There was no trace to find of him on the internet, which, even at that time, seemed curious given that he had important theorems to his name. Was he a practical joke of Barwise and Moss? But it wasn’t long before Alexandru and I met at <a class="reference external" href="http://www.aiml.net/conferences/aiml-1998/">AiML 1998</a> and we have been friends ever since.</p>
<p>The literature on colagebras and modal is considerable, so, on this occasion, I will restrict myself to a (personal and necessarily biased) selection of some of the main ideas.</p>
<p>Starting from modal logic, one can see a development of subsequent generalisations and specialisations, each move adding to the theory of coalgebraic logic a new dimension, or parameter, along which the general framework can be adjusted in a compositional and uniform manner in order to take into account various modelling requirements.</p>
<p>The starting point of modern research into coalgebras was Aczel’s “Non-Wellfounded Set Theory” from 1988, which not only had a direct influence on “Vicious Circles”, but also showed (amongst other discoveries) that the notion of bisimilarity well-known in modal logic and concurrency theory generalises to coalgebras for a functor. We will denote this functor by <span class="math notranslate nohighlight">\(T\)</span> (for transition type).</p>
<p>One question raised by Aczel’s discovery was whether the many important results in modal logic and in concurrency have generalisations to arbitrary functors <span class="math notranslate nohighlight">\(T\)</span>. This was the first dimension of coalgebraic logic and is the starting point for what follows.</p>
</section>
<section id="dimensions-of-coalgebraic-logic">
<h3>Dimensions of Coalgebraic Logic<a class="headerlink" href="#dimensions-of-coalgebraic-logic" title="Permalink to this headline">#</a></h3>
<p>In the talk I sketched a three dimensional picture. One axis had the functor <span class="math notranslate nohighlight">\(T\)</span> (the type of transitions, eg non-determinstic, probabilistic, etc), a second axis had the modal theory,  a third one had the base category. This axes, or dimensions, appear in red below (and there are more than three).</p>
<p>We start from modal logic, thinking of a class of Kripke frames axiomatized by a modal theory. Generalising from Kripke frames to <span class="math notranslate nohighlight">\(T\)</span>-coalgebras, we also need to generalise the standard modal operators <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>. There are two ways to do this known as Moss’s <span class="math notranslate nohighlight">\(\nabla\)</span> and as Pattinson’s predicate liftings.</p>
<p>Next one can ask what can be done in case of a general base cateagory <span class="math notranslate nohighlight">\(\mathcal C\)</span>. Dualising the Lawvere-Linton account of algebra over a general base category one is lead to a theory of “modal predicate transformer”, that is, predicate transformers preserving coalgebraic bisimilarity.</p>
<p>But over a general base category, we have no handle on the syntax of the logic. To improve on this, one can specalise to categories <span class="math notranslate nohighlight">\(\mathcal C\)</span> that have a Stone dual <span class="math notranslate nohighlight">\(\mathcal A\)</span>. A modal logic for coalgebras for <span class="math notranslate nohighlight">\(T:\mathcal C\to\mathcal C\)</span> is then given by a functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span>.</p>
<hr class="docutils" />
<p>I summarise this development by describing an <font color=blue>object of study</font> and its  <font color=red>mathematical formalisation</font></p>
<blockquote>
<div><p>followed by a move</p>
</div></blockquote>
<p>leading to a new <font color=blue>object of study</font> and a new  <font color=red>mathematical formalisation</font>.</p>
<hr class="docutils" />
<p><font color=blue>Classical modal logic.</font>
Parameter: <font color=red>Theory <span class="math notranslate nohighlight">\(\Lambda\)</span></font>.</p>
<blockquote>
<div><p>Generalise Kripke frames to <span class="math notranslate nohighlight">\(T\)</span>-coalgebras.</p>
</div></blockquote>
<p><font color=blue>Moss’s Coalgebraic Logic, Pattinson’s predicate liftings.</font><a class="footnote-reference brackets" href="#mosspattinson" id="id1">1</a>
Parameter: <font color=red> Functor <span class="math notranslate nohighlight">\(T\)</span></font>. <a class="footnote-reference brackets" href="#rankone" id="id2">2</a> <a class="footnote-reference brackets" href="#composingfunctors" id="id3">3</a></p>
<blockquote>
<div><p>Generalise to arbitrary base categories <span class="math notranslate nohighlight">\(\mathcal C\)</span>.</p>
</div></blockquote>
<p><font color=blue>Predicate transformers <span class="math notranslate nohighlight">\(\mathcal C(-,n)\to \mathcal C(-,m)\)</span>.</font> <a class="footnote-reference brackets" href="#predicatetransformers" id="id4">4</a>
Parameter: <font color=red>Category <span class="math notranslate nohighlight">\(\mathcal C\)</span>.</font><a class="footnote-reference brackets" href="#category" id="id5">5</a> <a class="footnote-reference brackets" href="#category2" id="id6">6</a></p>
<blockquote>
<div><p>Specialise to categories <span class="math notranslate nohighlight">\(\mathcal C\)</span> that have a Stone dual <span class="math notranslate nohighlight">\(\mathcal A\)</span>.</p>
</div></blockquote>
<p><font color=blue>Basic modal logic as a functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span>.</font>
Parameter: Adjunction <font color=red><span class="math notranslate nohighlight">\(Spec \dashv Pred: \mathcal C^{op}\to \mathcal A\)</span>.</font> <a class="footnote-reference brackets" href="#adjunction" id="id7">7</a></p>
<blockquote>
<div><p>Generalise to enriched adjunctions.</p>
</div></blockquote>
<p><font color=blue>Basic modal logic as a functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span>.</font>
Parameter: <font color=red>Enrichment</font>. <a class="footnote-reference brackets" href="#enrichment" id="id8">8</a></p>
<blockquote>
<div><p>Specialise to a quantale <span class="math notranslate nohighlight">\(\Omega\)</span> of truth values.</p>
</div></blockquote>
<p><font color=blue>Basic modal logic as a functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span>.</font>
Parameter:  <font color=red>Lattice <span class="math notranslate nohighlight">\(\Omega\)</span> of truth values</font>. <a class="footnote-reference brackets" href="#quantale" id="id9">9</a></p>
<hr class="docutils" />
<p><strong>Remark on Rank 1 Axioms:</strong> While <span class="math notranslate nohighlight">\(T\)</span>-coalgebras generalise Kripke frames, <span class="math notranslate nohighlight">\(L\)</span> generalises the corresponding basic modal logic. Note that the axioms of basic modal logic such as <span class="math notranslate nohighlight">\(\Box (a\to b)\to \Box a \to \Box b\)</span> are special in the sense that they are of “rank 1”, that is, every propositional variable is in the scope of exactly one modal operator. While this does not prevent us from adding more general axioms, rank 1 axioms are special because they can be accounted for by a functor. <a class="footnote-reference brackets" href="#monad" id="id10">10</a> Since functors allows us to apply special methods such as the final coalgebra and the initial algebra sequence, it can sometimes be useful to study a logic by separating out its rank 1 fragment. This technique was pioneered by Ghilardi, see eg <a class="reference external" href="https://staff.fnwi.uva.nl/n.bezhanishvili/Papers/Bezh-Ghi-Jib-Revised.pdf">Bezhanishvili, Ghilardi and Jibladze</a> for an overview and further references.</p>
<p><strong>Remark on Deriving Canonical Parameters from the Lattice of Truth Values:</strong> Work on the lattice <span class="math notranslate nohighlight">\(\Omega\)</span> of truth values as a parameter is ongoing (with Jiri Velebil and Adriana Balan). One question is how a choice of <span class="math notranslate nohighlight">\(\Omega\)</span> determines a “canonical” Stone type adjunction which in turn determines a “canonical” logic (given concretely in terms of operations and proof system).</p>
<p><strong>Summary of the Design Space of Coalgebraic Logic:</strong> Choose</p>
<ul class="simple">
<li><p>the lattice of truth values <span class="math notranslate nohighlight">\(\Omega\)</span>,</p></li>
<li><p>a base category <span class="math notranslate nohighlight">\(\mathcal C\)</span> of state spaces,</p></li>
<li><p>a functor <span class="math notranslate nohighlight">\(T:\mathcal C\to\mathcal C\)</span> of transition types,</p></li>
<li><p>a Stone type adjunction <span class="math notranslate nohighlight">\(Spec \dashv Pred: \mathcal C^{op}\to \mathcal A\)</span> for a propositional logic</p></li>
<li><p>a functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span> for a modal expansion,</p></li>
<li><p>a theory <span class="math notranslate nohighlight">\(\Lambda\)</span> of <span class="math notranslate nohighlight">\(L\)</span>-formulas. <a class="footnote-reference brackets" href="#designspace" id="id11">11</a></p></li>
</ul>
<p><strong>Additional “Non-Category Theoretic” Dimensions:</strong> In this presentation I concentrated on parameters that have category theoretic representations as categories, functors, adjunctions or enrichements. There are further dimensions one can add. For example: <a class="reference external" href="https://staff.science.uva.nl/y.venema/papers/catbr.pdf">Kupke and Venema</a> add winning conditions to automata-as-<span class="math notranslate nohighlight">\(T\)</span>-coalgebras in order to give semantics to a <em>coalgebraic <span class="math notranslate nohighlight">\(\mu\)</span>-calculus</em>; <a class="reference external" href="https://lmcs.episciences.org/4390">Litak, Pattinson, Sano and Schröder</a> develop  <em>coalgebraic  predicate logic</em>. <a class="reference external" href="https://users.cecs.anu.edu.au/~dpattinson/Publications/ic2010.pdf">Pattinson and Schröder</a> investigate the <em>proof theory of coalgebraic logics</em>; <a class="reference external" href="https://users.cecs.anu.edu.au/~dpattinson/Publications/ijcar2014.pdf">Gorín etal</a> build generic software tools paramaterised by <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>See also the survey paper <a class="reference external" href="https://users.cecs.anu.edu.au/~dpattinson/Publications/cj2011.pdf">Modal logics are coalgebraic</a>. Comput. J., 2011.</p>
</section>
<section id="acknowledgements">
<h3>Acknowledgements<a class="headerlink" href="#acknowledgements" title="Permalink to this headline">#</a></h3>
<p>I thank Alexandru Baltag, Nick Bezhanishvili and Nima Motamed for their questions and comments.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Coalgebraic logic draws on many influences. To mention just a few: Aczel in set theory; Goldblatt, van Benthem, Ghilardi in modal logic; Scott, Plotkin, Abramsky in domain theory; Johnstone on Stone duality. Coalgebras started to move into the mainstream of computer science with work by Jacobs and Rutten and the CMCS workshops the first of which took place in 1998.</p>
<p>In the following, I only list the work which I had time to mention in the presentation (but see also the references linked in the text above).</p>
<ul class="simple">
<li><p>Baltag’s Theorems in Barwise and Moss, <em>Vicious Circles</em>, 1996.</p></li>
<li><p>Lawrence Moss: Coalgebraic Logic. 1997.</p></li>
<li><p>Alexandru Baltag. “A Structural Theory of Sets”, AIML 1998.</p></li>
<li><p>Dirk Pattinson: Coalgebraic modal logic: soundness, completeness and decidability of local consequence. Theor. Comput. Sci. 309(1-3): 177-193 (2003)</p></li>
<li><p>Alexander Kurz, Jirí Rosický: Operations and equations for coalgebras. Math. Struct. Comput. Sci. 15(1): 149-166 (2005)</p></li>
<li><p>Clemens Kupke, Yde Venema: Coalgebraic Automata Theory: Basic Results. Log. Methods Comput. Sci. 4(4) (2008)</p></li>
<li><p>Alexander Kurz, Jirí Rosický: Strongly Complete Logics for Coalgebras. Log. Methods Comput. Sci. 8(3) (2012)</p></li>
<li><p>Alexander Kurz, Jiri Velebil: Enriched Logical Connections. Appl. Categorical Struct. 21(4): 349-377 (2013)</p></li>
<li><p>Fredrik Dahlqvist, Alexander Kurz: The Positivication of Coalgebraic Logics. CALCO 2017</p></li>
<li><p>Adriana Balan, Alexander Kurz, Jiri Velebil: Extending set functors to generalised metric spaces. Log. Methods Comput. Sci. 15(1) (2019)</p></li>
<li><p>Adriana Balan, Alexander Kurz: An equational approach to enriched distributivity. CoRR abs/2112.13290 (2021)</p></li>
</ul>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="mosspattinson"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Moss and Pattinson show in different ways that one can retain some control over the syntax and stay parametric in <span class="math notranslate nohighlight">\(T\)</span>. A chosen set of predicate liftings can be considered another parameter. This is similar to choose a basic set of operations when defining categories of algebras.</p>
</dd>
<dt class="label" id="rankone"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Some axioms, so called axioms of rank 1, can be incorporated in <span class="math notranslate nohighlight">\(T\)</span>, but general axioms (such as transitivity)  live on in their own dimension (the parameter of modal theories).</p>
</dd>
<dt class="label" id="composingfunctors"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Composing functors is compositional, as is composing their logics. (It is well-known in the semantics of programming languages that there are problems composing the monads for non-determinism and probability, but here we only compose functors. See <a class="reference external" href="https://hal.archives-ouvertes.fr/hal-02564365/document">(Goy and Petrisan, 2020)</a> for a recent work on composing the monads.)</p>
</dd>
<dt class="label" id="predicatetransformers"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Naturality of the predicate transformers guarantess that they are invariant under coalgebraic bisimilarity.</p>
</dd>
<dt class="label" id="category"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>One might say that the functor <span class="math notranslate nohighlight">\(T:\mathcal C\to\mathcal C\)</span> is just one parameter comprising both <span class="math notranslate nohighlight">\(\mathcal C\)</span> and <span class="math notranslate nohighlight">\(T\)</span>, but one can extend functors along varying <span class="math notranslate nohighlight">\(\mathcal C\)</span>. For example, the powerset functor on sets extends to the convex powerset functor on posets, to the Vietoris functor on Stone spaces, to the Plotkin powerdomain on domains, to the Hausdorff metric for metric spaces, etc.</p>
</dd>
<dt class="label" id="category2"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>Changing the base category can be used to model a variety of different phenomena. Partially ordered sets can be used to weaken bisimulation to simulation. Categories of algebras can be used to equip coalgebras (seen as automata) with internal memory. Categories such as nominal sets (and various presheaf categories) can be used to treat binding and local store. Measurable spaces are useful for probabilistic transition systems. Starting from a given logic, categories of topological spaces (such as Stone spaces) can be used to obtain coalgebraic semantics that is dually equivalent to the corresponding algebraic semantic. Categories of domains can be used to obtain solutions for mixed variance domain equations and build models for the untyped lambda calculus.</p>
</dd>
<dt class="label" id="adjunction"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>The adjunction can be varied to put different logics into the same picture. For example, starting from Sets, one my use boolean algebras or complete atomic boolean algebras as the semantics. One may also want to drop negation or only retain conjunction. On the other hand, starting from, say Boolean algebras, one may want to topologise the semantic side and consider Stone spaces.</p>
</dd>
<dt class="label" id="enrichment"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p>Enrichment is useful to enrich the notion of bismilarity. For example, order enriched category theory deals with simulations and metric-space enriched category deals with metric bisimulations.</p>
</dd>
<dt class="label" id="quantale"><span class="brackets"><a class="fn-backref" href="#id9">9</a></span></dt>
<dd><p>A quantale <span class="math notranslate nohighlight">\(\Omega\)</span> determines a “multi-ordered set” (<span class="math notranslate nohighlight">\(\Omega\)</span>-enriched category) with an order for each element of the quantale and composition of orderes governed by the multiplication of the quantale. Metric spaces are a special case of multi-ordered sets. The category of multi-ordered sets (<span class="math notranslate nohighlight">\(\Omega\)</span>-enriched categories) then serves as the base category <span class="math notranslate nohighlight">\(\mathcal C\)</span> over which one takes <span class="math notranslate nohighlight">\(T\)</span>-coalgebras.</p>
</dd>
<dt class="label" id="monad"><span class="brackets"><a class="fn-backref" href="#id10">10</a></span></dt>
<dd><p>While monads provide a means to account for general theories functors account onky for rank 1.</p>
</dd>
<dt class="label" id="designspace"><span class="brackets"><a class="fn-backref" href="#id11">11</a></span></dt>
<dd><p>Some comments on the design space of coalgebraic logic.</p>
<ul class="simple">
<li><p>The quantale <span class="math notranslate nohighlight">\(\Omega\)</span> determines a (residuated) lattice of truth values and a multi-order (metric) on the state space.</p></li>
<li><p>The base category <span class="math notranslate nohighlight">\(\mathcal C\)</span> can add topological structure and/or algebraic structure. Topological structure can be used to designate definable/observable sets of states. Algebraic structure can be used to add memory to states.</p></li>
<li><p>The functor <span class="math notranslate nohighlight">\(T:\mathcal C\to\mathcal C\)</span> chooses the “computational effects” of interest, which can include combinations of input/output, non-determinism, probability and more. Some computational effects (such as variable binding and function space or continuous probability) require base categories <span class="math notranslate nohighlight">\(\mathcal C\)</span> with special properties while others (such as powerset) can be varied uniformly over a range of base categories.</p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> determines the notion of bisimilarity (observational equivalence, behavioural equivalence) of interest.</p></li>
<li><p>The logic <span class="math notranslate nohighlight">\(L\)</span> can either be obtained as the Stone dual of <span class="math notranslate nohighlight">\(T\)</span> or created in an adhoc fashion to suit particular modelling requirements.</p></li>
<li><p>Various “bells and whistles” can be added.</p></li>
</ul>
</dd>
</dl>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-contents/Powerdomains"></span><section class="tex2jax_ignore mathjax_ignore" id="powerdomains">
<h2>Powerdomains<a class="headerlink" href="#powerdomains" title="Permalink to this headline">#</a></h2>
<p>Powerdomains can be seen as modelling non-determinstic choice. They appear in various areas of mathematics and computer science.</p>
<p>We review the basic relationships between lower/upper powerdomains, forward and backward simulation, and <span class="math notranslate nohighlight">\(\Diamond\)</span> and <span class="math notranslate nohighlight">\(\Box\)</span> modalities.</p>
<p>It may be worth to read the <span class="xref myst">Summary</span> first.</p>
<section id="an-axiomatic-account-of-choice">
<h3>An Axiomatic Account of Choice<a class="headerlink" href="#an-axiomatic-account-of-choice" title="Permalink to this headline">#</a></h3>
<p>A somewhat minimal axiomatisation of a choice operator <span class="math notranslate nohighlight">\(\odot\)</span> is</p>
<div class="amsmath math notranslate nohighlight" id="equation-c53906fb-77fd-4bb0-a7ed-3e2fc572b4f2">
<span class="eqno">(2)<a class="headerlink" href="#equation-c53906fb-77fd-4bb0-a7ed-3e2fc572b4f2" title="Permalink to this equation">#</a></span>\[\begin{gather}
(x\odot y)\odot z= x\odot (y\odot z)\\
x\odot y = y\odot x\\
x\odot x = x
\end{gather}\]</div>
<p>What is axiomatised here is choice as a set of alternatives. Given a set <span class="math notranslate nohighlight">\(X\)</span>, we denote by <span class="math notranslate nohighlight">\(\mathcal PX\)</span> the set of subsets of <span class="math notranslate nohighlight">\(X\)</span> and by <span class="math notranslate nohighlight">\(\mathcal P_\omega X\)</span> the set of finite subsets of <span class="math notranslate nohighlight">\(X\)</span>. A set with an operation <span class="math notranslate nohighlight">\(\odot\)</span> satisfying the three equations above is known as a <strong>semi-lattice</strong>.</p>
<p><strong>Facts:</strong></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal P_\omega X\)</span> is the free semi-lattice over <span class="math notranslate nohighlight">\(X\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\((\mathcal P_\omega,\eta,\mu)\)</span> with <span class="math notranslate nohighlight">\(\eta(x)=\{x\}\)</span> and <span class="math notranslate nohighlight">\(\mu(A)=\bigcup A\)</span> where <span class="math notranslate nohighlight">\(A\subseteq\mathcal P_\omega X\)</span> is a monad and the algebras for the monad are the semi-lattices.</p></li>
<li><p>Semi-lattices can be equipped with an order in two ways. The first corresponds to taking <span class="math notranslate nohighlight">\(\mathcal P_\omega X\)</span> with inclusion of subsets and the second to reverse inclusion.</p>
<ul>
<li><p>The operation <span class="math notranslate nohighlight">\(\odot\)</span> is the join in the poset generated by  <span class="math notranslate nohighlight">\(x\le x\odot y\)</span>.</p></li>
<li><p>The operation <span class="math notranslate nohighlight">\(\odot\)</span> is the meet in the poset generated by  <span class="math notranslate nohighlight">\(x\ge x\odot y\)</span>.</p></li>
</ul>
</li>
<li><p>Similarly, <span class="math notranslate nohighlight">\(\mathcal P\)</span> gives us complete semi-lattices. The initial algebra for the functor <span class="math notranslate nohighlight">\(\mathcal P\)</span> is our usual set-theoretic universe, while the final coalgebra fo the functor <span class="math notranslate nohighlight">\(\mathcal P\)</span> is Aczel’s universe of non-well founded sets. <a class="footnote-reference brackets" href="#size" id="id1">1</a></p></li>
</ul>
<p><strong>Remark:</strong> Semi-lattices exist in many categories. This often allows us to generalise non-determinism.</p>
</section>
<section id="coalgebras-for-the-powerset-functor">
<h3>Coalgebras for the Powerset Functor<a class="headerlink" href="#coalgebras-for-the-powerset-functor" title="Permalink to this headline">#</a></h3>
<p>More often than not, the reason to investigate choice is to model dynamic scenarios where agents change state by making choices. Such dynamical systems are known as <em>coalgebras</em> for the powerset functor and also as  <em>transition systems</em> in process algebra and as <em>non-determinstic automata</em> in the theory of automata and formal languages and as <strong>Kripke frames</strong> in the theory of modal logic.</p>
<p>Mathematically, a coalgebra is a function <span class="math notranslate nohighlight">\(X\to\mathcal PX\)</span>. A coalgebra morphism</p>
<div class="math notranslate nohighlight">
\[
(X\stackrel \xi \to \mathcal PX)
\stackrel f\longrightarrow (X'\stackrel {\xi'} \to \mathcal PX')
\]</div>
<p>is a function <span class="math notranslate nohighlight">\(f:X\to X'\)</span> satisfying</p>
<div class="math notranslate nohighlight">
\[\mathcal Pf\circ \xi = \xi\circ f.\]</div>
<p>In other words, <span class="math notranslate nohighlight">\(f\)</span> makes the following square commute.</p>
<p><img alt="" src="https://i.imgur.com/wpaU0or.png" /></p>
<p>Of course, a coalgebra on <span class="math notranslate nohighlight">\(X\)</span> is nothing but a set with a relation <span class="math notranslate nohighlight">\(R\subseteq X\times X\)</span>. But coalgebra morphisms do not only preserve the relation but also reflect it in a particular way. Key to this is the following.</p>
<p><strong>Exercise on (bi)simulation:</strong> We write <span class="math notranslate nohighlight">\(xRy\)</span> for <span class="math notranslate nohighlight">\(y\in\xi(x)\)</span>. The following are equivalent conditions for <span class="math notranslate nohighlight">\(f\)</span> being a <strong>forward simulation</strong>.</p>
<div class="amsmath math notranslate nohighlight" id="equation-4bd24b94-1a48-45da-8e6a-a4d2b8649347">
<span class="eqno">(3)<a class="headerlink" href="#equation-4bd24b94-1a48-45da-8e6a-a4d2b8649347" title="Permalink to this equation">#</a></span>\[\begin{gather}
\mathcal Pf\circ \xi \ \subseteq \ \xi'\circ f\\
xRy \ \Rightarrow \ f(x) R' f(y)\\
x'=f(x) \ \Rightarrow \ \forall y\in\xi(x)\,.\,\exists y'\in\xi'(x')\,.\,y'=f(x')
\end{gather}\]</div>
<p>The following are equivalent conditions for <span class="math notranslate nohighlight">\(f\)</span> being a <strong>backward simulation</strong>.</p>
<div class="amsmath math notranslate nohighlight" id="equation-259c3826-d2e7-4585-9eaf-fc65cfbfef67">
<span class="eqno">(4)<a class="headerlink" href="#equation-259c3826-d2e7-4585-9eaf-fc65cfbfef67" title="Permalink to this equation">#</a></span>\[\begin{gather}
\mathcal Pf\circ \xi \ \supseteq \ \xi'\circ f\\
f(x)R'y' \ \Rightarrow \ \exists y\,.\, xRy \ \&amp; \  y'=f(y)\\
x'=f(x) \ \Rightarrow \ \forall y'\in\xi'(x')\,.\,\exists y\in\xi(x)\,.\,y'=f(x')
\end{gather}\]</div>
<p>The advantage of the first conditions is that they are parametric in the functor<a class="footnote-reference brackets" href="#parametric" id="id2">2</a>, the second condition is how so-called zig-zag morphisms or p-morphisms or bounded morphisms are defined in modal logic and the third conditions establish the following important fact that will continue to play a role in this note (we will give a precise definition of bisimulation later).</p>
<p><strong>Fact:</strong> A function is a coalgebra morphism iff its graph is a bisimulation.</p>
</section>
<section id="powerdomains-on-posets">
<h3>Powerdomains on Posets<a class="headerlink" href="#powerdomains-on-posets" title="Permalink to this headline">#</a></h3>
<p>The “domain” in powerdomain comes from domain theory and the theory of programming languages. It is well-known that in order to model recursively defined programs and datatypes in general one needs to extend the types-as-sets paradigm to types-as-domains. There are different ways to define domains. Typically, they  involve some kind of complete order or complete metric that supports the taking of certain limits to interpret recursively defined functions. In this section, I simplify by ignoring completeness and only look at domains as ordered sets.</p>
<section id="functors">
<h4>Functors<a class="headerlink" href="#functors" title="Permalink to this headline">#</a></h4>
<p>The powerset functor gives rise to three different powerdomains on the category of partial orders according to whether we enforce one of one of the following two alternatives.</p>
<div class="amsmath math notranslate nohighlight" id="equation-9b7128da-3292-452c-8b5c-adc4e84e6326">
<span class="eqno">(5)<a class="headerlink" href="#equation-9b7128da-3292-452c-8b5c-adc4e84e6326" title="Permalink to this equation">#</a></span>\[\begin{gather}
x\le x\odot y\\
x\ge x\odot y
\end{gather}\]</div>
<section id="convex-powerdomain">
<h5>Convex Powerdomain<a class="headerlink" href="#convex-powerdomain" title="Permalink to this headline">#</a></h5>
<p>The functor</p>
<div class="math notranslate nohighlight">
\[\mathcal P^\rm c:\sf Pos \to Pos\]</div>
<p>maps a poset <span class="math notranslate nohighlight">\((X,\le)\)</span> to the set of convex subsets <span class="math notranslate nohighlight">\(\mathcal PX\)</span>. The order on convex subsets is defined as follows. <a class="footnote-reference brackets" href="#back-forth" id="id3">3</a> <a class="footnote-reference brackets" href="#pjust" id="id4">4</a></p>
<div class="amsmath math notranslate nohighlight" id="equation-a1534a77-1084-4c95-aab9-ede4f5fcd5af">
<span class="eqno">(6)<a class="headerlink" href="#equation-a1534a77-1084-4c95-aab9-ede4f5fcd5af" title="Permalink to this equation">#</a></span>\[\begin{align}
a\le b\  \quad \textrm{ if } \quad &amp; \forall x\in a\,.\,\exists y\in b. x\le y \quad \textrm{ and }\\
&amp;\forall y\in b\,.\,\exists x\in a. x\le y\\
\end{align}\]</div>
<p>If <span class="math notranslate nohighlight">\(X\)</span> is discrete then <span class="math notranslate nohighlight">\(\mathcal P^\rm c X\)</span> is just  <span class="math notranslate nohighlight">\(\mathcal PX\)</span> and <span class="math notranslate nohighlight">\(\le\)</span> is equality.</p>
</section>
<section id="lower-powerdomain">
<h5>Lower Powerdomain<a class="headerlink" href="#lower-powerdomain" title="Permalink to this headline">#</a></h5>
<p>The functor</p>
<div class="math notranslate nohighlight">
\[\mathcal D:\sf Pos \to Pos\]</div>
<p>maps a poset <span class="math notranslate nohighlight">\((X,\le)\)</span> to the set of downward closed subsets (downsets) <span class="math notranslate nohighlight">\(\mathcal DX\)</span>. The order on subsets <span class="math notranslate nohighlight">\(a,b\subseteq X\)</span> is defined as <a class="footnote-reference brackets" href="#dpre" id="id5">5</a> <a class="footnote-reference brackets" href="#djust" id="id6">6</a></p>
<div class="amsmath math notranslate nohighlight" id="equation-bc0b2e8a-5893-43d5-996b-2b6f63635890">
<span class="eqno">(7)<a class="headerlink" href="#equation-bc0b2e8a-5893-43d5-996b-2b6f63635890" title="Permalink to this equation">#</a></span>\[\begin{align}
a\le b\  \quad \textrm{ if } \quad &amp; \forall x\in a\,.\,\exists y\in b. x\le y
\end{align}\]</div>
<p>which amounts to inclusion of downsets. If <span class="math notranslate nohighlight">\(X\)</span> is discrete then <span class="math notranslate nohighlight">\(\mathcal DX\)</span> is <span class="math notranslate nohighlight">\(\mathcal PX\)</span> ordered by <span class="math notranslate nohighlight">\(\subseteq\)</span>.</p>
</section>
<section id="upper-powerdomain">
<h5>Upper Powerdomain<a class="headerlink" href="#upper-powerdomain" title="Permalink to this headline">#</a></h5>
<p>The functor <span class="math notranslate nohighlight">\(\mathcal U:\sf Pos \to Pos\)</span> maps a poset <span class="math notranslate nohighlight">\((X,\le)\)</span> to the set of upward closed subsets (upsets) <span class="math notranslate nohighlight">\(\mathcal UX\)</span>. The order on upsets is defined as <a class="footnote-reference brackets" href="#ujust" id="id7">7</a></p>
<div class="amsmath math notranslate nohighlight" id="equation-59a00ff4-6eab-4f29-a2f5-a2313dd60c1a">
<span class="eqno">(8)<a class="headerlink" href="#equation-59a00ff4-6eab-4f29-a2f5-a2313dd60c1a" title="Permalink to this equation">#</a></span>\[\begin{align}
a\le b\  \quad \textrm{ if } \quad &amp; \forall y\in b\,.\,\exists x\in a. x\le y
\end{align}\]</div>
<p>which amounts to reverse inclusion of upsets. If <span class="math notranslate nohighlight">\(X\)</span> is discrete then <span class="math notranslate nohighlight">\(\mathcal UX\)</span> is <span class="math notranslate nohighlight">\(\mathcal PX\)</span> ordered by <span class="math notranslate nohighlight">\(\supseteq\)</span>.</p>
</section>
</section>
<section id="coalgebras">
<h4>Coalgebras<a class="headerlink" href="#coalgebras" title="Permalink to this headline">#</a></h4>
<p>As noted above, coalgebras <span class="math notranslate nohighlight">\(X\to\mathcal PX\)</span> are in bijective correspondence with Kripke frames <span class="math notranslate nohighlight">\((X,R)\)</span>. This continues to hold in the ordered setting under appropriate conditions on the relation <span class="math notranslate nohighlight">\(R\)</span>.</p>
<p><span class="math notranslate nohighlight">\((X,R)\)</span> is an <span class="math notranslate nohighlight">\(\mathcal U\)</span>-coalgebra iff <span class="math notranslate nohighlight">\(R\)</span> is a weakening relation, that is, iff</p>
<div class="math notranslate nohighlight">
\[\frac{x'\le x R y \le y'}{x'R y'}\]</div>
<p><span class="math notranslate nohighlight">\((X,R)\)</span> is an <span class="math notranslate nohighlight">\(\mathcal D\)</span>-coalgebra iff</p>
<div class="math notranslate nohighlight">
\[\frac{x'\ge x R y \ge y'}{x'R y'}\]</div>
<p><strong>Example:</strong> Let <span class="math notranslate nohighlight">\(X=\{x,y\}\)</span> be a Kripke frame where <span class="math notranslate nohighlight">\(x\)</span> has no successor and <span class="math notranslate nohighlight">\(y\)</span> is reflexive. We can turn <span class="math notranslate nohighlight">\(X\)</span> into a <span class="math notranslate nohighlight">\(\mathcal U\)</span>-coalgebra by setting <span class="math notranslate nohighlight">\(x\le y\)</span> and into a <span class="math notranslate nohighlight">\(\mathcal D\)</span>-coalgebra by setting <span class="math notranslate nohighlight">\(x\ge y\)</span>.</p>
</section>
<section id="bi-simulations">
<h4>(Bi)simulations<a class="headerlink" href="#bi-simulations" title="Permalink to this headline">#</a></h4>
<p>As for set-functors, any functor on ordered sets gives rise to a canonical notion of <strong>(bi)simulation</strong>,  <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/HyQxhrh_v">cospan bisimulation</a>. In case of <span class="math notranslate nohighlight">\(\mathcal P^\rm c\)</span>-coalgebras (bi)simulation is bisimulation, in case of <span class="math notranslate nohighlight">\(\mathcal U\)</span>-coalgebras (bi)simulation is backward simulation and in case of  <span class="math notranslate nohighlight">\(\mathcal D\)</span>-coalgebras (bi)simulation is forward simulation.</p>
<p><strong>Fact:</strong> The largest preorder on a <span class="math notranslate nohighlight">\(\mathcal U\)</span>-coalgebra (<span class="math notranslate nohighlight">\(\mathcal D\)</span>-coalgebra) compatible with the coalgebra structure is the largest backward-simulation (forward simulation) on that coalgebra. <a class="footnote-reference brackets" href="#compatible" id="id8">8</a></p>
<p>To understand this better it helps to know more about <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/SJs53demu">coalgebraic (bi)similarity</a>. But I will try to shortcut this here, with more details available at <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/HyQxhrh_v">cospan (bi)simulation</a>.</p>
<p>In order to define the notion of (bi)simulation induced by <span class="math notranslate nohighlight">\(\mathcal U\)</span> or <span class="math notranslate nohighlight">\(\mathcal D\)</span> we proceed as follows.</p>
<ul class="simple">
<li><p>A relation <span class="math notranslate nohighlight">\(R\)</span> from <span class="math notranslate nohighlight">\(X\)</span> to <span class="math notranslate nohighlight">\(Y\)</span> will be represented as an order <span class="math notranslate nohighlight">\(\bf R\)</span> on the disjoint union <span class="math notranslate nohighlight">\(X+Y\)</span>.</p></li>
<li><p>Because of the universal property of the coproduct, there always will be a coalgebra <span class="math notranslate nohighlight">\({\bf R}\to T{\bf R}\)</span> where <span class="math notranslate nohighlight">\(T\)</span> is either <span class="math notranslate nohighlight">\(\mathcal U\)</span> or <span class="math notranslate nohighlight">\(\mathcal D\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(R\)</span> is a (bi)simulation iff <span class="math notranslate nohighlight">\({\bf R}\to T{\bf R}\)</span> is monotone.</p></li>
</ul>
<p>Recall from the definition of  <span class="math notranslate nohighlight">\(\mathcal D\)</span> and <span class="math notranslate nohighlight">\(\mathcal U\)</span> how these functors act on ordered sets.<a class="footnote-reference brackets" href="#du" id="id9">9</a> Instantiating this procedure it is not difficult to see the following.</p>
<p><strong>Proposition on <span class="math notranslate nohighlight">\(\mathcal D\)</span>- and <span class="math notranslate nohighlight">\(\mathcal U\)</span>-(bi)simulation:</strong> <span class="math notranslate nohighlight">\(\mathcal D\)</span>-(bi)simulation is forward-simulation and <span class="math notranslate nohighlight">\(\mathcal U\)</span>-(bi)simulation is backward-simulation.</p>
</section>
<section id="simulations-for-set-coalgebras">
<h4>Simulations for Set-Coalgebras<a class="headerlink" href="#simulations-for-set-coalgebras" title="Permalink to this headline">#</a></h4>
<p>Each functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> induces a notion of <span class="math notranslate nohighlight">\(T\)</span>-bisimulation.</p>
<p>What about simulations?</p>
<p>We first note that each functor <span class="math notranslate nohighlight">\(T:\sf Ord\to Ord\)</span> induces a notion of <span class="math notranslate nohighlight">\(T\)</span>-(bi)simulation.<a class="footnote-reference brackets" href="#ord" id="id10">10</a> I write (bi)simulation here because technically this notion works much in the same way for <span class="math notranslate nohighlight">\(\sf Set\)</span>-functors and for <span class="math notranslate nohighlight">\(\sf Ord\)</span>-functors. But for <span class="math notranslate nohighlight">\(\sf Ord\)</span>-functors, it encompasses both simulations and bisimulations, depending on the functor.</p>
<p>A general way to introduce notions of simulation for <span class="math notranslate nohighlight">\(\sf Set\)</span> functors is as follows. Let <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> be a functor. Extend <span class="math notranslate nohighlight">\(T\)</span> to a functor <span class="math notranslate nohighlight">\(T':\sf Ord\to Ord\)</span>.<a class="footnote-reference brackets" href="#extend" id="id11">11</a> Then restrict <span class="math notranslate nohighlight">\(T'\)</span>-(bi)simulation to <span class="math notranslate nohighlight">\(T\)</span>-coalgebras.</p>
<p><strong>Example:</strong> Let <span class="math notranslate nohighlight">\(T=\mathcal P\)</span>. We can let <span class="math notranslate nohighlight">\(T'\)</span> be one of <span class="math notranslate nohighlight">\(\mathcal P^\rm c\)</span> or <span class="math notranslate nohighlight">\(\mathcal U\)</span> or <span class="math notranslate nohighlight">\(\mathcal D\)</span> to capture bisimulation or forward simulation or backward simulation.</p>
<p><strong>Remark:</strong> The ordered setting is the right one if we want to exploit that the structures at hand support an order-duality. In the example, <span class="math notranslate nohighlight">\(\mathcal U\)</span> and <span class="math notranslate nohighlight">\(\mathcal D\)</span> capture <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> separately and both extend <span class="math notranslate nohighlight">\(\mathcal P\)</span>.</p>
</section>
</section>
<section id="powerdomains-via-generators-and-relations">
<h3>Powerdomains via Generators and Relations<a class="headerlink" href="#powerdomains-via-generators-and-relations" title="Permalink to this headline">#</a></h3>
<p>The finitary versions of the three powerdomains can be generated as follows. The way we describe algebras by generators and relation is the same as over sets, with the only difference that we now require <span class="math notranslate nohighlight">\(\odot\)</span> to be order-preserving (monotone).</p>
<p>If <span class="math notranslate nohighlight">\(X\)</span> is a finite poset, then the finitely generated convex subsets <span class="math notranslate nohighlight">\(\mathcal P_\omega^\rm c X\)</span> are ismorphic to the free semi-lattice over <span class="math notranslate nohighlight">\(X\)</span>. Convexity is captured by the requirement that <span class="math notranslate nohighlight">\(\odot\)</span> is montone. <a class="footnote-reference brackets" href="#fingenconv" id="id12">12</a></p>
<p>If <span class="math notranslate nohighlight">\(X\)</span> is a finite poset, then the finitely generated downsets <span class="math notranslate nohighlight">\(\mathcal D_\omega X\)</span> are ismorphic to the free semi-lattice over <span class="math notranslate nohighlight">\(X\)</span> satisfying <span class="math notranslate nohighlight">\(x\le x\odot y\)</span>, or, equivalently, the free join semi-lattice over <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(X\)</span> is a finite poset, then the finitely generated upsets <span class="math notranslate nohighlight">\(\mathcal U_\omega X\)</span> are ismorphic to the free semi-lattice over <span class="math notranslate nohighlight">\(X\)</span> satisfying <span class="math notranslate nohighlight">\(x\odot y\le x\)</span>, or, equivalently, the free meet semi-lattice over <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>To remember how taking upsets and downsets interacts with the order, it is helpful to know the following.</p>
<p><strong>Facts:</strong> Let <span class="math notranslate nohighlight">\(X\)</span> be a preorder. <span class="math notranslate nohighlight">\(\mathcal DX\)</span> is the free complete join semi lattice over <span class="math notranslate nohighlight">\(X\)</span>. <span class="math notranslate nohighlight">\(\mathcal D\)</span> is a monad on preorders (and also on posets). The unit <span class="math notranslate nohighlight">\(X\to\mathcal DX=[X^\rm o,2]\)</span> is the order enriched Yoneda embedding.<a class="footnote-reference brackets" href="#yoneda" id="id13">13</a> The Yoneda embedding is a free completion by colimits (joins). The <span class="math notranslate nohighlight">\(x\le x\odot y\)</span> play the role of the arrows into the colimit (coproduct, join). (The Yoneda embedding preserves all limits (meets) that may already exist in <span class="math notranslate nohighlight">\(X\)</span>.) The multiplication of the monad is the free extension of the identity <span class="math notranslate nohighlight">\(\mathcal DX\to\mathcal DX\)</span>.</p>
</section>
<section id="modal-logic">
<h3>Modal Logic<a class="headerlink" href="#modal-logic" title="Permalink to this headline">#</a></h3>
<p>We have seen that coalgebra morphisms express a particular back-and-forth condition. It is interesting to study its logical ramifications.</p>
<p>The key questions are: Which logic is invariant under coalgebra morphisms (bisimulation)? Which logic is invariant under forward (or backward) simulation?</p>
<section id="the-logic-of-bisimulation">
<h4>The Logic of Bisimulation<a class="headerlink" href="#the-logic-of-bisimulation" title="Permalink to this headline">#</a></h4>
<p>The answer is given by the “bounded quantifiers” <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>. Usually they are considered as syntactic operations on formulas. But I want to treat them here as operations on “semantic” propositions, that is, on subsets of <span class="math notranslate nohighlight">\(X\)</span> where $<span class="math notranslate nohighlight">\(\xi:X\to\mathcal PX\)</span>$</p>
<p>is a coalgebra. We rewrite the usual definition of the semantics of <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> in terms of the coalgebra structure <span class="math notranslate nohighlight">\(\xi\)</span> as follows.</p>
<div class="amsmath math notranslate nohighlight" id="equation-763fcfba-a2b9-4d57-97c3-40f6eea4db20">
<span class="eqno">(9)<a class="headerlink" href="#equation-763fcfba-a2b9-4d57-97c3-40f6eea4db20" title="Permalink to this equation">#</a></span>\[\begin{gather}
\Box a = \xi^{-1}(\{b\subseteq X \mid b\subseteq a\})\\
\Diamond a =  \xi^{-1}(\{b\subseteq X \mid a\cap b\not=\emptyset\})
\end{gather}\]</div>
<p><strong>Exercise:</strong> The following are a direct consequence of the definition above.</p>
<div class="amsmath math notranslate nohighlight" id="equation-a56dceb3-e6ab-4dda-a590-3dce846cdc1f">
<span class="eqno">(10)<a class="headerlink" href="#equation-a56dceb3-e6ab-4dda-a590-3dce846cdc1f" title="Permalink to this equation">#</a></span>\[\begin{gather}
x\in \Box a \quad \Longleftrightarrow \quad \forall y\in\xi(x)\,.\, y\in a\\
x\in \Diamond a \quad \Longleftrightarrow \quad \exists y\in\xi(x)\,.\, y\in a
\end{gather}\]</div>
<p>We can now extend propositional logic by unary operators for <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> (and all equations they satisfy in all coalgebras). This is known as the modal logic <span class="math notranslate nohighlight">\(\bf K\)</span>.</p>
<p>Here are some classic results of modal logic. I use “coalgebra” instead of “Kripke frame” to indicate that these results generalise.</p>
<p><strong>Facts:</strong> The modal logic <span class="math notranslate nohighlight">\(\bf K\)</span> is invariant under coalgebra morphisms. Every logic that contains classical propositional logic and is invariant under bisimulation is equivalent to <span class="math notranslate nohighlight">\(\bf K\)</span> on finite coalgebras. <span class="math notranslate nohighlight">\(\bf K\)</span> characterises elements of coalgebras up to bisimilarity on finite coalgebras. <span class="math notranslate nohighlight">\(\bf K\)</span> is the bisimulation-invariant fragment of first-order logic.</p>
<p>The notion of bisimilarity can be defined in different ways. From a coalgebraic point of view I find the following the most elegant.</p>
<p>Two elements of two <span class="math notranslate nohighlight">\(\mathcal P\)</span>-coalgebras are <strong>bisimilar</strong> (or <strong>behaviourally equivalent</strong>) iff they can be connected by some zig-zag of morphisms. <a class="footnote-reference brackets" href="#bisimilar" id="id14">14</a></p>
<p>The advantage of this definition is that it captures the informal idea that coalgebra-morphisms preserve behaviour and that it is parametric in the functor. But we also want a more combinatorial characterisation:</p>
<p>Given two coalgebras <span class="math notranslate nohighlight">\(X\stackrel \xi \to \mathcal PX\)</span> and <span class="math notranslate nohighlight">\(X'\stackrel {\xi'} \to \mathcal PX'\)</span> a relation <span class="math notranslate nohighlight">\(R\subseteq X\times X'\)</span> is called a <strong>bisimulation</strong> if</p>
<div class="amsmath math notranslate nohighlight" id="equation-099ec638-6346-4c99-94e6-b2ac9ebef403">
<span class="eqno">(11)<a class="headerlink" href="#equation-099ec638-6346-4c99-94e6-b2ac9ebef403" title="Permalink to this equation">#</a></span>\[\begin{align} 
x Rx' \ \ \textrm{ only if } \quad
&amp; \forall y\in \xi(x)\,.\,\exists y'\in\xi'(x')\,.\, x'Ry' \quad \textrm {and}\\
&amp; \forall y'\in \xi'(x')\,.\,\exists y\in\xi(x)\,.\, x'Ry'\\
\end{align}\]</div>
<p><strong>Facts:</strong> Two elements of two coalgebras are bisimilar iff there is a bisimulation relating them. If two elements of two coalgebras are bisimular then they satisfy the same modal formulas. The converse is true on finite coalgebras (or if we extend modal logic by infinitary conjunctions).</p>
</section>
<section id="logics-of-simulation">
<h4>Logics of Simulation<a class="headerlink" href="#logics-of-simulation" title="Permalink to this headline">#</a></h4>
<p>A finer analysis, separating forward and backward simulation, is possible. It also sheds light on the ordered generalisations of the powerset functor.</p>
<p>Let me write <span class="math notranslate nohighlight">\({\bf K}^\Box\)</span> and <span class="math notranslate nohighlight">\({\bf K}^\Diamond\)</span> (this is not standard notation) for the negation-free fragment of <span class="math notranslate nohighlight">\(\bf K\)</span> that only contains <span class="math notranslate nohighlight">\(\Box\)</span> (respectively <span class="math notranslate nohighlight">\(\Diamond\)</span>) formulas. It now turns out that preservation of <span class="math notranslate nohighlight">\({\bf K}^\Box\)</span>-formulas and preservation of <span class="math notranslate nohighlight">\({\bf K}^\Diamond\)</span>-formulas each corresponds to one direction of the definition of bisimulation.</p>
<!--
Let $f$ be a coalgebra morphism and $\phi\in\bf K^\Box$. Then 
$$x\in\phi \quad \Longleftrightarrow \quad $$
-->
<p>As the <em>Exercise on (bi)simulation</em> above shows, <span class="math notranslate nohighlight">\({\bf K}^\Diamond\)</span>-formulas are invariant under forward-simulation and <span class="math notranslate nohighlight">\({\bf K}^\Box\)</span>-formulas are invariant under backward-simulation.</p>
<p>On the other hand, we know from the <em>Proposition on <span class="math notranslate nohighlight">\(\mathcal D\)</span>- and <span class="math notranslate nohighlight">\(\mathcal U\)</span>-(bi)simulation</em> that <span class="math notranslate nohighlight">\(\mathcal D\)</span>-(bi)simulation is forward-simulation and <span class="math notranslate nohighlight">\(\mathcal U\)</span>-(bi)simulation is backward simulation.</p>
<p>We now assembled all the pieces needed for the table below.</p>
</section>
</section>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">#</a></h3>
<p>To read the table recall that, for a poset <span class="math notranslate nohighlight">\(X\)</span>,  the elements of <span class="math notranslate nohighlight">\(\mathcal DX\)</span> are downsets ordered according to <span class="math notranslate nohighlight">\(\ a\le b \ \Leftrightarrow\  a\subseteq b\)</span> and the elements of <span class="math notranslate nohighlight">\(\mathcal UX\)</span> are upsets ordered as  <span class="math notranslate nohighlight">\(\ a\le b \ \Leftrightarrow\  a\supseteq b\)</span> .</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p><span class="math notranslate nohighlight">\(T\)</span></p></th>
<th class="text-center head"><p><span class="math notranslate nohighlight">\(\mathcal D\)</span></p></th>
<th class="text-center head"><p><span class="math notranslate nohighlight">\(\mathcal U\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>also known as</p></td>
<td class="text-center"><p>Hoare powerdomain</p></td>
<td class="text-center"><p>Smyth powerdomain</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\odot\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\cup\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\cup\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(a\le b\in TX\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\forall x\in a\,.\,\exists y\in b\,.\, x\le y\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\forall y\in b\,.\,\exists x\in a\,.\, x\le y\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>semilattice + …</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(a\le a\odot b\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(a \odot b \le a\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>(bi)simulation</p></td>
<td class="text-center"><p>forward</p></td>
<td class="text-center"><p>backward</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>logic</p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Diamond\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(X\stackrel R \longrightarrow TX\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\frac{x'\ge x\,R\,y'\ge y}{x'\,R\,y'}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\frac{x'\le x\,R\,y'\le y}{x'\,R\,y'}\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p></p></td>
<td class="text-center"><p>angelic</p></td>
<td class="text-center"><p>demonic</p></td>
</tr>
</tbody>
</table>
<p>Maybe the most principled way to remember that <span class="math notranslate nohighlight">\(\mathcal U\)</span> gives <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\mathcal D\)</span> gives <span class="math notranslate nohighlight">\(\Diamond\)</span> is via a direct analysis of the predicate liftings of these functors, see my note on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/Sk4WH_fNd">monotone predicate liftings</a>.</p>
<p>A choice satisfying <span class="math notranslate nohighlight">\(a\le a\odot b\)</span> is sometimes called angelic because, whatever <span class="math notranslate nohighlight">\(a\odot b\)</span> is, it is better than what I have, <span class="math notranslate nohighlight">\(a\)</span>. Dually, a demon would make sure that <span class="math notranslate nohighlight">\(a\odot b\)</span> is not better than <span class="math notranslate nohighlight">\(a\)</span> and not better than <span class="math notranslate nohighlight">\(b\)</span>.</p>
</section>
<section id="generalisations">
<h3>Generalisations<a class="headerlink" href="#generalisations" title="Permalink to this headline">#</a></h3>
<p>The basic ideas we have seen so far generalise in many directions.</p>
<p>In domain theory we are typically interested in directed complete partial orders with the Scott topology.</p>
<p>Domains can be seen as particular topological spaces. Many different topological spaces support some kind of powerspace, often called the Vietoris construction.</p>
<p>Vietoris defined a powerdomain on certain topological spaces. A good introduction to the topic is this <a class="reference external" href="https://udenver.zoom.us/rec/play/7RjX2tLeKT1k77hAYU5ESknnw_mF81T3pQyOb9GwVCrfmJTcUVZ1UCB5J4bZ6arcFfDV7e2x-AXpZ9UM.S7zfu-HmUau4bDIJ?continueMode=true&amp;_x_zm_rtaid=z4OFcm27QFSp69I_BMOUkQ.1614750538907.e7098d2d8761d7702e11f6228f8a9179&amp;_x_zm_rhtaid=606">talk by Guram Bezhanishvili</a>. (Passcode: ?D3q#^mw).</p>
<p>The theory can also be developed internally in a topos.</p>
<p>Many results on powerdomains generalise to quantale enriched categories. And some even survive the move to categories or higher categories. The analogy here is that the powerset functor, or rather <span class="math notranslate nohighlight">\(\mathcal U\)</span> and <span class="math notranslate nohighlight">\(\mathcal D\)</span>, generalise to taking presheaves.</p>
<p>…</p>
</section>
<section id="further-reading">
<h3>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">#</a></h3>
<p>(very incomplete)</p>
<section id="topology">
<h4>Topology<a class="headerlink" href="#topology" title="Permalink to this headline">#</a></h4>
<p>Vietoris</p>
<p>Johnstone: Stone Spaces. 1982. See in particular Chapter III.4. On page 112 one finds the definitions of <span class="math notranslate nohighlight">\(\Box\)</span> (called <span class="math notranslate nohighlight">\(t\)</span>) and <span class="math notranslate nohighlight">\(\Diamond\)</span> (called <span class="math notranslate nohighlight">\(m\)</span>). This also works for ordered compact Hausdorff spaces and many other settings, see Guram Bezhanishvili’s talk.</p>
<p>G. Bezhanishvili: Talk on <a class="reference external" href="https://udenver.zoom.us/rec/play/7RjX2tLeKT1k77hAYU5ESknnw_mF81T3pQyOb9GwVCrfmJTcUVZ1UCB5J4bZ6arcFfDV7e2x-AXpZ9UM.S7zfu-HmUau4bDIJ?continueMode=true&amp;_x_zm_rtaid=z4OFcm27QFSp69I_BMOUkQ.1614750538907.e7098d2d8761d7702e11f6228f8a9179&amp;_x_zm_rhtaid=606">The hit-or-miss toplogy</a>. (Passcode: ?D3q#^mw).</p>
</section>
<section id="id15">
<h4>Modal Logic<a class="headerlink" href="#id15" title="Permalink to this headline">#</a></h4>
<p>van Benthem, Segerberg, Goldblatt, …</p>
</section>
<section id="domain-theory">
<h4>Domain Theory<a class="headerlink" href="#domain-theory" title="Permalink to this headline">#</a></h4>
<p><a class="reference external" href="https://homepages.inf.ed.ac.uk/gdp/publications/Powerdomain_Construction.pdf">Plotkin 1976</a>, <a class="reference external" href="https://homepages.inf.ed.ac.uk/gdp/publications/Dijkstras_Predicate_Transformers.pdf">Smyth 1978</a>  <a class="footnote-reference brackets" href="#smyth" id="id16">15</a>, <a class="reference external" href="https://homepages.inf.ed.ac.uk/gdp/publications/Dijkstras_Predicate_Transformers.pdf">Plotkin 1980</a>, <a class="reference external" href="https://ir.cwi.nl/pub/10433">Apt-Plotkin 1981</a>, <a class="reference external" href="https://core.ac.uk/display/82360862">Winskel 1985</a> <a class="footnote-reference brackets" href="#winskel" id="id17">16</a>, Section 6.2 of <a class="reference external" href="https://www.cs.bham.ac.uk/~axj/pub/papers/handy1.pdf">Abramsky-Jung 1994</a>, <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0167642306002115">Martin-Curtis-Rewitzky 2007</a>, Section 3 of <a class="reference external" href="https://www.informatics.sussex.ac.uk/events/domains9/MSCS/Goubault.pdf">Goubault-Larreque 2010</a>, …</p>
</section>
<section id="coalgebra">
<h4>Coalgebra<a class="headerlink" href="#coalgebra" title="Permalink to this headline">#</a></h4>
<p>Aczel: Non-well founded set theory. Aczel-Mendler, …</p>
<p>Barwise, Moss: Vicious Circles.</p>
<p>Baltag: A structural theory of sets.</p>
<p>Rutten: Universal coalgebra.</p>
<p>Jacobs, Hughes-Jacobs, …</p>
<p>Pattinson</p>
<p>Litak etal</p>
<p>…</p>
<p>More references can also be found in the following papers. Kurz-Palmigiano <a class="reference external" href="https://alexhkurz.github.io/papers/KP-cmcs04/cmcs04.pdf">Coalgebras and Modal Expansions of Logics</a>, Kapulkin-Kurz-Velebil <a class="reference external" href="http://www.aiml.net/volumes/volume9/Kapulkin-Kurz-Velebil.pdf">Expressiveness of Positive Coalgebraic Logic</a>, Bilkova-Kurz-Petrisan-Velebil <a class="reference external" href="https://arxiv.org/pdf/1307.4682v3.pdf">Relation lifting, with an application to the many-valued cover modality</a>, Balan-Kurz-Velebil <a class="reference external" href="https://arxiv.org/pdf/1402.5922.pdf">Positive Fragments of Coalgebraic Logics</a>.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="size"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>To make this claim precise, one needs to extend sets with classes and extend the powerset functor continuously.</p>
</dd>
<dt class="label" id="parametric"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>All functors can be extended to functors on ordered sets, see <a class="reference external" href="https://arxiv.org/pdf/1402.5922.pdf">Positive Fragments of Coalgebraic Logics</a>.</p>
</dd>
<dt class="label" id="back-forth"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>Note how the back-and-forth pattern of bisimulations appears again.</p>
</dd>
<dt class="label" id="pjust"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>We could have defined this powerdomain as the set of all subsets instead of restricting to convex subsets. Then <span class="math notranslate nohighlight">\(\mathcal PX\)</span> is a preorder but may not be a partial order. This gives the right definition of the “convex” powerdomain on preorders. In fact, for a preorder <span class="math notranslate nohighlight">\((X,\le)\)</span> and <span class="math notranslate nohighlight">\(a,b\subseteq X\)</span> we have <span class="math notranslate nohighlight">\(a\le b\)</span> iff they have the same posetal quotients of their convex closures.</p>
</dd>
<dt class="label" id="dpre"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Note that the definition of the order <span class="math notranslate nohighlight">\(\le\)</span> makes sense for aribtray subsets of <span class="math notranslate nohighlight">\(X\)</span> (but may only be a preorder then).</p>
</dd>
<dt class="label" id="djust"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>The justification for choosing this half of the convex powerdomain is the following. Two subsets <span class="math notranslate nohighlight">\(a,b\subseteq X\)</span> are in the relation <span class="math notranslate nohighlight">\(a\le b\)</span> iff the downset closure of <span class="math notranslate nohighlight">\(a\)</span> is a subset of the downset closure of <span class="math notranslate nohighlight">\(b\)</span>. It follows that if <span class="math notranslate nohighlight">\(X\)</span> is a poset then the order <span class="math notranslate nohighlight">\(\le\)</span> is also a poset when restricted to downsets.</p>
</dd>
<dt class="label" id="ujust"><span class="brackets"><a class="fn-backref" href="#id7">7</a></span></dt>
<dd><p>As before, the definition of the order makes sense for aribtrary subsets <span class="math notranslate nohighlight">\(a,b\subseteq X\)</span> (and we can use this observation to extend the powerset functor to preorders). Note that <span class="math notranslate nohighlight">\(a\le b\)</span> iff the upset of <span class="math notranslate nohighlight">\(b\)</span> is a subset of the upset of <span class="math notranslate nohighlight">\(a\)</span>. It follows that if <span class="math notranslate nohighlight">\(X\)</span> is a poset then the order <span class="math notranslate nohighlight">\(\le\)</span> is also a poset when restricted to upsets.</p>
</dd>
<dt class="label" id="compatible"><span class="brackets"><a class="fn-backref" href="#id8">8</a></span></dt>
<dd><p>Compatible means that the quotient by the preorder is again a coalgebra.</p>
</dd>
<dt class="label" id="du"><span class="brackets"><a class="fn-backref" href="#id9">9</a></span></dt>
<dd><p>The order on <span class="math notranslate nohighlight">\(\mathcal DX\)</span> is given by \begin{align}
a\le b\  \quad \textrm{ if } \quad &amp; \forall x\in a,.,\exists y\in b. x\le y
\end{align}</p>
<p>and the order on <span class="math notranslate nohighlight">\(\mathcal UX\)</span> by</p>
<div class="amsmath math notranslate nohighlight" id="equation-f256be5f-e62b-40a3-bbc7-a2538737db22">
<span class="eqno">(12)<a class="headerlink" href="#equation-f256be5f-e62b-40a3-bbc7-a2538737db22" title="Permalink to this equation">#</a></span>\[\begin{align}
a\le b\  \quad \textrm{ if } \quad &amp; \forall y\in b\,.\,\exists x\in a. x\le y
\end{align}\]</div>
</dd>
<dt class="label" id="ord"><span class="brackets"><a class="fn-backref" href="#id10">10</a></span></dt>
<dd><p>I like to write <span class="math notranslate nohighlight">\(\sf Ord\)</span> if I do not want to commit to using preorders or posets. If you want to be specific let <span class="math notranslate nohighlight">\(\sf Ord\)</span> be the category of preorders.</p>
</dd>
<dt class="label" id="extend"><span class="brackets"><a class="fn-backref" href="#id11">11</a></span></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(D:\sf Set\to Ord\)</span> be the “discrete” embedding. <span class="math notranslate nohighlight">\(T'\)</span> is an <em>extension</em> of <span class="math notranslate nohighlight">\(T\)</span> if there is a natural transformation <span class="math notranslate nohighlight">\(DT\to T'D\)</span>. For example, if <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> and <span class="math notranslate nohighlight">\(T'=\mathcal U\)</span>, then we have the bijection <span class="math notranslate nohighlight">\((\mathcal PX,=)\to(\mathcal U,\subseteq)\)</span>.</p>
</dd>
<dt class="label" id="fingenconv"><span class="brackets"><a class="fn-backref" href="#id12">12</a></span></dt>
<dd><p>Add more detail …</p>
</dd>
<dt class="label" id="yoneda"><span class="brackets"><a class="fn-backref" href="#id13">13</a></span></dt>
<dd><p>This deserves more explanation …</p>
</dd>
<dt class="label" id="bisimilar"><span class="brackets"><a class="fn-backref" href="#id14">14</a></span></dt>
<dd><p>See the note on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/SJs53demu">Coalgebraic (Bi)Similarity</a> for more.</p>
</dd>
<dt class="label" id="smyth"><span class="brackets"><a class="fn-backref" href="#id16">15</a></span></dt>
<dd><p>On page 26 we find
<img alt="" src="https://hackmd.io/_uploads/ryJYrcOCt.png" /></p>
</dd>
<dt class="label" id="winskel"><span class="brackets"><a class="fn-backref" href="#id17">16</a></span></dt>
<dd><p>On page 128 we find
<img alt="" src="https://hackmd.io/_uploads/r17WO9_0K.png" /></p>
</dd>
</dl>
</section>
</section>
</section>
<span id="document-contents/Neighbourhood-Frames"></span><section class="tex2jax_ignore mathjax_ignore" id="neighbourhood-frames">
<h2>Neighbourhood Frames<a class="headerlink" href="#neighbourhood-frames" title="Permalink to this headline">#</a></h2>
<p>… to be written …</p>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-contents/Coalgebraic-BiSimilarity"></span><section class="tex2jax_ignore mathjax_ignore" id="coalgebraic-bi-similarity">
<h2>Coalgebraic (Bi)Similarity<a class="headerlink" href="#coalgebraic-bi-similarity" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added)</p>
<p>One of the main contributions of coalgebra to computer science is to provide the minimal abstract setting allowing us to account for various different notions of simulation and bisimulation in a uniform way with the help of a single simple parameter, that of a functor <span class="math notranslate nohighlight">\(T\)</span> on a category <span class="math notranslate nohighlight">\(\mathcal C\)</span>.</p>
<p>The objects of the category <span class="math notranslate nohighlight">\(\mathcal C\)</span> represent the possible state spaces and the functor <span class="math notranslate nohighlight">\(T\)</span> represents the possible one-step transitions states can take.</p>
<p>Since (bi)simulation is a relationship betweeen states, the category <span class="math notranslate nohighlight">\(\mathcal C\)</span> should be the category of sets, or of sets with additional structure. The theory of (bi)similarity is not part of the theory of coalgebras that can be developed over arbitrary categories <span class="math notranslate nohighlight">\(\mathcal C\)</span>. <a class="footnote-reference brackets" href="#duality" id="id1">1</a></p>
<p>In the following we will define bisimilarity for set-coalgebras and then look at (bi)similarity for coalgebras over other base categories.</p>
<section id="bisimilarity-for-set-coalgebras">
<h3>Bisimilarity for Set-Coalgebras<a class="headerlink" href="#bisimilarity-for-set-coalgebras" title="Permalink to this headline">#</a></h3>
<p>Every functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> induces a notion of <span class="math notranslate nohighlight">\(T\)</span>-bisimilarity on elements of <span class="math notranslate nohighlight">\(T\)</span>-coalgebras <span class="math notranslate nohighlight">\(X\to TX\)</span>.</p>
<p><strong>Definition:</strong> Bisimilarity (behavioural equivalence) <span class="math notranslate nohighlight">\(\simeq\)</span> is the smallest equivalence relation between elements <span class="math notranslate nohighlight">\((x,X\to TX)\)</span> of coalgebras induced by pairs</p>
<div class="math notranslate nohighlight">
\[(x,X\to TX)\  \simeq\  (f(x),Y\to TY)\]</div>
<p>where <span class="math notranslate nohighlight">\(f:X\to TX\)</span> is a coalgebra morphism.</p>
<p>Intuitively, bisimilarity captures that what is preserved by homomorphisms. <a class="footnote-reference brackets" href="#fhom" id="id2">2</a></p>
<p><strong>Remark (2nd Definition):</strong> Equivalently, this definition can be formulated using cospans. Two elements of two coalgebras are bisimilar (behaviourally equivalent)</p>
<div class="math notranslate nohighlight">
\[(x,X\to TX)\  \simeq\  (y,Y\to TY)\]</div>
<p>if there are coalgebra morphism <span class="math notranslate nohighlight">\(f,g\)</span> with <span class="math notranslate nohighlight">\(f(x)=g(y)\)</span>.</p>
<p>The second definition has the advantage that one does not need to close under transitivity. The first definition has the advantage that it is more conceptual and makes the connection of bisimilarity with the final coalgebra more direct, as we are going to see now.</p>
<p><strong>Observation:</strong> The equivalence classes of bisimilarity are the connected components of the <a class="reference external" href="https://en.wikipedia.org/wiki/Category_of_elements">category of elements</a> of the forgetful functor <span class="math notranslate nohighlight">\({\sf Coalg}( T)\to \sf Set\)</span>.</p>
<p>Recall that colimits in the category of sets can be computed by taking a disjoint sum and then quotienting by connected components. <a class="footnote-reference brackets" href="#quot" id="id3">3</a></p>
<p>This implies, together with the Definition and the Observation, that the colimit of the forgetful functor quotients the disjoint sum of all coalgebras by bisimilarity, yielding the final coalgebra. <a class="footnote-reference brackets" href="#gaft" id="id4">4</a></p>
<p><strong>Prop:</strong> The final coalgebra (if it exists <a class="footnote-reference brackets" href="#am" id="id5">5</a>) is the colimit of the forgetful functor  <span class="math notranslate nohighlight">\(U:{\sf Coalg}( T)\to \sf Set\)</span>.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(Z={\sf colim}\,U\)</span>. The coalgebra structure <span class="math notranslate nohighlight">\(Z\to TZ\)</span> is given by the universal property of the colimit. Moreover, by <span class="math notranslate nohighlight">\(Z\)</span> having a cocone <span class="math notranslate nohighlight">\(c\)</span> over <span class="math notranslate nohighlight">\(U\)</span>, for every <span class="math notranslate nohighlight">\(X\to TX\)</span> there is a morphism <span class="math notranslate nohighlight">\(c_X:X\to Z\)</span>. In particular, there is <span class="math notranslate nohighlight">\(c_Z:Z\to Z\)</span>. It follows from <span class="math notranslate nohighlight">\(Z\)</span> being a colimit that <span class="math notranslate nohighlight">\(c_Z\)</span> is the identity. But this implies that all coalgebra morphisms <span class="math notranslate nohighlight">\(f:X\to Z\)</span> are equal to <span class="math notranslate nohighlight">\(c_X\)</span>. Hence there is precisely one coalgebra morphism <span class="math notranslate nohighlight">\(X\to Z\)</span> and <span class="math notranslate nohighlight">\(Z\to TZ\)</span> is the final coalgebra.</p>
<p><strong>Remark:</strong> This proof is a variation of Lemma 1 in Chapter X of Mac Lane, which shows that the limit of the identity functor is the initial object (and the colimit of the identity functor is the terminal object).</p>
</section>
<section id="bi-similarity-for-ordered-coalgebras">
<h3>(Bi)similarity for Ordered Coalgebras<a class="headerlink" href="#bi-similarity-for-ordered-coalgebras" title="Permalink to this headline">#</a></h3>
<p>We briefly indicate that essentially the same approach to bisimilarity works for coalgebras over ordered sets (preorders or posets). <a class="footnote-reference brackets" href="#preorders" id="id6">6</a></p>
<p>Let <span class="math notranslate nohighlight">\(T:\sf Ord\to Ord\)</span> be a functor.</p>
<p><strong>Definition:</strong> Two elements of two coalgebras are (bi)similar</p>
<div class="math notranslate nohighlight">
\[(x,X\to TX)\  \lesssim\  (y,Y\to TY)\]</div>
<p>if there are coalgebra morphism <span class="math notranslate nohighlight">\(f,g\)</span> such that <span class="math notranslate nohighlight">\(f(x)\le g(y)\)</span>.</p>
<p>Colimits in preorders are computed as in <span class="math notranslate nohighlight">\(\sf Set\)</span> with the preorder on the colimit being the smallest preorder compatible with the preorders on the components. Colimits in posets additionally quotient by <a class="reference external" href="https://en.wikipedia.org/wiki/Antisymmetric_relation">antisymmetry</a>.</p>
<p>We can adapt the category of elements to the ordered setting. Then (bi)similarity is the smallest preorder on the category of elements generated by “connections between components” and the “preorders inside components”.</p>
<p>As before we obtain</p>
<p><strong>Prop:</strong> The final coalgebra (if it exists) is the colimit of the forgetful functor  <span class="math notranslate nohighlight">\({\sf Coalg}( T)\to \sf Ord\)</span>.</p>
</section>
<section id="other-base-categories">
<h3>Other Base Categories<a class="headerlink" href="#other-base-categories" title="Permalink to this headline">#</a></h3>
<p>One could continue here with looking at other base categories such as metric spaces, topological spaces, nominal sets, various categories of algebras, …</p>
<p>I don’t do this (for now) because the literature is big and growing and the new interesting phenomena that arise are particular to the base category one chooses.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Modal Logic: van Benthem, Segerberg, Goldblatt, …</p>
<p>Concurrency: Park, Milner, van Glabbeek, Panangaden, …</p>
<p>Coalgebra: Aczel, Aczel-Mendler, Barr, Rutten, Worrell, Kurz, Staton, Hughes-Jacobs, Balan-Kurz-Velebil, …</p>
<p>Mac Lane: Categories for the Working Mathematician. 1971.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="duality"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>This can be seen from the fact that the theory of coalgebras over <span class="math notranslate nohighlight">\(\mathcal C\)</span> is  the theory of algebras over <span class="math notranslate nohighlight">\(\mathcal C^{\rm op}\)</span>. But the theory that can be developed simultaneously for algebra and coalgebra is quite small in the sense that it excludes most features that are of particular interest to the algebraist or the coalgebraist. Intuitively, the intersection of algebra and coalgebra only consists of those “systems” that can be defined by <em>unary</em> operations such as deterministic automata or, more generally, presheaves.</p>
</dd>
<dt class="label" id="fhom"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>This notion makes sense in any category which has a forgetful functor to <span class="math notranslate nohighlight">\(\sf Set\)</span>. Why is it trivial for categories of algebras?</p>
</dd>
<dt class="label" id="quot"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><em>Exercise:</em> Let <span class="math notranslate nohighlight">\(D:\mathcal I\to \sf Set\)</span> be a functor. Form the disjoint sum <span class="math notranslate nohighlight">\(S\)</span> of all <span class="math notranslate nohighlight">\(D(i)\)</span>, <span class="math notranslate nohighlight">\(i\in\mathcal I\)</span>. Connect <span class="math notranslate nohighlight">\((x,Di)\)</span> with <span class="math notranslate nohighlight">\((y,Dj)\)</span> if there is <span class="math notranslate nohighlight">\(f:i\to j\)</span> in <span class="math notranslate nohighlight">\(\mathcal I\)</span> such that <span class="math notranslate nohighlight">\(f(x)=y\)</span>. Then the connected components of <span class="math notranslate nohighlight">\(S\)</span> are the colimit of <span class="math notranslate nohighlight">\(D\)</span>.</p>
</dd>
<dt class="label" id="gaft"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>For a deeper understanding of final coalgebras, it is instructive to study the proof of the General Adjoint Functor Theroy as it appears in Mac Lane and then the proof of the final coalgebra theorem of Aczel-Mendler. Further contributions to this topic are in papers by Barr, by Adamek-Milius-Velebil and others. Much of this work resolves around the question of what are the most elegant side conditions that allow us to cope with situations where the final coalgebra does not exist in the category of coalgebras. (Footnote: Aczel-Mendler showed that for all set-functors there is a final coalgebra that classifies bisimilarity for all set-coalgebras and the carrier of which is a proper class. I find this still the most elegant formulation of the size problem in coalgebra as it shows exactly where the distinction between <em>set</em> and <em>proper class</em> comes in.)</p>
</dd>
<dt class="label" id="am"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>As shown by Aczel-Mendler, the final coalgebra always exists if one allows coalgebras on proper classes (as opposed to only sets).</p>
</dd>
<dt class="label" id="preorders"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>It is well known, in the classic case of the Kripke frames (coalgebras for the powerset functor), that to ask that <span class="math notranslate nohighlight">\(x,y\)</span> are bisimilar is a stronger requirement than to ask that <span class="math notranslate nohighlight">\(x,y\)</span> are forward and backward bisimilar. Accordingly, it does make a difference whether we take, for example, the final upset-coalgebra over preorders or posets. Over preorders equality in the final coalgebra is bisimilarity and the preorder captures forward-simulation. Over posets, equality means the existence of a forward-simulation in both directions.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Basic-Coalgebraic-Logic"></span><p><span class="math notranslate nohighlight">\(\newcommand{\sem}[1]{\mathopen{[\![} #1 \mathclose{]\!]}}\)</span></p>
<section class="tex2jax_ignore mathjax_ignore" id="basic-coalgebraic-logic">
<h2>Basic Coalgebraic Logic<a class="headerlink" href="#basic-coalgebraic-logic" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added)</p>
<section id="idea">
<h3>Idea<a class="headerlink" href="#idea" title="Permalink to this headline">#</a></h3>
<p>We continue from the <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/r1t-Y6f8L">introduction</a>.</p>
<p>Let</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal X\)</span> the category of sets</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal A\)</span> the category of Boolean algebras</p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> the powerset functor, <span class="math notranslate nohighlight">\(Coalg(T)\)</span> the category of Kripke frames</p></li>
</ul>
<p>Then there is a functor</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(L:BA\to BA\)</span> such that <span class="math notranslate nohighlight">\(Alg(L)\)</span> is the category of BAOs</p></li>
</ul>
<p>where BAOs is the category of Boolean algebras with operators, the standard algebraic semantics of classical modal logic.</p>
<p>In particular,</p>
<ul class="simple">
<li><p>the initial <span class="math notranslate nohighlight">\(L\)</span>-algebra is (the Lindenbaum-Tarski algebra of) basic modal logic. <a class="footnote-reference brackets" href="#freelalgebra" id="id1">1</a></p></li>
</ul>
<p>Moreover,</p>
<ul class="simple">
<li><p>LA is the free Boolean algebra over <span class="math notranslate nohighlight">\(\Box a\)</span>, <span class="math notranslate nohighlight">\(a\in A\)</span> module the equations</p></li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-9bfa61e1-4127-49ca-8205-4c8808a36bc6">
<span class="eqno">(13)<a class="headerlink" href="#equation-9bfa61e1-4127-49ca-8205-4c8808a36bc6" title="Permalink to this equation">#</a></span>\[\begin{align}
\Box\top &amp;= \top \\
\Box(a\wedge b) &amp; = \Box a\wedge \Box b
\end{align}\]</div>
</section>
<section id="the-category-theoretic-approach">
<h3>The category theoretic approach<a class="headerlink" href="#the-category-theoretic-approach" title="Permalink to this headline">#</a></h3>
<p>(should this section go into the intro?)</p>
<p>Here are some simplifications that the category theoretic approach offers:</p>
<ul class="simple">
<li><p><strong>Restricting to the one-step case:</strong> <span class="math notranslate nohighlight">\(TX\)</span> describes the possible successors, here sets of states. <span class="math notranslate nohighlight">\(LPX\)</span> describes one-step modal formulas over sets of successors. <a class="footnote-reference brackets" href="#rank-one" id="id2">2</a> By directly relating <span class="math notranslate nohighlight">\(TX\)</span> and <span class="math notranslate nohighlight">\(LPX\)</span> we can prove many results of modal logic in a one-step form without ever having to nest modal operators.</p></li>
<li><p><strong>Restricting to the finite case:</strong> Since Boolean algebras are defined by operations with finite arity, it is enough to describe <span class="math notranslate nohighlight">\(L\)</span> on the category <span class="math notranslate nohighlight">\(BA_\omega\)</span> of finite Boolean algebras. (Note that <span class="math notranslate nohighlight">\(BA_\omega\)</span> can also be described as the category of finitely presentable BAs and the category of finitely generated BAs.) This has the benefit that we can make explicit use of the fact that <span class="math notranslate nohighlight">\(Set_\omega\)</span> and <span class="math notranslate nohighlight">\(BA_\omega\)</span> are dually equivalent.</p></li>
</ul>
<p>In both situations, the move from the special case to the general case can then be performed by appealing to generic categorical techniques.</p>
<p>The category theoretic approach has also the advantage that the duality of <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(L\)</span> yields, once established, a range of results such as</p>
<ul class="simple">
<li><p>invariance under bisimilarity</p></li>
<li><p>completeness</p></li>
<li><p>expressiveness (Hennessy-Milner, bisimulation somewhere else, …)</p></li>
<li><p>normal forms</p></li>
<li><p>proof systems</p></li>
<li><p>decidability</p></li>
<li><p>complexity</p></li>
</ul>
<p>We need to emphasise that the best results of the coalgebraic approach to modal logic generalise the results from basic modal logic from Kripke frames to other functors <span class="math notranslate nohighlight">\(T\)</span> on a category of “spaces” <span class="math notranslate nohighlight">\(\mathcal X\)</span>. Thus, when we talk about completeness, decidability, complexity, etc this refers to the logics of the functors, not to more general logics that are obtained by adding additional axioms to these logics.</p>
<p>(<em>We need to elaborate on the last point above somewhere!</em>)</p>
</section>
<section id="finding-the-logic-of-a-functor">
<h3>Finding the logic of a functor<a class="headerlink" href="#finding-the-logic-of-a-functor" title="Permalink to this headline">#</a></h3>
<p>Starting from a functor <span class="math notranslate nohighlight">\(T:Set\to Set\)</span>, what is the modal logic of <span class="math notranslate nohighlight">\(T\)</span>-coalgebras?</p>
<p>According to the discussion above, the task is to find a functor <span class="math notranslate nohighlight">\(L:BA\to BA\)</span> such that, restricted to finite sets and finite Boolean algebras, <span class="math notranslate nohighlight">\(L\)</span> is the dual of <span class="math notranslate nohighlight">\(T\)</span>. More precisely, we have to find <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(\delta\)</span> such that
$<span class="math notranslate nohighlight">\(\delta:LP\to PT\)</span>$</p>
<p>is an isomorphism. <a class="footnote-reference brackets" href="#natural-isomorphism" id="id3">3</a></p>
<p>We do this in two steps. The first step is to describe
$<span class="math notranslate nohighlight">\(\delta':L'P\to PT\)</span>$</p>
<p>for <span class="math notranslate nohighlight">\(L'P\)</span> being freely generated by enough modal operators so that <span class="math notranslate nohighlight">\(\delta'\)</span> is injective. This means that the logical one-step language <span class="math notranslate nohighlight">\(L'\)</span> is expressive enough to describe all elements of <span class="math notranslate nohighlight">\(PTX\)</span> uniquely.</p>
<p>The second step is then to quotient
$<span class="math notranslate nohighlight">\( L'P\to LP\)</span>$</p>
<p>in such a way that
$<span class="math notranslate nohighlight">\(PT\to L'P\to LP\)</span>$</p>
<p>becomes an isomorphism. This quotient then describes the axioms of the modal logic. Completeness, as well as other nice properties of the modal logic <span class="math notranslate nohighlight">\(L\)</span> then follow for free from the category theoretic approach hinted at in the previous subsection.</p>
<p>How general is this methodology?</p>
<p>In order to find a nice presentation of <span class="math notranslate nohighlight">\(L\)</span> by generators (modal operators) and relations (modal axioms) one, of course, needs to understand the particular functor <span class="math notranslate nohighlight">\(T\)</span> and this can require a lot of work. But there are general theorems that for all functors <span class="math notranslate nohighlight">\(T\)</span> there exists a functor <span class="math notranslate nohighlight">\(L\)</span>. And, conversely, all functors preserving so-called sifted colimits describe a modal logic given by operations and equations.</p>
</section>
<section id="finding-the-logic-of-the-powerset-functor">
<h3>Finding the logic of the powerset functor<a class="headerlink" href="#finding-the-logic-of-the-powerset-functor" title="Permalink to this headline">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> be the powerset functor. <span class="math notranslate nohighlight">\(T\)</span>-coalgebras are precisely Kripke frames.</p>
<section id="step-1-the-language-and-modal-operations">
<h4>Step 1: The Language and Modal Operations<a class="headerlink" href="#step-1-the-language-and-modal-operations" title="Permalink to this headline">#</a></h4>
<p>For now we side-step the question of how to find the language. We start from the language we know and love, namely the one given by one modal operation <span class="math notranslate nohighlight">\(\Box\)</span>. We also know the standard Kripke semantics of the <span class="math notranslate nohighlight">\(\Box\)</span> via sets of successors. The aim is to show a methodology of how to find the axioms.</p>
<p>The functor <span class="math notranslate nohighlight">\(L'\)</span> is represented by the language without the axioms. It is defined as</p>
<div class="amsmath math notranslate nohighlight" id="equation-9048795c-ec85-463f-a242-9cc0d4e8d46f">
<span class="eqno">(14)<a class="headerlink" href="#equation-9048795c-ec85-463f-a242-9cc0d4e8d46f" title="Permalink to this equation">#</a></span>\[\begin{align}
L':BA&amp; \to BA\\
 A &amp; \mapsto F\{\Box a \mid a\in A\}
\end{align}\]</div>
<p>where <span class="math notranslate nohighlight">\(FX\)</span> denotes the free Boolean algebra over <span class="math notranslate nohighlight">\(X\)</span>. Categorically <span class="math notranslate nohighlight">\(F\)</span> is the left adjoint of the forgetful functor <span class="math notranslate nohighlight">\(U:BA\to Set\)</span>.</p>
<p>The semantics of the language is given by</p>
<div class="amsmath math notranslate nohighlight" id="equation-e85afc47-4ceb-41a4-bb56-b5bb5d83a3ad">
<span class="eqno">(15)<a class="headerlink" href="#equation-e85afc47-4ceb-41a4-bb56-b5bb5d83a3ad" title="Permalink to this equation">#</a></span>\[\begin{align}
\delta'_X:L'PX &amp; \to PTX\\
           \Box a &amp; \mapsto \{S\in PTX \mid S\subseteq a\}
\end{align}\]</div>
<p>This definition expresses that a set of successors <span class="math notranslate nohighlight">\(S\)</span> satisfies <span class="math notranslate nohighlight">\(\Box a\)</span> if the <span class="math notranslate nohighlight">\(S\)</span> is contained in <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>To regain the usual semantics with respect to Kripke frames (ie <span class="math notranslate nohighlight">\(T\)</span>-coalgebras) consider a coalgebra <span class="math notranslate nohighlight">\(\xi:X\to TX\)</span>. Note the following, where <span class="math notranslate nohighlight">\(P\xi\)</span> denotes the inverse image of <span class="math notranslate nohighlight">\(\xi\)</span>:</p>
<ul>
<li><p>The collection <span class="math notranslate nohighlight">\(\Phi\)</span> of all modal formulas is the initial <span class="math notranslate nohighlight">\(L\)</span>-algebra <span class="math notranslate nohighlight">\(L\Phi\to\Phi\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(LPX\stackrel{\delta'_X}{\longrightarrow} PTX\stackrel{P\xi}{\longrightarrow} PX\)</span> is what is known as the “complex algebra” of <span class="math notranslate nohighlight">\((X,\xi)\)</span> in modal logic.</p></li>
<li><p>The universal property of the initial algebra induces a unique
$<span class="math notranslate nohighlight">\(\sem{-}:\Phi\to PX\)</span>$</p>
<p>interpreting formulas as subsets of <span class="math notranslate nohighlight">\(X\)</span>.</p>
</li>
</ul>
<p>Spelling this out in detail, gives us back the usual definition of the semantics of modal logic:</p>
<div class="amsmath math notranslate nohighlight" id="equation-a34471da-94ba-438b-a6ea-cea0fd51ac62">
<span class="eqno">(16)<a class="headerlink" href="#equation-a34471da-94ba-438b-a6ea-cea0fd51ac62" title="Permalink to this equation">#</a></span>\[\begin{align}
\sem{\top} &amp; = X\\
\sem{\phi\wedge \psi} &amp; = \sem{\phi}\wedge\sem{\psi}\\
\sem{\neg\phi} &amp; = X\setminus \sem{\phi}\\
\sem{\Box\phi} &amp; = \{x\in X\mid \xi(x)\in \sem{\phi}\}\\
\end{align}\]</div>
<p>The first three lines come from <span class="math notranslate nohighlight">\(\sem{-}\)</span> being a Boolean algebra morphism and the fourth one from being an <span class="math notranslate nohighlight">\(L\)</span>-algebra morphism.</p>
</section>
<section id="step-2-finding-the-normal-form-of-operations">
<h4>Step 2: Finding the Normal Form of Operations<a class="headerlink" href="#step-2-finding-the-normal-form-of-operations" title="Permalink to this headline">#</a></h4>
<p>We now turn to the task of finding the axioms via normal forms. This involves finding a map
$<span class="math notranslate nohighlight">\( nf: PTX\to L'PX\)</span>$</p>
<p>such that <span class="math notranslate nohighlight">\(\delta'\circ nf = id\)</span>. Since <span class="math notranslate nohighlight">\(PTX\)</span> is a Boolean algebra, it is enough to define <span class="math notranslate nohighlight">\(nf\)</span> on generators and since we can assume <span class="math notranslate nohighlight">\(X\)</span> to be finite, it is enough to give <span class="math notranslate nohighlight">\(nf\)</span> on singletons <span class="math notranslate nohighlight">\(\{t\}\)</span> with <span class="math notranslate nohighlight">\(t\in TX\)</span>. Since <span class="math notranslate nohighlight">\(T=\mathcal P\)</span>, <span class="math notranslate nohighlight">\(t\)</span> is a subset of <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p>Thus, the task is to find a formula in <span class="math notranslate nohighlight">\(L'PX\)</span> that expresses <span class="math notranslate nohighlight">\(t\in TX\)</span>. This formula is well-known in modal logic</p>
<p>(what are the historical references?)</p>
<div class="math notranslate nohighlight">
\[\sem{...}\]</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="freelalgebra"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>More precisely, the initial <span class="math notranslate nohighlight">\(L\)</span>-algebra will be the Lindenbaum-Tarski algebra of classical modal logic with no atomic propositions. To account for a set of atomic proposisions, one takes the free <span class="math notranslate nohighlight">\(L\)</span>-algebra over the Boolean algebra freely generated by the set of atomic propositions.</p>
</dd>
<dt class="label" id="rank-one"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>More precisely, <span class="math notranslate nohighlight">\(LPX\)</span> has formulas in which every generator <span class="math notranslate nohighlight">\(a\in PX\)</span> is under the scope of exactly one modal operation. For example <span class="math notranslate nohighlight">\(\Box(a\wedge b)\)</span> is of rank 1 but neither are <span class="math notranslate nohighlight">\(a\to \Box a\)</span> nor <span class="math notranslate nohighlight">\(\Box\Box a\to \Box a\)</span>. Intuitively, <span class="math notranslate nohighlight">\(a\to \Box a\)</span> expresses a relationship between states in <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(TX\)</span> and <span class="math notranslate nohighlight">\(\Box\Box a\to \Box a\)</span> between states in <span class="math notranslate nohighlight">\(TTX\)</span> and <span class="math notranslate nohighlight">\(TX\)</span>, whereas formulas in <span class="math notranslate nohighlight">\(LPX\)</span> express only relationships between states in <span class="math notranslate nohighlight">\(TX\)</span>.</p>
</dd>
<dt class="label" id="natural-isomorphism"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><span class="math notranslate nohighlight">\(PT\)</span> and <span class="math notranslate nohighlight">\(LP\)</span> are functors <span class="math notranslate nohighlight">\(Set\to BA\)</span>. Hence <span class="math notranslate nohighlight">\(\delta\)</span> should be an arrow in the category of functors <span class="math notranslate nohighlight">\(Set\to BA\)</span>, that is, we require <span class="math notranslate nohighlight">\(\delta\)</span> to be a natural transformation such that all components <span class="math notranslate nohighlight">\(\delta_X:PTX\to LPX\)</span> are isomorphisms.</p>
</dd>
</dl>
</section>
</section>
</section>
<span id="document-contents/Predicate-Liftings"></span><p><span class="math notranslate nohighlight">\(\newcommand{\sem}[1]{\mathopen{[\![}#1\mathclose{]\!]}}\)</span></p>
<section class="tex2jax_ignore mathjax_ignore" id="predicate-liftings">
<h2>Predicate Liftings<a class="headerlink" href="#predicate-liftings" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<section id="definition">
<h3>Definition<a class="headerlink" href="#definition" title="Permalink to this headline">#</a></h3>
<p>A <span class="math notranslate nohighlight">\(n\)</span>-ary predicate lifting for a functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> is a natural transformation</p>
<div class="math notranslate nohighlight">
\[{2^n}^X\to 2^{TX}\]</div>
<p>It follows from the Yoneda lemma that such natural transformations are in bijection with functions</p>
<div class="math notranslate nohighlight">
\[T(2^n)\to 2.\]</div>
<p>In one direction, we apply <span class="math notranslate nohighlight">\({2^n}^X\to 2^{TX}\)</span> to the idenity on <span class="math notranslate nohighlight">\(X=2^n\)</span> to obtain <span class="math notranslate nohighlight">\(T(2^n)\to 2\)</span>.</p>
<p>In the other direction, each <span class="math notranslate nohighlight">\(T(2^n)\to 2\)</span> induces a modal operator as follows.</p>
<p>Given a predicate lifting <span class="math notranslate nohighlight">\(\triangle: T(2^n)\to 2\)</span> and a collection <span class="math notranslate nohighlight">\(\phi:X\to 2^n\)</span> of <span class="math notranslate nohighlight">\(n\)</span> predicates <span class="math notranslate nohighlight">\(\phi_i:X\to 2\)</span>, we obtain <span class="math notranslate nohighlight">\(TX\to 2\)</span> defined as</p>
<div class="math notranslate nohighlight">
\[TX\stackrel {T\phi}\longrightarrow T(2^n)\stackrel\triangle\longrightarrow 2\]</div>
<p>Precomposing with a coalgebra <span class="math notranslate nohighlight">\(X\to TX\)</span> the semantics of a modal formula $<span class="math notranslate nohighlight">\(\triangle \phi\)</span>$</p>
<p>is then given by</p>
<div class="math notranslate nohighlight">
\[X\longrightarrow TX\stackrel {T\phi}\longrightarrow T(2^n)\stackrel\triangle\longrightarrow 2.\]</div>
<p>A good way to understand what is going on here is to explicitely calculate all unary predicate liftings of the powerset functor.</p>
<p>But before doing this let us clarify terminology.</p>
<p>First, to simplify notation, we will only consider unary predicate liftings in the following.</p>
<p><strong>Terminology:</strong> We tend to say <strong>predicate lifting</strong> for the function</p>
<div class="math notranslate nohighlight">
\[\triangle: T2\to 2\]</div>
<p>and <strong>modal operator</strong> (or sometimes <strong>predicate transformer</strong>) for the function that maps a predicate <span class="math notranslate nohighlight">\(\phi\)</span> to the predicate</p>
<div class="math notranslate nohighlight">
\[\triangle\phi: X\to TX \stackrel {T\phi}\longrightarrow T2\stackrel\triangle\longrightarrow 2.\]</div>
<p><strong>Question:</strong> Would it be better to reverse the terminology? Or perhaps as follows:</p>
<ul class="simple">
<li><p>predicate lifting <span class="math notranslate nohighlight">\(2^X\to 2^{TX}\)</span></p></li>
<li><p>predicate transformer <span class="math notranslate nohighlight">\(2^X\to 2^{TX}\to 2^X\)</span></p></li>
<li><p>modal operator: <span class="math notranslate nohighlight">\(T2\to 2\)</span></p></li>
</ul>
<p><strong>Anyway:</strong> Since there is a bijection between predicate liftings and modal operators, we may blur the distinction on occasion.</p>
</section>
<section id="example-powerset">
<h3>Example: Powerset<a class="headerlink" href="#example-powerset" title="Permalink to this headline">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> be the powerset functor.</p>
<p>We see right away that there are 16 modal operators</p>
<div class="math notranslate nohighlight">
\[\mathcal P2\to 2\]</div>
<p>because that is the cardinality of the set of functions of type <span class="math notranslate nohighlight">\(\mathcal P2\to 2\)</span>.</p>
<p>We are interested in explicitely describing all modal operators <span class="math notranslate nohighlight">\(\triangle:\mathcal P2\to 2\)</span> taking predicates <span class="math notranslate nohighlight">\(\phi:X\to 2\)</span> to $<span class="math notranslate nohighlight">\(\mathcal PX\stackrel {\mathcal P\phi}\longrightarrow \mathcal P2\stackrel\triangle\longrightarrow 2\)</span>$</p>
<p>We need to know that <span class="math notranslate nohighlight">\(\mathcal P\phi\)</span> takes direct image. This tells us how to interpret the 4 possible results of applying <span class="math notranslate nohighlight">\(\mathcal P \phi\)</span> to a set <span class="math notranslate nohighlight">\(S\)</span> of successors. Writing <span class="math notranslate nohighlight">\(2=\{0,1\}\)</span>, if <span class="math notranslate nohighlight">\((\mathcal P\phi)S\)</span> is <a class="footnote-reference brackets" href="#aristotle" id="id1">1</a></p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\{0,1\}\)</span> then some successors are outside of <span class="math notranslate nohighlight">\(\phi\)</span> and some are inside of <span class="math notranslate nohighlight">\(\phi\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\{0\}\)</span> then all and some successors are out.</p></li>
<li><p><span class="math notranslate nohighlight">\(\{1\}\)</span> then all and some successors are in.</p></li>
<li><p><span class="math notranslate nohighlight">\(\{\}\)</span> then there are no successors.</p></li>
</ul>
<p>For the purpose of further calculations I propose the following abbreviations:</p>
<div class="math notranslate nohighlight">
\[\varnothing=\{\}
\quad\quad
\overline 0=\{0\}
\quad\quad
\overline{01}=\{0,1\}
\quad\quad
\overline 1=\{1\}
\]</div>
<p>for the elements of <span class="math notranslate nohighlight">\(\mathcal P2\)</span>.</p>
<p><img alt="" src="https://i.imgur.com/QXnFCEZ.png" /></p>
<p><strong>Exercise:</strong> (Assumes familiarity with the classical definition of the modal operators <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>). Show that <span class="math notranslate nohighlight">\(\varnothing,\overline 1\mapsto 1\)</span> defines <span class="math notranslate nohighlight">\(\Box\)</span> and that <span class="math notranslate nohighlight">\(\overline 1,\overline{01}\mapsto 1\)</span> defines <span class="math notranslate nohighlight">\(\Diamond\)</span>. <a class="footnote-reference brackets" href="#zero" id="id2">2</a></p>
<p><strong>Answer.</strong> <a class="footnote-reference brackets" href="#boxdiamond" id="id3">3</a></p>
<p><strong>Observation:</strong> The modal operator <span class="math notranslate nohighlight">\(\Box:\mathcal P2\to 2\)</span> coincides with <span class="math notranslate nohighlight">\(\bigwedge: \mathcal P2\to 2\)</span> and the modal operator <span class="math notranslate nohighlight">\(\Diamond:\mathcal P2\to 2\)</span> coincides with <span class="math notranslate nohighlight">\(\bigvee: \mathcal P2\to 2\)</span>.</p>
<p>Modal logic is expressive up to bisimilarity and this means here that all predicate liftings <span class="math notranslate nohighlight">\(\mathcal P2\to 2\)</span> (and also all <span class="math notranslate nohighlight">\(\mathcal P2^n\to 2\)</span>) are generated by those for <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>. Let us try to support this with some examples:</p>
<p><strong>Exercise:</strong> Using <span class="math notranslate nohighlight">\(\Box,\Diamond\)</span> as well as propositional connectives, express the predicate liftings <span class="math notranslate nohighlight">\(\triangle_\sigma\)</span> defined by <span class="math notranslate nohighlight">\(\sigma\mapsto 1\)</span> where <span class="math notranslate nohighlight">\(\sigma\)</span> ranges over <span class="math notranslate nohighlight">\(\{\varnothing,\overline 0,  \overline{01},\overline 1\}\)</span>. Also verify that <span class="math notranslate nohighlight">\(\Diamond=\neg\Box\neg\)</span> holds for the corresponding predicate liftings.</p>
<p>Our next concern is to better understand the lattice (Boolean algebra) of all unary modal operators of the powerset functor <span class="math notranslate nohighlight">\(\mathcal P\)</span>.</p>
<p>We already noted that there are 16 unary modal operators <span class="math notranslate nohighlight">\(P2\to 2\)</span> and we exhibited some salient examples.</p>
<p>From general facts about Boolean algebras we can deduce the following. The Boolean algebra of modal operators <span class="math notranslate nohighlight">\(P2\to 2\)</span> is isomorphic to the free Boolean algebra on two generators, which I call <span class="math notranslate nohighlight">\(\sf o\)</span> and <span class="math notranslate nohighlight">\(\sf i\)</span>. <a class="footnote-reference brackets" href="#generators" id="id4">4</a> These generators combine to the atoms of the Boolean algebra as</p>
<div class="math notranslate nohighlight">
\[\sf o\wedge i, o\wedge\neg i, \neg o\wedge i, \neg o\wedge\neg i.\]</div>
<p>Every element of the Boolean algebra of modal operators is a join of these atoms.</p>
<p><strong>Exercise:</strong> Define an isomorphism between predicate liftings <span class="math notranslate nohighlight">\(\mathcal P2\to 2\)</span> and the free Boolean algebra generated by <span class="math notranslate nohighlight">\(\{\sf o,i\}\)</span> which maps <span class="math notranslate nohighlight">\(\Box\)</span> to <span class="math notranslate nohighlight">\(\neg\sf o\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> to <span class="math notranslate nohighlight">\(\sf i\)</span>.</p>
<p><strong>Answer.</strong> <a class="footnote-reference brackets" href="#atoms" id="id5">5</a></p>
<p><strong>Remark:</strong> The isomorphism in the previous exercise has been chosen in such a way that the generator <span class="math notranslate nohighlight">\(\sf o\)</span> is interpreted as “some  successors are <strong>o</strong>utside of <span class="math notranslate nohighlight">\(\phi\)</span>” and <span class="math notranslate nohighlight">\(\sf i\)</span> as “some successors are <strong>i</strong>nside”.</p>
<ol class="arabic simple">
<li><p>This choice of interpretation is suggested by how the functor <span class="math notranslate nohighlight">\(\mathcal P\)</span> acts on <span class="math notranslate nohighlight">\(\phi\)</span> (as direct image). In particular, <span class="math notranslate nohighlight">\(\sf o\)</span> symbolizes the observation that the direct image under <span class="math notranslate nohighlight">\(\phi\)</span> of the set of successors  contains <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(\sf i\)</span> that the direct image contains <span class="math notranslate nohighlight">\(1\)</span>.</p></li>
<li><p>From the point of view of Boolean generators there is no reason to prefer <span class="math notranslate nohighlight">\(\sf \neg o\)</span> over <span class="math notranslate nohighlight">\(\sf o\)</span>. But from a logician’s point of view <span class="math notranslate nohighlight">\(\sf \neg o\)</span>, which is <span class="math notranslate nohighlight">\(\Box\)</span>, has the advantage of being a monotone operator. We will study this in more detail in the follow-up note on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/Sk4WH_fNd">monotone predicate liftings</a>.</p></li>
</ol>
<p><strong>Remark:</strong> Items 1. and 2. could be the starting point for a rational reconstruction of why classical modal logic is usually presented in terms of <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>. One would begin with the question of a logic that is invariant under bisimilarity, answer that such a logic is given by the logic of all predicate liftings and then proceed to the insight that <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> generate all predicate liftings in a canonical way.</p>
<p><strong>Summary:</strong> We introduced some notation for the set <span class="math notranslate nohighlight">\(\mathcal P2\)</span></p>
<p><img alt="" src="https://i.imgur.com/VKicAZA.png" /></p>
<p>and then represented the unary modal operators as subsets of <span class="math notranslate nohighlight">\(\mathcal P2\)</span>. For example,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Box=\{\varnothing,\overline 1\} = \neg \sf o\)</span> (“nothing out”)</p></li>
<li><p><span class="math notranslate nohighlight">\(\Diamond = \{\overline 1,\overline{01}\} = \sf i\)</span> (“at least one in”)</p></li>
</ul>
<p>As a corollary we identified <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> as the generators of the free Boolean algebra of all unary predicate liftings.</p>
<p><strong>Puzzle:</strong> If we equip <span class="math notranslate nohighlight">\(\mathcal P2\)</span> with the inclusion order, then <span class="math notranslate nohighlight">\(\Box\)</span> is not a monotone function <span class="math notranslate nohighlight">\(\mathcal P2 \to 2\)</span> (when <span class="math notranslate nohighlight">\(2\)</span> is ordered as <span class="math notranslate nohighlight">\(0&lt;1\)</span>). On the other hand, we do know that <span class="math notranslate nohighlight">\(\Box\)</span> is a monotone modal operator in the sense that <a class="footnote-reference brackets" href="#monotonebox" id="id6">6</a></p>
<div class="math notranslate nohighlight">
\[\frac{\phi\to\psi}{\Box\phi\to\Box\psi}\]</div>
<p>This puzzle will be resolved in a follow-up note on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/Sk4WH_fNd">monotone predicate liftings</a>.</p>
</section>
<section id="example-probability-distributions">
<h3>Example: Probability Distributions<a class="headerlink" href="#example-probability-distributions" title="Permalink to this headline">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(\mathcal D\)</span> be the functor that maps a set <span class="math notranslate nohighlight">\(X\)</span> to the set <span class="math notranslate nohighlight">\(\mathcal DX\)</span> of finitely supported probability distributions.</p>
<p>The unary modalities are given by sets of distributions on 2
$<span class="math notranslate nohighlight">\(\mathcal D2\to 2.\)</span>$</p>
<p>A modal operators <span class="math notranslate nohighlight">\(\triangle:\mathcal D2\to 2\)</span> takes a predicate <span class="math notranslate nohighlight">\(\phi:X\to 2\)</span> to</p>
<div class="math notranslate nohighlight">
\[\mathcal DX\stackrel {\mathcal 
D\phi}\longrightarrow \mathcal D2\stackrel\triangle\longrightarrow 2\]</div>
<p>The atoms of the Boolean algebra are the sets <span class="math notranslate nohighlight">\(\{b_r\}\)</span> where <span class="math notranslate nohighlight">\(b_r(1)=r\)</span>. If <span class="math notranslate nohighlight">\(\triangle\)</span> is <span class="math notranslate nohighlight">\(\{b_r\}\)</span>, then</p>
<div class="math notranslate nohighlight">
\[p\in \sem{\triangle\phi}\ \Leftrightarrow \ Pr(x\in\phi)
=r\]</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="aristotle"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>This reminds me of the <a class="reference external" href="https://plato.stanford.edu/entries/square/">square of opposition</a> in Aristotelian logic. <span class="math notranslate nohighlight">\(\{1\}\)</span> corresponds to <span class="math notranslate nohighlight">\(\phi\)</span> “belongs to all successors”, <span class="math notranslate nohighlight">\(\{0\}\)</span> to <span class="math notranslate nohighlight">\(\phi\)</span> “belongs to no successors”, <span class="math notranslate nohighlight">\(\top\)</span> to “belongs to some but not all”. As far as I understand (not my area of expertise) Aristotle’s logic does not admit <span class="math notranslate nohighlight">\(\varnothing\)</span>.</p>
</dd>
<dt class="label" id="zero"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Here and in the following all elements not explicitly mentioned are sent to <span class="math notranslate nohighlight">\(0\)</span>. For example, writing <span class="math notranslate nohighlight">\(\varnothing,\overline 1\mapsto 1\)</span> implies  <span class="math notranslate nohighlight">\(\overline 0,\overline{01}\mapsto 0\)</span>.</p>
</dd>
<dt class="label" id="boxdiamond"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>For example, in the case of <span class="math notranslate nohighlight">\(\Box\)</span>, one has to verify that with <span class="math notranslate nohighlight">\(\triangle\)</span> defined as <span class="math notranslate nohighlight">\(\varnothing,\overline 1\mapsto 1\)</span> the function <span class="math notranslate nohighlight">\(\mathcal PX\stackrel {\mathcal P\phi}\longrightarrow \mathcal P2\stackrel\triangle\longrightarrow 2\)</span> maps <span class="math notranslate nohighlight">\(S\subseteq X\)</span> to <span class="math notranslate nohighlight">\(1\)</span> iff <span class="math notranslate nohighlight">\(S\subseteq\phi\)</span>.</p>
</dd>
<dt class="label" id="generators"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Intuitively, <span class="math notranslate nohighlight">\(\sf o\)</span> means “some successor outside of <span class="math notranslate nohighlight">\(\phi\)</span>” and <span class="math notranslate nohighlight">\(\sf i\)</span> means “some successor inside <span class="math notranslate nohighlight">\(\phi\)</span>”. It is a lucky coincidence that the symbol <span class="math notranslate nohighlight">\(\sf o\)</span> reminds us of both <strong>o</strong>ut and <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(\sf i\)</span> of both <strong>i</strong>n and <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd>
<dt class="label" id="atoms"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Recall that <span class="math notranslate nohighlight">\(\varnothing\)</span> means “no successor”, <span class="math notranslate nohighlight">\(\overline 0\)</span> means “some and all successor outside of <span class="math notranslate nohighlight">\(\phi\)</span>”, <span class="math notranslate nohighlight">\(\overline 1\)</span> means “some and all successors in <span class="math notranslate nohighlight">\(\phi\)</span>” and <span class="math notranslate nohighlight">\(\overline{01}\)</span> means “some out and some in”.
Accordingly, we map the elements <span class="math notranslate nohighlight">\(\varnothing,\overline 0,\overline{01},\overline 1\in\mathcal P2\)</span> to conjunctions of generators as follows. <span class="math notranslate nohighlight">\(\varnothing \mapsto \sf \neg o\wedge\neg i\)</span>, <span class="math notranslate nohighlight">\(\overline 0\mapsto \sf o\wedge\neg i\)</span>, <span class="math notranslate nohighlight">\(\overline{01}\mapsto \sf o\wedge i\)</span>, <span class="math notranslate nohighlight">\(\overline 1\mapsto \sf\neg o\wedge i\)</span>.</p>
</dd>
<dt class="label" id="monotonebox"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>It also makes sense to replace <span class="math notranslate nohighlight">\(\to\)</span> by <span class="math notranslate nohighlight">\(\le\)</span> if we think of predicates as propositional functions to <span class="math notranslate nohighlight">\(2=\{0&lt;1\}\)</span>.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Monotone-Predicate-Liftings"></span><section class="tex2jax_ignore mathjax_ignore" id="monotone-predicate-liftings">
<h2>Monotone Predicate Liftings<a class="headerlink" href="#monotone-predicate-liftings" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<p>In a previous note, we defined <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/SJcARPMVO">predicate liftings</a> and showed that the unary predicate liftings of the powerset functor are isomorphic to the free Boolean algebra generated by <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>.</p>
<p>Here, we first single out all of those 16 modal operators that are monotone.</p>
<p>Then we are going to test our insights by studying the predicate liftings of two posets functors, namely the upset functor <span class="math notranslate nohighlight">\(\mathcal U\)</span> and the downset functor <span class="math notranslate nohighlight">\(\mathcal D\)</span>.</p>
<section id="set-functors">
<h3>Set Functors<a class="headerlink" href="#set-functors" title="Permalink to this headline">#</a></h3>
<p>We have studied modal operators as predicate liftings</p>
<div class="math notranslate nohighlight">
\[\mathcal P 2\to 2\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathcal P 2\)</span> can be pictured as <a class="footnote-reference brackets" href="#predlift" id="id1">1</a></p>
<p><img alt="" src="https://i.imgur.com/VKicAZA.png" /></p>
<p>Which order on <span class="math notranslate nohighlight">\(\mathcal P2\)</span> exhibits the monotone modal operators as exactly the monotone predicate liftings?</p>
<p>The answer is given by the so-called posetification <a class="footnote-reference brackets" href="#posetification" id="id2">2</a></p>
<div class="math notranslate nohighlight">
\[\overline{\mathcal P}:\sf Pos\to Pos\]</div>
<p>of the functor <span class="math notranslate nohighlight">\(\mathcal P:\sf Set\to Set\)</span>.</p>
<p><strong>Fact:</strong> <span class="math notranslate nohighlight">\(\overline{\mathcal P}\)</span> is the convex powerset functor, that is, for two convex subsets <span class="math notranslate nohighlight">\(a,b\subseteq X\)</span> we have</p>
<div class="amsmath math notranslate nohighlight" id="equation-5251fc29-5ed5-4e4a-906b-0c8635590545">
<span class="eqno">(17)<a class="headerlink" href="#equation-5251fc29-5ed5-4e4a-906b-0c8635590545" title="Permalink to this equation">#</a></span>\[\begin{align}
a\le b\  \quad \textrm{ iff } \quad &amp; \forall x\in a\,.\,\exists y\in b. x\le y \quad \textrm{ and }\\
&amp;\forall y\in b\,.\,\exists x\in a. x\le y\\
\end{align}\]</div>
<p><strong>Exercise:</strong> Recall that <span class="math notranslate nohighlight">\(2=\{0&lt;1\}\)</span>. The order on <span class="math notranslate nohighlight">\(\overline{\mathcal P}2\)</span> is given by <span class="math notranslate nohighlight">\(\{0\}&lt;\{0,1\}&lt;\{1\}\)</span>:</p>
<p>![](https://i.imgur.com/D8YrRFK.png =300x)</p>
<p>It follows that there are <span class="math notranslate nohighlight">\(2\times 4\)</span> monotone predicate liftings <span class="math notranslate nohighlight">\(\overline{\mathcal P}2\to 2\)</span>. The 4 upsets of the chain are</p>
<div class="math notranslate nohighlight">
\[ \{\overline 0,\overline{01},\overline 1\}, \{\overline{01},\overline 1\},  \{\overline 1\}, \{\}\]</div>
<p>We can now list all monotone predicate liftings as follows.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p>subset of <span class="math notranslate nohighlight">\(\mathcal P2\)</span></p></th>
<th class="text-center head"><p>Boolean combination of generators</p></th>
<th class="text-center head"><p>modal formula</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\bot\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\bot\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline 1\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\sf \neg o\wedge i\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\phi\wedge\Diamond\phi\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline{01},\overline 1\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\sf i\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Diamond\phi\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline 0,\overline{01},\overline 1\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\sf o\vee i\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Diamond\top\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\varnothing\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\sf \neg o\wedge\neg i\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\bot\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\varnothing,\overline 1\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\sf \neg o\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\phi\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\varnothing,\overline{01},\overline 1\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\sf \neg o\vee i\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\phi\vee\Diamond\phi\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\varnothing,\overline 0,\overline{01},\overline 1\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\top\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\top\)</span></p></td>
</tr>
</tbody>
</table>
</section>
<section id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">#</a></h3>
<p>We have seen that in the example of the powerset functor that the monotone modal operators correspond precisely to the monotone functions  <span class="math notranslate nohighlight">\(\overline{\mathcal P}2\to 2\)</span> where <span class="math notranslate nohighlight">\(\overline{\mathcal P}\)</span> is the convex powerset functor.</p>
<p>More generally, for any set-functor <span class="math notranslate nohighlight">\(T\)</span>, the <span class="math notranslate nohighlight">\(n\)</span>-ary monotone modal operators (=predicate liftings) are in bijection to the monotone functions</p>
<div class="math notranslate nohighlight">
\[\overline T(2^n)\to 2\]</div>
<p>where <span class="math notranslate nohighlight">\(\overline T\)</span> is the posetification of <span class="math notranslate nohighlight">\(T\)</span>.</p>
</section>
<section id="poset-functors">
<h3>Poset Functors<a class="headerlink" href="#poset-functors" title="Permalink to this headline">#</a></h3>
<section id="the-upset-functor">
<h4>The Upset Functor<a class="headerlink" href="#the-upset-functor" title="Permalink to this headline">#</a></h4>
<p>Let <span class="math notranslate nohighlight">\(\mathcal U\)</span> be the upset functor. Consider</p>
<div class="math notranslate nohighlight">
\[\mathcal UX\stackrel{\mathcal U\phi}\longrightarrow\mathcal U2\longrightarrow 2\]</div>
<p><span class="math notranslate nohighlight">\(\mathcal U2\)</span> is the poset (again <span class="math notranslate nohighlight">\(\overline{01}=\{0,1\}\)</span>, etc)</p>
<div class="math notranslate nohighlight">
\[\overline{01}&lt;\overline{1}&lt;\varnothing\]</div>
<p>which allows us to identify monotone functions <span class="math notranslate nohighlight">\(\mathcal U2\longrightarrow 2\)</span> with upsets:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p>upset of <span class="math notranslate nohighlight">\(\mathcal U2\)</span></p></th>
<th class="text-center head"><p>modal formula</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline{01},\overline 1,\varnothing\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\top\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline 1,\varnothing\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\phi\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\varnothing\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Box\bot\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\bot\)</span></p></td>
</tr>
</tbody>
</table>
<p>The difference between upsets of <span class="math notranslate nohighlight">\(\overline{\mathcal P}2\)</span> and upsets of <span class="math notranslate nohighlight">\(\mathcal U 2\)</span> is that in the latter case the “observation”</p>
<div class="math notranslate nohighlight">
\[\{\overline{01},\overline{1}\}=\sf (o\wedge i)\vee (\neg o\wedge i) = i \quad \textrm{ which corresponds to } \quad \Diamond\phi\]</div>
<p>is not an upset of <span class="math notranslate nohighlight">\(\mathcal U 2\)</span>.</p>
</section>
<section id="the-downset-functor">
<h4>The Downset Functor<a class="headerlink" href="#the-downset-functor" title="Permalink to this headline">#</a></h4>
<p>Let <span class="math notranslate nohighlight">\(\mathcal D\)</span> be the downset functor. Consider</p>
<div class="math notranslate nohighlight">
\[\mathcal DX\stackrel{\mathcal D\phi}\longrightarrow\mathcal D2\longrightarrow 2\]</div>
<p><span class="math notranslate nohighlight">\(\mathcal D2\)</span> is the poset</p>
<div class="math notranslate nohighlight">
\[\varnothing&lt;\overline{0}&lt;\overline{01}\]</div>
<p>which allows us to identify monotone functions <span class="math notranslate nohighlight">\(\mathcal D2\longrightarrow 2\)</span> with upsets:</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-center head"><p>upset of <span class="math notranslate nohighlight">\(\mathcal D2\)</span></p></th>
<th class="text-center head"><p>modal formula</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\varnothing,\overline 0,\overline{01}\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\top\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline 0,\overline{01}\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Diamond\top\)</span></p></td>
</tr>
<tr class="row-even"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\overline{01}\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\Diamond\phi\)</span></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p><span class="math notranslate nohighlight">\(\{\}\)</span></p></td>
<td class="text-center"><p><span class="math notranslate nohighlight">\(\bot\)</span></p></td>
</tr>
</tbody>
</table>
<p>The difference between upsets of <span class="math notranslate nohighlight">\(\overline{\mathcal P}2\)</span> and upsets of <span class="math notranslate nohighlight">\(\mathcal D 2\)</span> is that in the latter case</p>
<div class="math notranslate nohighlight">
\[\{\varnothing,\overline{1}\}=\sf (\neg o\wedge \neg i)\vee (\neg o\wedge i) = \neg o \quad \textrm{ which corresponds to } \quad \Box\phi\]</div>
<p>is not available since <span class="math notranslate nohighlight">\(\overline 1\)</span> is not an element of <span class="math notranslate nohighlight">\(\mathcal D2\)</span>.</p>
</section>
<section id="breakdown-of-duality">
<h4>Breakdown of Duality<a class="headerlink" href="#breakdown-of-duality" title="Permalink to this headline">#</a></h4>
<p>It is interesting to think about why the arguments for <span class="math notranslate nohighlight">\(\mathcal U2\)</span> and <span class="math notranslate nohighlight">\(\mathcal D2\)</span> are not entirely dual.</p>
<p>On the “object level” there is duality: Swapping <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span> and turning the order around is an isomorphism.</p>
<p>This means that it must be the “meta level” which is breaking the duality.</p>
<p>Importantly, for both <span class="math notranslate nohighlight">\(\mathcal U\)</span> and <span class="math notranslate nohighlight">\(\mathcal D\)</span>, the meaning of the predicate liftings depends on the existential quantifier implicit in taking the direct image of <span class="math notranslate nohighlight">\(\phi\)</span>. For example, the statement</p>
<div class="math notranslate nohighlight">
\[\phi[S]=\overline 1
\quad
\textrm{ only if }
\quad
\phi[S]\subseteq \overline{01}\]</div>
<p>is on the meta level and does not dualise. <a class="footnote-reference brackets" href="#doesnot" id="id3">3</a></p>
<p>We summarise the situation with the following picture, depicting <span class="math notranslate nohighlight">\(\mathcal P2\)</span>, <span class="math notranslate nohighlight">\(\mathcal U2\)</span>, <span class="math notranslate nohighlight">\(\mathcal D2\)</span> and the subsets that correspond to <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span>:</p>
<p><img alt="" src="https://i.imgur.com/yy0CrMa.png" /></p>
</section>
<section id="distribution-functor">
<h4>Distribution Functor<a class="headerlink" href="#distribution-functor" title="Permalink to this headline">#</a></h4>
<p><strong>Proposition</strong>: The posetification of the distribution functor is given by <span class="math notranslate nohighlight">\(p\sqsubseteq q\)</span> if <span class="math notranslate nohighlight">\(p[S]\le q[S]\)</span> for all upsets <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p>This order on distributions goes back to (Jones and Plotkin, 1989) for so-called IPOs and was extended to all posets in Worrell 2000. The observation that it is the posetification will appear in (Kurz and Motamed, 2022).</p>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>The definition of the posetification (extension from <span class="math notranslate nohighlight">\(\sf Set\)</span> to <span class="math notranslate nohighlight">\(\sf Pos\)</span>) of an arbitrary set-functor as well as the result on monotone predicate liftings is in</p>
<ul class="simple">
<li><p>Balan, Kurz, Velebil: <a class="reference external" href="https://lmcs.episciences.org/1594">Positive Fragments of Coalgebraic Logics</a>. 2015.</p></li>
</ul>
<p>Theorem 7.1 contains the result that the predicate liftings of the posetification of <span class="math notranslate nohighlight">\(T\)</span> are the monotone predicate liftings of <span class="math notranslate nohighlight">\(T\)</span>.</p>
<div class="math notranslate nohighlight">
\[p_1,p_2:R\to X\]</div>
<p>Moreover, one can reconstruct the poset <span class="math notranslate nohighlight">\((X,R)\)</span> as a certain order-enriched colimit of the diagram <span class="math notranslate nohighlight">\(p_1,p_2:R\to X\)</span>. Then the posetification <span class="math notranslate nohighlight">\(\overline TX\)</span> is defined as the said colimit of <span class="math notranslate nohighlight">\(Tp_1,Tp_2:TR\to TX\)</span>.</p>
<p>The posetification enjoys the universal property of an order-enriched left Kan extension.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="predlift"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Recall that for a predicate lifting <span class="math notranslate nohighlight">\(\triangle\)</span> and a formula <span class="math notranslate nohighlight">\(\varphi:X\to 2\)</span>, the meaning of <span class="math notranslate nohighlight">\(\triangle\phi\)</span> is given by how the composition <span class="math notranslate nohighlight">\(\mathcal PX\stackrel{\mathcal P\phi}\longrightarrow{\mathcal P2}\stackrel \triangle\longrightarrow 2\)</span> acts on a subset ‘of successors’ <span class="math notranslate nohighlight">\(S\in\mathcal PX\)</span>.</p>
</dd>
<dt class="label" id="posetification"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The posetification of a functor <span class="math notranslate nohighlight">\(T\)</span> is defined as follows. Any poset <span class="math notranslate nohighlight">\((X,R)\)</span> can be represented by its “graph”</p>
</dd>
<dt class="label" id="doesnot"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>“<span class="math notranslate nohighlight">\(\phi[S]=\overline 1\)</span> only if <span class="math notranslate nohighlight">\(\phi[S]\subseteq \overline{01}\)</span>” is needed to establish that <span class="math notranslate nohighlight">\(\{\overline{01}\}\subseteq\mathcal D2\)</span> corresponds to <span class="math notranslate nohighlight">\(\Diamond\phi\)</span>.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Expressive-Predicate-Liftings"></span><section class="tex2jax_ignore mathjax_ignore" id="expressive-predicate-liftings">
<h2>Expressive Predicate Liftings<a class="headerlink" href="#expressive-predicate-liftings" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added)</p>
<p>For every functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> there is a natural transformation (<span class="math notranslate nohighlight">\(n\)</span> runs over all positive integers and the product is taken over all finitary predicate liftings)</p>
<div class="math notranslate nohighlight">
\[ TX\to \prod 2^{({2^n}^X)}\]</div>
<p>which, for a choice of predicate lifting <span class="math notranslate nohighlight">\(\triangle: T(2^n)\to 2\)</span> and predicate <span class="math notranslate nohighlight">\(\phi:X\to 2^n\)</span>, applies</p>
<div class="math notranslate nohighlight">
\[TX\stackrel {T\phi} \longrightarrow T(2^n)\stackrel\triangle\longrightarrow 2\]</div>
<p>to elements of  <span class="math notranslate nohighlight">\(TX\)</span>.</p>
<p><strong>Proposition:</strong> The natural transformation is injective on all finite <span class="math notranslate nohighlight">\(X\not=\emptyset\)</span>. <a class="footnote-reference brackets" href="#standard" id="id1">1</a></p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(s\not=t\in TX\)</span>. We have to show that there are <span class="math notranslate nohighlight">\(n\)</span>, <span class="math notranslate nohighlight">\(\phi\)</span> and <span class="math notranslate nohighlight">\(\triangle\)</span> such that <span class="math notranslate nohighlight">\(\triangle(T\phi(s))\not=\triangle(T\phi(t))\)</span>. We choose <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(\phi\)</span> so that <span class="math notranslate nohighlight">\(\phi:X\to 2^n\)</span> is injective. Since <span class="math notranslate nohighlight">\(X\not=\emptyset\)</span> it follows that also <span class="math notranslate nohighlight">\(T\phi\)</span> is injective, that is, <span class="math notranslate nohighlight">\(T\phi(s)\not= T\phi(t)\)</span>. Finally, we choose some <span class="math notranslate nohighlight">\(\triangle:T(2^n)\to 2\)</span> that separates the two.</p>
<p><strong>Remark:</strong> This proofs shows that any two distinct elements of <span class="math notranslate nohighlight">\(TX\)</span> are separated by some predicate <span class="math notranslate nohighlight">\(X\to 2^n\)</span> and predicate lifting <span class="math notranslate nohighlight">\(T(2^n)\to 2\)</span>.</p>
<p><strong>Remark:</strong> For finitary functors <span class="math notranslate nohighlight">\(T\)</span> we can drop the restriction to finite sets.</p>
<p><strong>Corollary:</strong> For a finitary functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> the logic of all predicate liftings is expressive in the sense that for any two non-bisimular points there is a distinguishing formula.</p>
<p>(I can add a proof sketch if that turns out to be of interest.)</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>The results of this section are due to</p>
<ul class="simple">
<li><p>Lutz Schroeder: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0304397507007074?via%3Dihub">Expressivity of coalgebraic modal logic</a>. 2008.</p></li>
</ul>
<p>An axiomatic approach generalising to other categories than Set was presented by</p>
<ul class="simple">
<li><p>Bartek Klin: <a class="reference external" href="https://">link text</a></p></li>
</ul>
<p>The results can also be extended to the poset-enriched situation</p>
<ul class="simple">
<li><p>Kapulkin, Kurz, Velebil: <a class="reference external" href="https://">link text</a></p></li>
</ul>
<p>where expressivity is the stronger property that the logic does not only detect bisimulation but also simulation.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="standard"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>One can eliminate this proviso <span class="math notranslate nohighlight">\(X\not=\emptyset\)</span> by restricting to standard functors. Every set functor has a canonical standard functor which, moreover, induces an equivalent category of coalgebras.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Relation-Lifting"></span><section class="tex2jax_ignore mathjax_ignore" id="relation-lifting">
<h2>Relation Lifting<a class="headerlink" href="#relation-lifting" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<p>Extending a functor from functions to relations is important to coalgebra for at least two reasons. Relation lifting can be used to define bisimulations and also to define Moss’s coalgebraic logic. In the latter case, the idea is to apply the lifted functor to the satisfiability relation.</p>
<p>Relation lifting can be defined in at least two ways, via spans and via cospans. In both cases the idea is to first represent a relation by a pair of arrows, and then to apply the functor to these arrows.</p>
<p>In the following let <span class="math notranslate nohighlight">\(\sf Rel\)</span> be the category which has sets as objects and relations as arrows.</p>
<section id="span-based-relation-lifting">
<h3>Span-Based Relation Lifting<a class="headerlink" href="#span-based-relation-lifting" title="Permalink to this headline">#</a></h3>
<p>The idea of the span-based relation lifting of a functor <span class="math notranslate nohighlight">\(T\)</span> is to “tabulate” a relation <span class="math notranslate nohighlight">\(R\)</span> by a span <span class="math notranslate nohighlight">\(X\stackrel p \leftarrow R\stackrel q\rightarrow Y\)</span> and then to apply the functor <span class="math notranslate nohighlight">\(T\)</span> to the projections, obtaining <span class="math notranslate nohighlight">\(TX\stackrel {Tp} \longleftarrow TR\stackrel {Tq}\longrightarrow TY\)</span>.</p>
<p><strong>Definition:</strong> Let <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> and <span class="math notranslate nohighlight">\(X\stackrel p \leftarrow R\stackrel q\rightarrow Y\)</span> be a relation. Then</p>
<div class="math notranslate nohighlight">
\[\overline T:\sf Rel\to Rel\]</div>
<p>is the relation given by</p>
<div class="math notranslate nohighlight">
\[\overline TR = \{(a,b) \in TX\times TY \mid \exists w\in TR\,.\, Tp(w)=a \ \&amp; \ Tq(w)=b\}\]</div>
<p><strong>Remark:</strong> This formulation is specific to set-functors, but can be generalised to other base categories.</p>
<p><strong>Fact:</strong> <span class="math notranslate nohighlight">\(\overline T\)</span> preserves composition (and therefore is a functor on <span class="math notranslate nohighlight">\(\sf Rel\)</span>) if <span class="math notranslate nohighlight">\(T\)</span> preserves weak-pullbacks.</p>
<p><strong>Example/Exercise:</strong> Let <span class="math notranslate nohighlight">\(\mathcal P\)</span> be the powerset functor. It is an interesting exercise to check that <span class="math notranslate nohighlight">\((a,b)\in \overline{\mathcal P}X\)</span> iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-31f663aa-a876-47d8-881e-224f00111927">
<span class="eqno">(18)<a class="headerlink" href="#equation-31f663aa-a876-47d8-881e-224f00111927" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall x\in \mathcal a\,.\, \exists y\in b\,.\,xRy \\
\forall y\in \mathcal b\,.\, \exists x\in a\,.\,xRy \\
\end{gather}\]</div>
<p><strong>Fact:</strong> <span class="math notranslate nohighlight">\(\overline {\mathcal P} : \sf Rel \to Rel\)</span> is a functor. If <span class="math notranslate nohighlight">\(R\)</span> is a partial order then <span class="math notranslate nohighlight">\(\overline {\mathcal P}R\)</span> is a partial order.</p>
</section>
<section id="extending-set-functors-to-ordered-sets">
<h3>Extending Set-Functors to Ordered Sets<a class="headerlink" href="#extending-set-functors-to-ordered-sets" title="Permalink to this headline">#</a></h3>
<p>The cospan-based relation lifting starts from the cotabulation (or collage) of a relation <span class="math notranslate nohighlight">\(R\)</span> by a cospan <span class="math notranslate nohighlight">\(X\stackrel j \rightarrow \mathbf R\stackrel k\leftarrow Y\)</span>, where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an order on the disjoint union <span class="math notranslate nohighlight">\(X+Y\)</span> given by <span class="math notranslate nohighlight">\((u,v)\in\mathbf R\)</span> iff <span class="math notranslate nohighlight">\(u=v\in X\)</span> or <span class="math notranslate nohighlight">\((u,v)\in R\)</span> or <span class="math notranslate nohighlight">\(u=v\in Y\)</span>.</p>
<p>Thus, in order to apply a set-functor <span class="math notranslate nohighlight">\(T\)</span> to <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(k\)</span>, we need extend <span class="math notranslate nohighlight">\(T\)</span> from sets to orders. This follows the same idea as the relation lifting in the previous section, but now one closes under reflexivity and transitivity (and quotients by anti-symmetry in the case one works with posets).</p>
<p><strong>Definition:</strong> Let <span class="math notranslate nohighlight">\((X,\le)\)</span> be a pre-order. Write <span class="math notranslate nohighlight">\(X\stackrel p \leftarrow {\le}\stackrel q\rightarrow X\)</span> for the two projections. Then <span class="math notranslate nohighlight">\(\widetilde T (X,\le)\)</span> has carrier <span class="math notranslate nohighlight">\(TX\)</span> and the order on <span class="math notranslate nohighlight">\(\widetilde T(X,\le)\)</span></p>
<p>is the smallest order containing</p>
<div class="math notranslate nohighlight">
\[\{(a,b) \in TX\times TX \mid \exists w\in T(\le)\,.\, Tp(w)=a \ \&amp; \ Tq(w)=b\}.\]</div>
<p>This defines a functor</p>
<div class="math notranslate nohighlight">
\[\widetilde T:\sf Ord\to Ord\]</div>
<p>where <span class="math notranslate nohighlight">\(\sf Ord\)</span> can be preorders or posets.</p>
<p><strong>Remark:</strong> The surjection <span class="math notranslate nohighlight">\(\ TX\stackrel s \to \widetilde T (X,\le)\)</span> has a universal property as the universal solution to the inequation to <span class="math notranslate nohighlight">\(s\circ Tp\le s\circ Tq\)</span>. Category theoretically, we can say that <span class="math notranslate nohighlight">\(s\)</span> is the coinserter of <span class="math notranslate nohighlight">\((Tp,Tq)\)</span> and also that <span class="math notranslate nohighlight">\(\widetilde T\)</span> is the (order-enriched) left Kan extension of <span class="math notranslate nohighlight">\(DT\)</span> along <span class="math notranslate nohighlight">\(D\)</span> where <span class="math notranslate nohighlight">\(D\)</span> is the embedding of sets into (discrete) ordered sets.</p>
<p>The following fact allows us to use known results about the span-based relation lifting to compute the order-extension of a set-functor in many examples.</p>
<p><strong>Fact:</strong> If <span class="math notranslate nohighlight">\(T\)</span> preserves weak pullbacks, then applying <span class="math notranslate nohighlight">\(\widetilde T\)</span> to a preorder <span class="math notranslate nohighlight">\((X,\le)\)</span> agrees with applying the relation lifting <span class="math notranslate nohighlight">\(\overline T\)</span> to <span class="math notranslate nohighlight">\(\le\)</span>.</p>
<p><strong>Example:</strong> Let <span class="math notranslate nohighlight">\((X,\le)\)</span> be a preorder. For subsets <span class="math notranslate nohighlight">\(a,b\subseteq X\)</span> we have <span class="math notranslate nohighlight">\(a\le b\in \widetilde{\mathcal P}(X,\le)\)</span> iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-669f929d-e5a4-4bfe-afcb-a29c03d119df">
<span class="eqno">(19)<a class="headerlink" href="#equation-669f929d-e5a4-4bfe-afcb-a29c03d119df" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall x\in \mathcal a\,.\, \exists y\in b\,.\,x\le y \\
\forall y\in \mathcal b\,.\, \exists x\in a\,.\,x\le y \\
\end{gather}\]</div>
<p>In domain theory, this is also known as the Egli-Milner order. When restricted to convex subsets (and modified wrt the empty subset)  <span class="math notranslate nohighlight">\(\widetilde{\mathcal P}\)</span> is known as the Plotkin powerdomain. See also my review of <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/r1SJ8lizO">powerdomains</a>.</p>
</section>
<section id="cospan-based-relation-lifting">
<h3>Cospan-Based Relation Lifting<a class="headerlink" href="#cospan-based-relation-lifting" title="Permalink to this headline">#</a></h3>
<p>To cotabulate a relation <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> by a cospan</p>
<div class="math notranslate nohighlight">
\[X\stackrel j \rightarrow \mathbf R\stackrel k\leftarrow Y\]</div>
<p>we need to recall the <strong>collage</strong> <span class="math notranslate nohighlight">\(\bf R\)</span> of a relation <span class="math notranslate nohighlight">\(R\)</span>. This notion can also be defined in case <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are ordered sets and <span class="math notranslate nohighlight">\(R\)</span> is <strong>weakening-closed</strong>, that is,</p>
<div class="math notranslate nohighlight">
\[\frac{x'\le x\,R\, y\le y'}{x'\,R\,y'}.\]</div>
<p>We give the more general definition, because it shows that the cospan-based relation lifting cannot only be used to extend set-functors but also ordered functors.</p>
<p>If <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> is a weakening relation, then the <strong>collage</strong> <span class="math notranslate nohighlight">\(\bf R\)</span> is an order on the disjoint union <span class="math notranslate nohighlight">\(X+Y\)</span> such that <span class="math notranslate nohighlight">\(x\mathbf R y\)</span> if (i) <span class="math notranslate nohighlight">\(x\le y\)</span> in <span class="math notranslate nohighlight">\(X\)</span> or (ii) <span class="math notranslate nohighlight">\(xRy\)</span> or (iii) <span class="math notranslate nohighlight">\(x\le y\)</span> in <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<p>Given a functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span>, <a class="footnote-reference brackets" href="#ord" id="id1">1</a> we can use the collage to give a cospan-based definition of relation lifting.</p>
<p><strong>Definition:</strong> Let <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[\widehat T: \sf Rel\to Rel\]</div>
<p>is defined<span class="math notranslate nohighlight">\((a,b)\in \widehat TR\)</span> if <span class="math notranslate nohighlight">\(a\le b\)</span> in <span class="math notranslate nohighlight">\(\widetilde T\bf R\)</span>.</p>
<p><strong>Fact:</strong> If <span class="math notranslate nohighlight">\(T\)</span> preserves weak pullbacks then <span class="math notranslate nohighlight">\(\overline T=\widehat T\)</span>.</p>
</section>
<section id="conclusion">
<h3>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">#</a></h3>
<p>The span-based relation lifting can be generalised to ordered sets an is well-behaved if the functor preserves weak pullbacks.</p>
<p>The cospan-based relation lifting is ineherently order enriched, but can be applied to the discrete case if we extend the functor to ordered sets.</p>
<p>One application of relation lifting is to define coalgebraic bisimulation. Here the span-based and the cospan-based definition agree if the functor preserves weak pullbacks, but in general it is only <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/rk4TFb8FP">cospan bisimilarity</a> that captures coalgebraic behavioural equivalence/preorder.</p>
<p>The cospan-based relation lifting generalises from ordered sets to Lawvere metric spaces and other categories enriched over a quantale.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>References can be found in the survey article</p>
<ul class="simple">
<li><p>Kurz, Velebil: <span class="xref myst">Relation Lifting</span>.</p></li>
</ul>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="ord"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>(or a functor on preorders or posets)</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Moss-Coalgebraic-Logic"></span><section class="tex2jax_ignore mathjax_ignore" id="moss-s-coalgebraic-logic">
<h2>Moss’s Coalgebraic Logic<a class="headerlink" href="#moss-s-coalgebraic-logic" title="Permalink to this headline">#</a></h2>
<p>(under construction)</p>
<p>Given a coalgebra <span class="math notranslate nohighlight">\(\gamma:X\to TX\)</span> and the set of all formulas <span class="math notranslate nohighlight">\(\Phi\)</span> and <span class="math notranslate nohighlight">\(\theta\in T\Phi\)</span>, we define the semantics of the formla <span class="math notranslate nohighlight">\(\nabla\theta\)</span> via</p>
<div class="math notranslate nohighlight">
\[x\Vdash \nabla\theta \quad\Longleftrightarrow\quad \gamma(x)\,  \widehat T(\Vdash)\, \theta \]</div>
<p>where <span class="math notranslate nohighlight">\(\widehat T\)</span> is the <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/ByPA9_Juu">relation lifting</a> of <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p><strong>Example:</strong> If <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> the powerset functor and <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span>, then the relation lifting <span class="math notranslate nohighlight">\(\widehat{\mathcal P}R\subseteq \mathcal PX\times\mathcal PY\)</span> is given as follows.</p>
<div class="math notranslate nohighlight">
\[(A,B)\in\widehat{\mathcal P}R \quad\Leftrightarrow\quad \forall x\in A.\exists y\in B. (x,y)\in R \quad \&amp;\quad 
\forall y\in B.\exists x\in A. (x,y)\in R
\]</div>
<p>Instantiating <span class="math notranslate nohighlight">\(A=\gamma(x)\)</span> and <span class="math notranslate nohighlight">\(B=\theta\)</span> we get</p>
<div class="math notranslate nohighlight">
\[\gamma(x)\,  \widehat{\mathcal P}(\Vdash)\, \theta \quad\Leftrightarrow\quad \forall y\in\gamma(x).\exists \phi\in\theta. y\Vdash\phi \quad \&amp;\quad 
\forall\phi\in\theta.\exists y\in \gamma(x). y\Vdash\theta
\]</div>
<p>With <span class="math notranslate nohighlight">\(\theta = \{\phi_1,\ldots\phi_n\}\)</span> we can now rewrite this using <span class="math notranslate nohighlight">\(\Box\)</span> and <span class="math notranslate nohighlight">\(\Diamond\)</span> to obtain</p>
<div class="math notranslate nohighlight">
\[\nabla\theta = \Box(\phi_1\vee\ldots\phi_n)\wedge\Diamond\phi_1\wedge\ldots\Diamond\phi_n\]</div>
<p><strong>Definition:</strong> The syntax of Moss’s logic <a class="footnote-reference brackets" href="#syntaxmoss" id="id1">1</a> is given by the functor</p>
<div class="math notranslate nohighlight">
\[FTU:{\sf BA}\to {\sf BA}\]</div>
<p>and the semantics is given for finite sets <span class="math notranslate nohighlight">\(X\)</span> by the BA-morphism <span class="math notranslate nohighlight">\(FTUPX \to PTX\)</span> which is the adjoint transpose of the function <span class="math notranslate nohighlight">\(TUP\stackrel\rho\longrightarrow UPTX\)</span> that arises from applying the relation lifting of <span class="math notranslate nohighlight">\(T\)</span> to the elementship relation.<a class="footnote-reference brackets" href="#semanticsmoss" id="id2">2</a></p>
<div class="amsmath math notranslate nohighlight" id="equation-2426bccd-512b-4801-87b1-8b0bf57504c5">
<span class="eqno">(20)<a class="headerlink" href="#equation-2426bccd-512b-4801-87b1-8b0bf57504c5" title="Permalink to this equation">#</a></span>\[\begin{align}
X\times 2^X &amp; \stackrel\in\longrightarrow  2\\
TX\times T(2^X) &amp; \stackrel{\widehat T\in}\longrightarrow 2\\
T(2^X) &amp;\to 2^{TX}
\end{align}\]</div>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Lawrence S. Moss: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0168007298000426">Coalgebraic logic</a>, 1999.</p></li>
<li><p>Kurz, Leal: <a class="reference external" href="https://alexhkurz.github.io/papers/mfps09KurzLeal-jv.pdf">Modalities in the Stone age: A comparison of coalgebraic logics</a>, 2012.</p></li>
</ul>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="syntaxmoss"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>One often takes the finitary version of <span class="math notranslate nohighlight">\(T\)</span> defined as the left Kan extension of the restriction of <span class="math notranslate nohighlight">\(T\)</span> to finite sets. This is more in the spirit of using a finitary variety such as Boolea algebra for the base logic.</p>
</dd>
<dt class="label" id="semanticsmoss"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd></dd>
</dl>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-contents/Introduction-to-Functorial-Modal-Logic"></span><section class="tex2jax_ignore mathjax_ignore" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h2>
<p>(not even a draft)</p>
<section id="review">
<h3>Review<a class="headerlink" href="#review" title="Permalink to this headline">#</a></h3>
<p>Given functors <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span> and <span class="math notranslate nohighlight">\(L:\sf BA\to BA\)</span> and the contravariant adjunction “homming into <span class="math notranslate nohighlight">\(2\)</span>”</p>
<div class="math notranslate nohighlight">
\[ P:\sf Set \leftrightarrow BA : S\]</div>
<p>the meaning of the logic <span class="math notranslate nohighlight">\(L\)</span> is determined by</p>
<div class="math notranslate nohighlight">
\[LP\to PT\]</div>
<p>Moreover, <span class="math notranslate nohighlight">\(LP\to PT\)</span> determines, and is determined by, its so-called mate</p>
<div class="amsmath math notranslate nohighlight" id="equation-12557bd6-d650-41b6-98a4-b5f48edc1855">
<span class="eqno">(21)<a class="headerlink" href="#equation-12557bd6-d650-41b6-98a4-b5f48edc1855" title="Permalink to this equation">#</a></span>\[\begin{gather}
TS\to SL
\end{gather}\]</div>
<p>which maps a one-step behaviour to its theory.</p>
</section>
<section id="one-step-properties">
<h3>One-Step Properties<a class="headerlink" href="#one-step-properties" title="Permalink to this headline">#</a></h3>
<p>It is possible to express properties of the logic in terms of the properties of these natural transformations. Below</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n\)</span> is a finite set,</p></li>
<li><p><span class="math notranslate nohighlight">\(\twoheadrightarrow\)</span> is onto,</p></li>
<li><p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> is split epi (onto and has a half-inverse),</p></li>
<li><p><span class="math notranslate nohighlight">\(\rightarrowtail\)</span> is injective,</p></li>
<li><p><span class="math notranslate nohighlight">\(\hookrightarrow\)</span> is a section (injective and has a half-inverse).</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{|l|l|}
  \hline
  LP\stackrel{}{\rightarrowtail}PT  &amp; \textrm{one-step completeness}
  \\ \hline
  LP\stackrel{}{\twoheadrightarrow}PT &amp; \textrm{all sets of one-step behaviours are definable}
  \\ \hline
  LFn\twoheadrightarrow PTSFn &amp; \textrm{all finitary predicate liftings are definable}
  \\ \hline
  TS\rightarrowtail SL &amp; \textrm{one-step expressiveness}\\
  \hline
  TS\Rightarrow SL &amp; \textrm{canonical (strongly complete)}
  \\ \hline
  T \rightarrowtail SLP &amp; \textrm{separating (non-bisimilar successors are distinguished by a formula)}
  \\ \hline
\end{array}
\end{split}\]</div>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>The algebraic approach to coalgebraic logic was proposed in</p>
<ul class="simple">
<li><p>Kupke, Kurz, Pattinson: <a class="reference external" href="https://alexhkurz.github.io/papers/KKP-cmcs04/cmcs2004.entcs.pdf">Algebraic Semantics for Coalgebraic Logics</a>. 2004.</p></li>
</ul>
<p>This paper proves that one-step completeness implies completeness. That one-step expressiveness implies expressiveness is due to</p>
<ul class="simple">
<li><p>Klin: <span class="xref myst"></span> …</p></li>
</ul>
<p>…</p>
<ul class="simple">
<li><p>Kurz, Rosicky: <span class="xref myst"></span> …</p></li>
</ul>
</section>
</section>
<span id="document-contents/Presenting-Functors-by-Operations-and-Equations"></span><section class="tex2jax_ignore mathjax_ignore" id="presenting-functors">
<h2>Presenting Functors<a class="headerlink" href="#presenting-functors" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<p>The main theorem is that a functor on a variety (in the sense of universal algebra) has a <strong>presentation by operations and equations</strong> if and only if the functor preserves sifted colimits.</p>
<p>The theory of sifted colimits is well explained in Adamek-Rosicky-Vitale. We only cover some highlights.</p>
<p>In all of the following <span class="math notranslate nohighlight">\(\mathcal A\)</span> is a variety in the sense of univeral algebra, that is, a category of algebras specified (finitary) operations equations. (We will assume all operations to be finitary in the following, even if we drop the qualifier.)</p>
<section id="sifted-colimits">
<h3>Sifted Colimits<a class="headerlink" href="#sifted-colimits" title="Permalink to this headline">#</a></h3>
<p><strong>Filtered categories</strong> are precisely categories <span class="math notranslate nohighlight">\(\mathcal D\)</span> such that colimits over <span class="math notranslate nohighlight">\(\mathcal D\)</span> commute with finite limits in Set. There is also a characterization of filtered categories independent of sets – a category <span class="math notranslate nohighlight">\(\mathcal D\)</span> is filtered if and only if the diagonal functor <span class="math notranslate nohighlight">\(\mathcal D \to \mathcal D^\mathcal I\)</span> is final for each finite category <span class="math notranslate nohighlight">\(\mathcal I\)</span>.</p>
<p><strong>Sifted categories</strong> are the categories <span class="math notranslate nohighlight">\(\mathcal D\)</span> such that colimits over <span class="math notranslate nohighlight">\(\mathcal D\)</span> commute with finite products. These categories are characterized by the property that the diagonal functor <span class="math notranslate nohighlight">\(\mathcal D \to \mathcal D \times \mathcal D\)</span> is final.</p>
<p><strong>Facts:</strong></p>
<ul class="simple">
<li><p>Every filtered colimit is sifted.</p></li>
<li><p>Reflexive coequalisers are sifted but not filtered.</p></li>
<li><p>Sifted colimit preserving functors preserve filtered colimits.</p></li>
</ul>
<p>An object <span class="math notranslate nohighlight">\(A\)</span> of a category <span class="math notranslate nohighlight">\(\mathcal C\)</span> is <strong>finitely presentable</strong> if its hom-functor <span class="math notranslate nohighlight">\(hom(A, −) : \mathcal C → Set\)</span> preserves filtered colimits. A category <span class="math notranslate nohighlight">\(\mathcal C\)</span> is locally finitely presentable <strong>(lfp)</strong> if it is cocomplete and has a set <span class="math notranslate nohighlight">\(\mathcal X\)</span> of finitely presentable objects such that each object of <span class="math notranslate nohighlight">\(\mathcal C\)</span> is a filtered colimit of objects from <span class="math notranslate nohighlight">\(\mathcal X\)</span>.</p>
<p>An object <span class="math notranslate nohighlight">\(A\)</span> is <strong>strongly finitely presentable</strong> if its hom-functor <span class="math notranslate nohighlight">\(hom(A,−) : \mathcal C → Set\)</span> preserves sifted colimits. A category <span class="math notranslate nohighlight">\(\mathcal C\)</span> is strongly locally finitely presentable <strong>(slfp)</strong> if it is cocomplete and has a set <span class="math notranslate nohighlight">\(\mathcal X\)</span> of strongly finitely presentable objects such that each object of <span class="math notranslate nohighlight">\(\mathcal C\)</span> is a sifted colimit of objects from <span class="math notranslate nohighlight">\(\mathcal X\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(\mathcal A\)</span> be a variety in the sense of universal algebra.</p>
<p><strong>Facts:</strong></p>
<ul class="simple">
<li><p>Finitely presentable objects in <span class="math notranslate nohighlight">\(\mathcal A\)</span> are algebras finitely presentable in a usual sense.</p></li>
<li><p>Strongly finitely presentable algebra = retract of finitely generated free algebra.</p></li>
<li><p>Finitely presentable algebra = reflexive coequalizer of strongly finitely presentable ones.</p></li>
<li><p>Sifted colimit preserving functors on <span class="math notranslate nohighlight">\(\mathcal A\)</span> are determined by their action on finitely generated free algebras.</p></li>
</ul>
<p>Let <span class="math notranslate nohighlight">\(Alg(L)\)</span> be the categories of algebras for the functor <span class="math notranslate nohighlight">\(L:\mathcal A\to\mathcal A\)</span>.</p>
<p><strong>Theorem:</strong> If <span class="math notranslate nohighlight">\(\mathcal A\)</span> is a variety and <span class="math notranslate nohighlight">\(L:\mathcal A\to \mathcal A\)</span> preserves sifted colimits then <span class="math notranslate nohighlight">\(Alg(L)\)</span> is a variety.</p>
<p><strong>Proposition:</strong></p>
<ul class="simple">
<li><p>Let <span class="math notranslate nohighlight">\(\mathcal A\)</span> be a variety such that every finitely presentable algebra is projective. Then any functor <span class="math notranslate nohighlight">\(L : \mathcal A \to  \mathcal A\)</span> preserving filtered colimits preserves sifted colimits.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> preserves filtered colimits then <span class="math notranslate nohighlight">\(T\)</span> preserves sifted colimits.</p></li>
<li><p>For any filtered colimit preserving functor <span class="math notranslate nohighlight">\(L : BA → BA\)</span> there is a sifted colimit preserving functor <span class="math notranslate nohighlight">\(L′ : BA → BA\)</span> such that <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(L′\)</span> are isomorphic when restricted to the full subcategory of BA without <span class="math notranslate nohighlight">\(1\)</span>. Moreover, <span class="math notranslate nohighlight">\(Alg(L) = Alg(L′)\)</span>.</p></li>
</ul>
</section>
<section id="presenting-functors-on-varieties">
<h3>Presenting Functors on Varieties<a class="headerlink" href="#presenting-functors-on-varieties" title="Permalink to this headline">#</a></h3>
<section id="introduction">
<h4>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h4>
<p>Given an adjunction <span class="math notranslate nohighlight">\(L\dashv R:\mathcal C\to \mathcal X\)</span> such that the right-adjoint <span class="math notranslate nohighlight">\(R\)</span> is monadic (or of descent type) all objects <span class="math notranslate nohighlight">\(A\in\mathcal C\)</span> have a presentation “by generators and relations”</p>
<div class="math notranslate nohighlight">
\[LRLRA\rightrightarrows LRA \to A.\]</div>
<p>In words, <span class="math notranslate nohighlight">\(A\)</span> is the quotient of the free algebra <span class="math notranslate nohighlight">\(LRA\)</span> over generators <span class="math notranslate nohighlight">\(RA\)</span> by equations in <span class="math notranslate nohighlight">\(LRLRA\)</span>.</p>
<p>We apply this “monadic presentation” now to the situation where <span class="math notranslate nohighlight">\(A\)</span> is an endofunctor. In fact, we apply it twice and combine two representations:</p>
<p><em>Step 1:</em> We represent a sifted colimit preserving endofunctor on a variety <span class="math notranslate nohighlight">\(\mathcal A\)</span> such that the “generators” and “relations” are given by sifted colimit preserving endofunctors on Set.</p>
<p><em>Step 2:</em> We represent a sifted colimit on Set as the quotient of polynomial functor.</p>
</section>
<section id="preliminaries">
<h4>Preliminaries<a class="headerlink" href="#preliminaries" title="Permalink to this headline">#</a></h4>
<p>Let <span class="math notranslate nohighlight">\(S(\mathcal C)\)</span> be the category of sifted colimit preserving functors <span class="math notranslate nohighlight">\(\mathcal C\to\mathcal C\)</span>.</p>
<p><strong>Fact:</strong> The category <span class="math notranslate nohighlight">\(S(\mathcal C)\)</span> is slfp if <span class="math notranslate nohighlight">\(\mathcal C\)</span> is.</p>
<p>A functor <span class="math notranslate nohighlight">\(H : \mathcal A \to \mathcal B\)</span> between slfp categories is called <strong>algebraically exact</strong> provided that it preserves limits and sifted colimits.</p>
<p><strong>Fact:</strong> If <span class="math notranslate nohighlight">\(H\)</span> is algebraically exact it has a left adjoint.</p>
</section>
<section id="step-1">
<h4>Step 1<a class="headerlink" href="#step-1" title="Permalink to this headline">#</a></h4>
<p>Let <span class="math notranslate nohighlight">\(U:\mathcal A\to Set\)</span> be a variety and <span class="math notranslate nohighlight">\(F\dashv U\)</span>. Define</p>
<div class="math notranslate nohighlight">
\[\Psi:S(\mathcal A)\to S(Set)\]</div>
<p>via <span class="math notranslate nohighlight">\(\Psi L = ULF\)</span> and</p>
<div class="math notranslate nohighlight">
\[\Phi: S(Set) \to S(\mathcal A)\]</div>
<p>via <span class="math notranslate nohighlight">\(\Phi T = FTU\)</span>.</p>
<p><strong>Fact:</strong> <span class="math notranslate nohighlight">\(\Psi\)</span> is algebraically exact and <span class="math notranslate nohighlight">\(\Phi\dashv\Psi\)</span>.</p>
<p>After the first step, we obtain a quotient <span class="math notranslate nohighlight">\(FULFU\to L\)</span>. Here, <span class="math notranslate nohighlight">\(FULFU\)</span> results from applying the free construction <span class="math notranslate nohighlight">\(\Phi=F-U\)</span> to the Set-functor <span class="math notranslate nohighlight">\(ULF\)</span>. What we need next is a presentation by operations and equations of <span class="math notranslate nohighlight">\(ULF\)</span>.</p>
</section>
<section id="step-2">
<h4>Step 2<a class="headerlink" href="#step-2" title="Permalink to this headline">#</a></h4>
<p>Every sifted colimit preserving on <span class="math notranslate nohighlight">\(Set\)</span> (=filtered colimit preserving functor=finitary functor) can be presented as the quotient of a polynomial functor.</p>
<p>Indeed, if <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> is finitary then we have a natural transformation</p>
<div class="amsmath math notranslate nohighlight" id="equation-9722b0d4-1103-49e1-9237-99e0ea3f7b2d">
<span class="eqno">(22)<a class="headerlink" href="#equation-9722b0d4-1103-49e1-9237-99e0ea3f7b2d" title="Permalink to this equation">#</a></span>\[\begin{align}
\coprod_{n\in\mathbb N} Tn\times X^n &amp; 
\stackrel {q_X} \longrightarrow TX \\
(\sigma,v) &amp; \ \mapsto \ T(v)(\sigma)
\end{align}\]</div>
<p>with each <span class="math notranslate nohighlight">\(q_X\)</span> being surjective (even for infinite sets <span class="math notranslate nohighlight">\(X\)</span>).</p>
<p>Note that <span class="math notranslate nohighlight">\(v\)</span> can be seen both as a tuple <span class="math notranslate nohighlight">\((x_1,\ldots x_n)\)</span> and as a function <span class="math notranslate nohighlight">\(n\to X\)</span>. Hence we can evaluate the term <span class="math notranslate nohighlight">\(\sigma(x_1,\ldots x_n)\)</span> by applying <span class="math notranslate nohighlight">\(Tv:Tn\to TX\)</span> to <span class="math notranslate nohighlight">\(\sigma\)</span>.</p>
<p>This gives us a representation of <span class="math notranslate nohighlight">\(T\)</span> as a functor by operations and equations where the set of <span class="math notranslate nohighlight">\(n\)</span>-ary operations is <span class="math notranslate nohighlight">\(Tn\)</span> and the set of equations in <span class="math notranslate nohighlight">\(n\)</span> variables is the kernel of <span class="math notranslate nohighlight">\(q_n\)</span>.</p>
</section>
<section id="the-presentation">
<h4>The Presentation<a class="headerlink" href="#the-presentation" title="Permalink to this headline">#</a></h4>
<p><strong>Theorem:</strong> A functor on a variety has a presentation by operations and equations iff the functor preserves sifted colimits.</p>
<p>To prove “if”, one shows that every sifted colimit preserving functor <span class="math notranslate nohighlight">\(L\)</span> on a variety is a quotient</p>
<div class="math notranslate nohighlight">
\[FGUA\stackrel {q_A} \longrightarrow LA\]</div>
<p>where <span class="math notranslate nohighlight">\(GX=\coprod_{n\in\mathbb N}ULFn\times X^n\)</span>.</p>
<ul class="simple">
<li><p>The <span class="math notranslate nohighlight">\(n\)</span>-ary modal operators <span class="math notranslate nohighlight">\(\sigma\)</span> are the elements of <span class="math notranslate nohighlight">\(ULFn\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(q_A\)</span> maps <span class="math notranslate nohighlight">\((\sigma,v:n\to UA)\)</span> to <span class="math notranslate nohighlight">\(L(v^\dagger)(\sigma)\)</span> where <span class="math notranslate nohighlight">\(v^\dagger:Fn\to A\)</span> is the adjoint transpose of <span class="math notranslate nohighlight">\(v\)</span>.<a class="footnote-reference brackets" href="#sigma" id="id1">1</a></p></li>
<li><p>The equations in <span class="math notranslate nohighlight">\(n\)</span> variables are the kernel of <span class="math notranslate nohighlight">\(q_{Fn}\)</span>.</p></li>
</ul>
<p>In particular the <span class="math notranslate nohighlight">\((\sigma,v:n\to UA)\)</span> are modal formulas</p>
<div class="math notranslate nohighlight">
\[\Delta(a_1,\ldots a_n)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta=\sigma\)</span> and <span class="math notranslate nohighlight">\(a_i=v(i)\)</span>.</p>
<p>The set <span class="math notranslate nohighlight">\(\Sigma\)</span> of operations and the set <span class="math notranslate nohighlight">\(E\)</span> of equations constitute the presentation <span class="math notranslate nohighlight">\(\langle\Sigma_L,E_L\rangle\)</span> of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p><strong>Theorem:</strong> Let <span class="math notranslate nohighlight">\(\mathcal A \cong Alg(Σ_\mathcal A, E_\mathcal A)\)</span> be a variety and <span class="math notranslate nohighlight">\(\langle \Sigma_L, E_L\rangle\)</span> a presentation of <span class="math notranslate nohighlight">\(L : \mathcal A \to \mathcal A\)</span>. Then <span class="math notranslate nohighlight">\(Alg(Σ_\mathcal A + \Sigma_L, E_\mathcal A+E_L)\)</span> is isomorphic to Alg(L), where equations in <span class="math notranslate nohighlight">\(E_\mathcal A\)</span> and <span class="math notranslate nohighlight">\(E_L\)</span> are understood as equations over <span class="math notranslate nohighlight">\(\Sigma_\mathcal A + \Sigma_L\)</span>.</p>
<p><strong>Example:</strong> The variety of modal algebras is presented by the operations and equations of Boolean algebra plus a unary operation <span class="math notranslate nohighlight">\(\Box\)</span> and two equations specifying that <span class="math notranslate nohighlight">\(\Box\)</span> preserves finite meets.</p>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Kurz-Rosicky: <a class="reference external" href="https://arxiv.org/pdf/1207.2732.pdf">Strongly Complete Logics for Coalgebras</a>, 2012.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="sigma"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Note that <span class="math notranslate nohighlight">\((\sigma,v:n\to UA)\)</span> is a modal formula <span class="math notranslate nohighlight">\(\Delta(a_1,\ldots a_n)\)</span> where <span class="math notranslate nohighlight">\(\Delta=\sigma\)</span> and <span class="math notranslate nohighlight">\(a_i=v(i)\)</span>.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Boolean-Logic-for-Set-Coalgebras"></span><section class="tex2jax_ignore mathjax_ignore" id="boolean-logic-for-set-coalgebras">
<h2>Boolean Logic for Set-Coalgebras<a class="headerlink" href="#boolean-logic-for-set-coalgebras" title="Permalink to this headline">#</a></h2>
<p>We build on concepts and examples explained previously, but try to keep this section self-contained from a technical point of view.</p>
<p>We specialise the setting from <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/r1t-Y6f8L">Coalgebraic Logic: Introduction</a> as follows:</p>
<ul class="simple">
<li><p>a functor <span class="math notranslate nohighlight">\(T:Set \to Set\)</span></p></li>
<li><p>a functor <span class="math notranslate nohighlight">\(L:{\sf BA} \to {\sf BA}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(F\dashv U:{\sf BA} \to Set\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P:Set\to BA\)</span> given by <span class="math notranslate nohighlight">\(PX=2^X\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(S:BA\to Set\)</span> given by <span class="math notranslate nohighlight">\(SA=BA(A,2)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\delta_X: LPX\to PTX\)</span></p></li>
</ul>
<p>We have seen previously that modal logics for <span class="math notranslate nohighlight">\(T\)</span>-coalgebras can be described by giving <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(\delta\)</span>.</p>
<p>Conversely, <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/ByRlkfCio">every sifted colimit preserving functor on a variety has a presentation</a> and hence gives rise to a modal logic. Before we see how this works let us state some results needed later.</p>
<p><strong>Proposition:</strong> Let <span class="math notranslate nohighlight">\(L\)</span> be a sifted colimit preserving functor on <span class="math notranslate nohighlight">\({\sf BA}\)</span>. There is a functor <span class="math notranslate nohighlight">\(L'\)</span> that agrees with <span class="math notranslate nohighlight">\(L\)</span> on all non-trivial algebras and preserves filtered colimits. Moreover <span class="math notranslate nohighlight">\(Alg(L)\cong Alg(L')\)</span>.</p>
<p><strong>Lemma:</strong> Let <span class="math notranslate nohighlight">\(H\)</span> be a functor on <span class="math notranslate nohighlight">\({\sf BA}\)</span> and <span class="math notranslate nohighlight">\(L\)</span> a sifted colimit preserving functor on <span class="math notranslate nohighlight">\({\sf BA}\)</span> and <span class="math notranslate nohighlight">\(LFn=HFn\)</span> for all finitely generated free Boolean algebras <span class="math notranslate nohighlight">\(Fn\)</span>. Then <span class="math notranslate nohighlight">\(LA=HA\)</span> for all finite non-trivial algebras <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p><em>Proof:</em> Every finite non-trivial Boolean algebra is a retract of a finitely generated free one.</p>
<section id="the-logic-of-l">
<h3>The logic of <span class="math notranslate nohighlight">\(L\)</span><a class="headerlink" href="#the-logic-of-l" title="Permalink to this headline">#</a></h3>
<p>As promised, we are going to show that  every sifted colimit preserving functor on a variety has a presentation and hence gives rise to a modal logic.</p>
<p>Every sifted colimit preserving functor <span class="math notranslate nohighlight">\(L\)</span> on a variety is a quotient</p>
<div class="math notranslate nohighlight">
\[FGUA\stackrel {q_A} \longrightarrow LA\]</div>
<p>where <span class="math notranslate nohighlight">\(GX=\coprod_{n\in\mathbb N}ULFn\times X^n\)</span>. Since <span class="math notranslate nohighlight">\(F\)</span> is a left adjoint, the morphism <span class="math notranslate nohighlight">\(q_A\)</span> is the adjoint transpose of a morphism</p>
<div class="math notranslate nohighlight">
\[GUA \longrightarrow ULA\]</div>
<p>which determines (and is determinedy by) the following modal logic.</p>
<ul class="simple">
<li><p>The <span class="math notranslate nohighlight">\(n\)</span>-ary modal operators <span class="math notranslate nohighlight">\(\sigma\)</span> are the elements of <span class="math notranslate nohighlight">\(ULFn\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(q_A\)</span> maps <span class="math notranslate nohighlight">\((\sigma,v:n\to UA)\)</span> to <span class="math notranslate nohighlight">\(L(v^\dagger)(\sigma)\)</span> where <span class="math notranslate nohighlight">\(v^\dagger\)</span> is the adjoint transpose of <span class="math notranslate nohighlight">\(v\)</span>.</p></li>
<li><p>The equations in <span class="math notranslate nohighlight">\(n\)</span> variables are the kernel of <span class="math notranslate nohighlight">\(q_{Fn}\)</span>.</p></li>
</ul>
<p>In particular the <span class="math notranslate nohighlight">\((\sigma,v:n\to UA)\)</span> are modal formulas</p>
<div class="math notranslate nohighlight">
\[\Delta(a_1,\ldots a_n)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta=\sigma\)</span> and <span class="math notranslate nohighlight">\(a_i=v(i)\)</span>.</p>
<p>The set <span class="math notranslate nohighlight">\(\Sigma\)</span> of operations and the set <span class="math notranslate nohighlight">\(E\)</span> of equations constitute the presentation <span class="math notranslate nohighlight">\(\langle\Sigma_L,E_L\rangle\)</span> of <span class="math notranslate nohighlight">\(L\)</span>.</p>
<p><strong>Example:</strong> The variety of Boolean algebras with operator (BAO) is presented by the operations and equations of Boolean algebra plus a unary operation <span class="math notranslate nohighlight">\(\Box\)</span> and two equations specifying that <span class="math notranslate nohighlight">\(\Box\)</span> preserves finite meets.</p>
</section>
<section id="moss-s-coalgebraic-logic">
<h3>Moss’s coalgebraic logic<a class="headerlink" href="#moss-s-coalgebraic-logic" title="Permalink to this headline">#</a></h3>
<p>The first proposal for a logic of coalgebras parametric in the coalgebra functor <span class="math notranslate nohighlight">\(T\)</span> was Moss’s coalgebraic logic. It can be obtained by defining <span class="math notranslate nohighlight">\(L\)</span> via a presentation</p>
<div class="math notranslate nohighlight">
\[FGUA\stackrel {q_A} \longrightarrow LA\]</div>
<p>where <span class="math notranslate nohighlight">\(G=T\)</span>. Originally, Moss’s logic did not have equations, which corresponds to taking the <span class="math notranslate nohighlight">\(q_{Fn}\)</span> to be identities. This use of the functor <span class="math notranslate nohighlight">\(T\)</span> itself as a syntax constructor for a logic yields a very interesting presentation. This presentation is equivalent in expressiveness (in case <span class="math notranslate nohighlight">\(T\)</span> preserves weak pullbacks) to the ones we know from classical modal logic, but is quite different in terms of the opportunities it offers as a logical tool. For more see the section on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/rJksR4sso">Moss’s Coalgebraic Logic</a>.</p>
</section>
<section id="the-logic-of-all-predicate-liftings">
<h3>The logic of all predicate liftings<a class="headerlink" href="#the-logic-of-all-predicate-liftings" title="Permalink to this headline">#</a></h3>
<p>Pattinson introduced <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/SJcARPMVO">predicate liftings</a> to give a parametric treatment of coalgebraic logic that includes classical modal logic as an example. The logic of all predicate liftings can be defined in our setting in a natural way.</p>
<p><strong>Remark:</strong> Note that Moss’s logic is defined by applying <span class="math notranslate nohighlight">\(T\)</span> directly to syntax, whereas here we want to use the duality given by <span class="math notranslate nohighlight">\(S:{\sf BA} \to Set\)</span> and <span class="math notranslate nohighlight">\(P:Set\to{\sf BA}\)</span> to keep <span class="math notranslate nohighlight">\(T\)</span> on the semantic side of the duality. In fact, we might have been tempted to simply define <span class="math notranslate nohighlight">\(L = PTS\)</span> and while this is still the guiding idea, this direct approach is only suitable if we start from a dual equivalence of base categories such as the one given by complete atomic Boolean algebras and Set or the one given by Boolean algebras and Stone spaces. Moreover, defining <span class="math notranslate nohighlight">\(L=PTS\)</span> will not, in general, result in a sifted colimit preserving functor and, thus, not, in general, allow us to find a finitary presentation of <span class="math notranslate nohighlight">\(Alg(L)\)</span> by operations and equations.</p>
<section id="syntax">
<h4>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">#</a></h4>
<p>We define <span class="math notranslate nohighlight">\(L=PTS\)</span> on finitely generated free algebras:</p>
<div class="math notranslate nohighlight">
\[LFn = PTSFn\]</div>
<p>We extend <span class="math notranslate nohighlight">\(L\)</span> to all algebras via sifted colimits (hence <span class="math notranslate nohighlight">\(L\)</span> preserves sifted colimits by definition).</p>
<p>Moreover, <span class="math notranslate nohighlight">\(ULFn=UPTSFn\)</span> is the set of all <span class="math notranslate nohighlight">\(n\)</span>-ary <strong>predicate liftings</strong>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-709ce7ea-f3b3-4a41-ba35-232e9dee4ec2">
<span class="eqno">(23)<a class="headerlink" href="#equation-709ce7ea-f3b3-4a41-ba35-232e9dee4ec2" title="Permalink to this equation">#</a></span>\[\begin{align}
UPTSFn &amp;\cong UPT(2^n) \\
&amp;= 2^{T(2^n)} \\
&amp;\cong Nat({(2^n)}^X,2^{TX}) \\
&amp;\cong Nat({(2^X)}^n,2^{TX}) \\
\end{align}\]</div>
<p>Since <span class="math notranslate nohighlight">\(L\)</span> preserves sifted colimits it has a <span class="xref myst">presentation by operations and equations</span> and this presentation presents <span class="math notranslate nohighlight">\(L\)</span> by all predicates liftings as</p>
<div class="math notranslate nohighlight">
\[FGUA\stackrel {q_A} \longrightarrow LA\]</div>
<p>where <span class="math notranslate nohighlight">\(GX=\coprod_{n\in\mathbb N}ULFn\times X^n\)</span>.</p>
</section>
<section id="semantics">
<h4>Semantics<a class="headerlink" href="#semantics" title="Permalink to this headline">#</a></h4>
<p>The semantics <span class="math notranslate nohighlight">\(\delta_X:LPX\to PTX\)</span> is given as follows.
![](https://hackmd.io/_uploads/HJHa0kb2o.png =500x)</p>
<p>Every <span class="math notranslate nohighlight">\(PX\)</span> is a sifted colimit <span class="math notranslate nohighlight">\(c_i:Fn\to PX\)</span>. Let <span class="math notranslate nohighlight">\(c_i^\ast\)</span> be the adjoint transpose. Since <span class="math notranslate nohighlight">\(L\)</span> preserves sifted colimits and since <span class="math notranslate nohighlight">\(PTc_i^\ast\)</span> is a cocone, <span class="math notranslate nohighlight">\(\delta_X\)</span> is well-defined.</p>
<p>In more detail, <span class="math notranslate nohighlight">\(c_i:Fn\to PX\)</span> is also a valuation of variable <span class="math notranslate nohighlight">\(v:n\to UPX\)</span> or also a tuple <span class="math notranslate nohighlight">\((a_1,\ldots a_n)\)</span> of subsets of <span class="math notranslate nohighlight">\(X\)</span>. Its adjoint transpose <span class="math notranslate nohighlight">\(X\to SFn\)</span> combines the characteristic functions <span class="math notranslate nohighlight">\(\chi_i\)</span> of all the subsets <span class="math notranslate nohighlight">\(a_i\)</span> into one function <span class="math notranslate nohighlight">\(X\to 2^n\)</span>, <span class="math notranslate nohighlight">\(x\mapsto \langle\chi_1,\ldots\chi_n\rangle\)</span>. Now, given a modal operator <span class="math notranslate nohighlight">\(\Delta\in UPTSFn = 2^{T{(2^n)}}\)</span> we have that <span class="math notranslate nohighlight">\(PTc_i^\ast(\Delta)\)</span> is</p>
<div class="math notranslate nohighlight">
\[TX\stackrel{Tc_i^\ast}\longrightarrow T(2^n)\stackrel\Delta\longrightarrow 2\]</div>
<p>which, as expected, coincides with the semantics of a modal operator as a predicate lifting.</p>
<p><strong>Remark:</strong> Using the Lemma above (which is special to the category <span class="math notranslate nohighlight">\({\sf BA}\)</span>), we do not need to go via the finitely generated free algebras <span class="math notranslate nohighlight">\(Fn\)</span> and can define <span class="math notranslate nohighlight">\(\delta_X\)</span> for finite <span class="math notranslate nohighlight">\(X\)</span> directly as the isomorphism</p>
<div class="math notranslate nohighlight">
\[LPX=PTSPX\cong PTX\]</div>
<p>which, in terms of the presentation of <span class="math notranslate nohighlight">\(L\)</span> by modal operators, corresponds to</p>
<div class="amsmath math notranslate nohighlight" id="equation-3d92b703-2202-4ce6-8178-3a2572760372">
<span class="eqno">(24)<a class="headerlink" href="#equation-3d92b703-2202-4ce6-8178-3a2572760372" title="Permalink to this equation">#</a></span>\[\begin{align}
\delta_X: LPX &amp; \to PTX\\
\Delta(a_1,\ldots a_n) &amp;\mapsto \Delta(a_1,\ldots a_n)
\end{align}\]</div>
<p>where</p>
<ul class="simple">
<li><p>on the left <span class="math notranslate nohighlight">\(\Delta(a_1,\ldots a_n)\)</span> is understood as syntax, that is, <span class="math notranslate nohighlight">\(\Delta\in UPTSFn\)</span> and <span class="math notranslate nohighlight">\((a_1,\ldots a_n)\in (UPX)^n\)</span> and</p></li>
<li><p>on the right <span class="math notranslate nohighlight">\(\Delta(a_1,\ldots a_n)\)</span> is evaluated by taking the predicate lifting <span class="math notranslate nohighlight">\(\Delta\)</span> as a function <span class="math notranslate nohighlight">\({(2^X)}^n \to 2^{TX}\)</span>, that is, as a function <span class="math notranslate nohighlight">\((UPX)^n\to UPTX\)</span>.</p></li>
</ul>
</section>
</section>
<section id="from-funtors-to-predicate-liftings-and-back">
<h3>From Funtors to Predicate Liftings and Back<a class="headerlink" href="#from-funtors-to-predicate-liftings-and-back" title="Permalink to this headline">#</a></h3>
<p>Every sifted colimit preserving functor <span class="math notranslate nohighlight">\(L\)</span> with a semantics <span class="math notranslate nohighlight">\(\delta:LP\to PT\)</span> can be represented by predicate liftings. Conversely, each set of predicate liftings presents a functor together with a semantics. We summarize this corrspondence.</p>
<p><img alt="" src="https://hackmd.io/_uploads/Sktt1gIhj.png" /></p>
<p>Starting with a functor <span class="math notranslate nohighlight">\(L\)</span>, its presentation <span class="math notranslate nohighlight">\(FGU\to L\)</span> and its semantics <span class="math notranslate nohighlight">\(LP\to PT\)</span>, we obtain its presentation by predicate liftings in the last line, where <span class="math notranslate nohighlight">\(\Delta\)</span> ranges over all elements of <span class="math notranslate nohighlight">\(G_n\)</span>. Conversely, any collection of predicate liftings <span class="math notranslate nohighlight">\(\Delta\)</span> defines a functor <span class="math notranslate nohighlight">\(L\)</span> obtained from “climbing the ladder up” and quotienting the corresponding <span class="math notranslate nohighlight">\(FGUPX\to PTX\)</span>.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<ul class="simple">
<li><p>Kurz-Rosicky: <a class="reference external" href="https://arxiv.org/pdf/1207.2732.pdf">Strongly Complete Logics for Coalgebras</a>, 2012.</p></li>
</ul>
<p>Diagrams:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://q.uiver.app/?q=WzAsOCxbMiwwLCJMUFgiXSxbNCwwLCJQVFgiXSxbMiwyLCJMRm4iXSxbNCwyLCJQVFNGbiJdLFswLDAsIlBYIl0sWzAsMiwiRm4iXSxbNiwwLCJYIl0sWzYsMiwiU0ZuIl0sWzAsMSwiXFxkZWx0YV9YIl0sWzIsMywiPSJdLFs1LDQsImNfaSJdLFsyLDAsIkxjX2kiXSxbMywxLCJQVGNfaV5cXGFzdCIsMl0sWzYsNywiY19pXlxcYXN0Il1d">Semantics of <span class="math notranslate nohighlight">\(L\)</span></a></p></li>
<li><p><a class="reference external" href="https://q.uiver.app/?q=WzAsMTIsWzEsOSwie30iXSxbMCwzLCJcXGNvcHJvZF97blxcaW5cXG1hdGhiYiBOfSAoR19uXFx0aW1lcyAoVVBYKV5uKSJdLFs0LDMsIlVQVFgiXSxbMCw0LCIoVVBYKV5uIl0sWzQsNCwiVVBUWCJdLFswLDAsIkZHVVBYIl0sWzIsMCwiTFBYIl0sWzQsMCwiUFRYIl0sWzAsMSwiRkdVUFgiXSxbNCwxLCJQVFgiXSxbMCwyLCJHVVBYIl0sWzQsMiwiVVBUWCJdLFsxLDJdLFszLDQsIlxcRGVsdGEiXSxbNSw2LCJxX3tQWH0iLDAseyJzdHlsZSI6eyJoZWFkIjp7Im5hbWUiOiJlcGkifX19XSxbNiw3LCJcXGRlbHRhX1giXSxbOCw5XSxbMTAsMTFdXQ==">From <span class="math notranslate nohighlight">\(L\)</span> to <span class="math notranslate nohighlight">\(\Delta\)</span> (and back)</a></p></li>
</ul>
</section>
</section>
<span id="document-contents/Semantics"></span><p><span class="math notranslate nohighlight">\(\newcommand{\sem}[1]{[\![#1]\!]}\)</span></p>
<section class="tex2jax_ignore mathjax_ignore" id="semantics-of-coalgebraic-logic">
<h2>Semantics of Coalgebraic Logic<a class="headerlink" href="#semantics-of-coalgebraic-logic" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<p>We first review the definitions and results that make sense for the general setting of coalgebraic logic.</p>
<section id="syntax-and-semantics">
<h3>Syntax and Semantics<a class="headerlink" href="#syntax-and-semantics" title="Permalink to this headline">#</a></h3>
<p>one-step syntax</p>
<div class="math notranslate nohighlight">
\[\mathcal A\stackrel L \longrightarrow \mathcal A\]</div>
<p>syntax is the initial algebra</p>
<div class="math notranslate nohighlight">
\[LI\longrightarrow I\]</div>
<p>one-step semantics</p>
<div class="math notranslate nohighlight">
\[LP\stackrel \delta \longrightarrow PT\]</div>
<p>semantics wrt <span class="math notranslate nohighlight">\(X\to TX\)</span></p>
<p><img alt="" src="https://i.imgur.com/AGBiZjm.png" /></p>
<p>For the next result we assume that <span class="math notranslate nohighlight">\(\mathcal X\)</span> is a concrete category. Various generalisations to abstract categories are also possible.</p>
<p><strong>Proposition:</strong> Formulas are invariant under bisimilarity.</p>
<p><em>Proof:</em> Follows from the naturality of <span class="math notranslate nohighlight">\(LP \to PT\)</span>.</p>
</section>
<section id="the-logic-functor-induced-by-the-coalgebra-functor">
<h3>The Logic Functor Induced by the Coalgebra Functor<a class="headerlink" href="#the-logic-functor-induced-by-the-coalgebra-functor" title="Permalink to this headline">#</a></h3>
<p>The definitions above are parametric in <span class="math notranslate nohighlight">\(L\)</span> and <span class="math notranslate nohighlight">\(LP\to PT\)</span>.</p>
<p>On the other hand, from a coalgebraic point of view, <span class="math notranslate nohighlight">\(T\)</span> is given and we should ask how to derive <span class="math notranslate nohighlight">\(L\)</span> from <span class="math notranslate nohighlight">\(T\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(\mathcal A\)</span> is a variety in the sense of universal algebra, then we can define a functor by its action on the free algebras. Moreover, if the variety has a presentation by operations of finite arity, then we can restrict attention to finitely generated free algebras and define <span class="math notranslate nohighlight">\(L\)</span> as</p>
<div class="math notranslate nohighlight">
\[LFn=PTSFn,\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> ranges over finite sets.</p>
<p>(to be continued)</p>
</section>
</section>
<span id="document-contents/Completeness"></span><section class="tex2jax_ignore mathjax_ignore" id="completeness">
<h2>Completeness<a class="headerlink" href="#completeness" title="Permalink to this headline">#</a></h2>
</section>
<span id="document-contents/Expressivity"></span><section class="tex2jax_ignore mathjax_ignore" id="expressivity">
<h2>Expressivity<a class="headerlink" href="#expressivity" title="Permalink to this headline">#</a></h2>
<p>(not even draft)</p>
<p>…</p>
<p><strong>Definition:</strong> A coalgebraic logic is <strong>expressive</strong> if for any two non-bisimilar states there is a formula distinguishing them.</p>
<p>…</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p><span id="id1">[<a class="reference internal" href="intro.html#id20" title="Dirk Pattinson. Expressive logics for coalgebras via terminal sequence induction. Notre Dame J. Formal Log., 45(1):19–33, 2004. URL: https://doi.org/10.1305/ndjfl/1094155277, doi:10.1305/ndjfl/1094155277.">Pattinson, 2004</a>]</span> introduces the notion of a <em>separating set of predicate liftings</em> and uses induction along the terminal coalgebra sequence, based on work by <span id="id2">[<a class="reference internal" href="intro.html#id19" title="James Worrell. Terminal sequences for accessible endofunctors. In Bart Jacobs and Jan J. M. M. Rutten, editors, Coalgebraic Methods in Computer Science, CMCS 1999, Amsterdam, The Netherlands, March 20-21, 1999, volume 19 of Electronic Notes in Theoretical Computer Science, 24–38. Elsevier, 1999. URL: https://doi.org/10.1016/S1571-0661(05)80267-1, doi:10.1016/S1571-0661(05)80267-1.">Worrell, 1999</a>, <a class="reference internal" href="intro.html#id18" title="James Worrell. On the final sequence of a finitary set functor. Theor. Comput. Sci., 338(1-3):184–199, 2005. URL: https://doi.org/10.1016/j.tcs.2004.12.009, doi:10.1016/j.tcs.2004.12.009.">Worrell, 2005</a>]</span>, to show that if <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> is finitary (or <span class="math notranslate nohighlight">\(\kappa\)</span>-accessible) and the set of predicate liftings is separating then the coalgebraic logic generated from the predicate liftings, finitary (<span class="math notranslate nohighlight">\(\kappa\)</span>-ary) conjunctions and negation is expressive.</p>
<p><span id="id3">[<a class="reference internal" href="intro.html#id17" title="Lutz Schröder. Expressivity of coalgebraic modal logic: the limits and beyond. In Vladimiro Sassone, editor, Foundations of Software Science and Computational Structures, 8th International Conference, FOSSACS 2005, Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2005, Edinburgh, UK, April 4-8, 2005, Proceedings, volume 3441 of Lecture Notes in Computer Science, 440–454. Springer, 2005. URL: https://doi.org/10.1007/978-3-540-31982-5\_28, doi:10.1007/978-3-540-31982-5\_28.">Schröder, 2005</a>, <a class="reference internal" href="intro.html#id16" title="Lutz Schröder. Expressivity of coalgebraic modal logic: the limits and beyond. Theor. Comput. Sci., 390(2-3):230–247, 2008. URL: https://doi.org/10.1016/j.tcs.2007.09.023, doi:10.1016/j.tcs.2007.09.023.">Schröder, 2008</a>]</span> showed that the logic of all predicate liftings is expressive for any finitary functor <span class="math notranslate nohighlight">\(T:Set\to Set\)</span>.</p>
<p><span id="id4">[<a class="reference internal" href="intro.html#id15" title="Bartek Klin. Coalgebraic modal logic beyond sets. In Marcelo Fiore, editor, Proceedings of the 23rd Conference on the Mathematical Foundations of Programming Semantics, MFPS 2007, New Orleans, LA, USA, April 11-14, 2007, volume 173 of Electronic Notes in Theoretical Computer Science, 177–201. Elsevier, 2007. URL: https://doi.org/10.1016/j.entcs.2007.02.034, doi:10.1016/j.entcs.2007.02.034.">Klin, 2007</a>]</span> showed that the proofs of Pattinson and Schröder can be done at the level of abstraction of functorial modal logic if the mate of the semantics <span class="math notranslate nohighlight">\(\delta\)</span> is mono. Klin’s method generalizes beyond sets and Boolean algebras and <span id="id5">[<a class="reference internal" href="intro.html#id14" title="Bart Jacobs and Ana Sokolova. Exemplaric expressivity of modal logics. J. Log. Comput., 20(5):1041–1068, 2010. URL: https://doi.org/10.1093/logcom/exn093, doi:10.1093/logcom/exn093.">Jacobs and Sokolova, 2010</a>]</span> provide a number of concrete examples of how it can be applied to various dynamical systems and their logics.</p>
<p><span id="id6">[<a class="reference internal" href="intro.html#id4" title="Krzysztof Kapulkin, Alexander Kurz, and Jiri Velebil. Expressiveness of positive coalgebraic logic. In Thomas Bolander, Torben Braüner, Silvio Ghilardi, and Lawrence S. Moss, editors, Advances in Modal Logic 9, papers from the ninth conference on &quot;Advances in Modal Logic,&quot; held in Copenhagen, Denmark, 22-25 August 2012, 368–385. College Publications, 2012. URL: http://www.aiml.net/volumes/volume9/Kapulkin-Kurz-Velebil.pdf.">Kapulkin <em>et al.</em>, 2012</a>]</span> shows that the logic of all monotone predicate liftings is expressive for every finitary, locally monotone, embedding-preserving poset-functor.</p>
<p><span id="id7">[<a class="reference internal" href="intro.html#id11" title="Marta Bílková and Matej Dostál. Expressivity of many-valued modal logics, coalgebraically. In Jouko A. Väänänen, Åsa Hirvonen, and Ruy J. G. B. de Queiroz, editors, Logic, Language, Information, and Computation - 23rd International Workshop, WoLLIC 2016, Puebla, Mexico, August 16-19th, 2016. Proceedings, volume 9803 of Lecture Notes in Computer Science, 109–124. Springer, 2016. URL: https://doi.org/10.1007/978-3-662-52921-8\_8, doi:10.1007/978-3-662-52921-8\_8.">Bílková and Dostál, 2016</a>]</span> studies the expressivity of many-valued logics for set-coalgebras given by predicate liftings.</p>
<p>…</p>
</section>
</section>
<span id="document-contents/Translations"></span><section class="tex2jax_ignore mathjax_ignore" id="translations-of-logics">
<h2>Translations of Logics<a class="headerlink" href="#translations-of-logics" title="Permalink to this headline">#</a></h2>
<p>…</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Kurz-Leal</p>
</section>
</section>
<span id="document-contents/Many-Valued-Coalgebraic-Logic"></span><section class="tex2jax_ignore mathjax_ignore" id="many-valued-coalgebraic-logic">
<h2>Many-Valued Coalgebraic Logic<a class="headerlink" href="#many-valued-coalgebraic-logic" title="Permalink to this headline">#</a></h2>
<p>…</p>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>There are at least two systematic ways to explore many-valued coalgebraic logic.</p>
<p>One is to generalise coalgebras over orders to coalgebras over quantale-enriched categories. This line of work was begun in <span id="id1">[<a class="reference internal" href="intro.html#id11" title="Marta Bílková and Matej Dostál. Expressivity of many-valued modal logics, coalgebraically. In Jouko A. Väänänen, Åsa Hirvonen, and Ruy J. G. B. de Queiroz, editors, Logic, Language, Information, and Computation - 23rd International Workshop, WoLLIC 2016, Puebla, Mexico, August 16-19th, 2016. Proceedings, volume 9803 of Lecture Notes in Computer Science, 109–124. Springer, 2016. URL: https://doi.org/10.1007/978-3-662-52921-8\_8, doi:10.1007/978-3-662-52921-8\_8.">Bílková and Dostál, 2016</a>]</span>, which in turn was based on earlier work <span id="id2">[<a class="reference internal" href="intro.html#id9" title="Marta Bílková, Alexander Kurz, Daniela Petrisan, and Jiri Velebil. Relation liftings on preorders and posets. In Andrea Corradini, Bartek Klin, and Corina Cîrstea, editors, Algebra and Coalgebra in Computer Science - 4th International Conference, CALCO 2011, Winchester, UK, August 30 - September 2, 2011. Proceedings, volume 6859 of Lecture Notes in Computer Science, 115–129. Springer, 2011. URL: https://doi.org/10.1007/978-3-642-22944-2\_9, doi:10.1007/978-3-642-22944-2\_9.">Bílková <em>et al.</em>, 2011</a>, <a class="reference internal" href="intro.html#id8" title="Marta Bílková, Alexander Kurz, Daniela Petrisan, and Jiri Velebil. Relation liftings on preorders and posets. CoRR, 2012. URL: http://arxiv.org/abs/1210.1433, arXiv:1210.1433.">Bílková <em>et al.</em>, 2012</a>]</span> on the order-enriched case. While this work studies coalgebras over preorders or over other quantale-enriched categories such as Lawvere metric spaces, <span id="id3">[<a class="reference internal" href="intro.html#id12" title="Marta Bílková and Matej Dostál. Many-valued relation lifting and moss' coalgebraic logic. In Reiko Heckel and Stefan Milius, editors, Algebra and Coalgebra in Computer Science - 5th International Conference, CALCO 2013, Warsaw, Poland, September 3-6, 2013. Proceedings, volume 8089 of Lecture Notes in Computer Science, 66–79. Springer, 2013. URL: https://doi.org/10.1007/978-3-642-40206-7\_7, doi:10.1007/978-3-642-40206-7\_7.">Bílková and Dostál, 2013</a>]</span> develops a many-valued Moss’s coalgebraic logic for coalgebras over sets. <span id="id4">[<a class="reference internal" href="intro.html#id11" title="Marta Bílková and Matej Dostál. Expressivity of many-valued modal logics, coalgebraically. In Jouko A. Väänänen, Åsa Hirvonen, and Ruy J. G. B. de Queiroz, editors, Logic, Language, Information, and Computation - 23rd International Workshop, WoLLIC 2016, Puebla, Mexico, August 16-19th, 2016. Proceedings, volume 9803 of Lecture Notes in Computer Science, 109–124. Springer, 2016. URL: https://doi.org/10.1007/978-3-662-52921-8\_8, doi:10.1007/978-3-662-52921-8\_8.">Bílková and Dostál, 2016</a>]</span> studies the expressivity of many-valued logics given by predicate liftings for coalgebras over sets.</p>
<p>The above mentioned <span id="id5">[<a class="reference internal" href="intro.html#id12" title="Marta Bílková and Matej Dostál. Many-valued relation lifting and moss' coalgebraic logic. In Reiko Heckel and Stefan Milius, editors, Algebra and Coalgebra in Computer Science - 5th International Conference, CALCO 2013, Warsaw, Poland, September 3-6, 2013. Proceedings, volume 8089 of Lecture Notes in Computer Science, 66–79. Springer, 2013. URL: https://doi.org/10.1007/978-3-642-40206-7\_7, doi:10.1007/978-3-642-40206-7\_7.">Bílková and Dostál, 2013</a>]</span> introduce a notion of <span class="math notranslate nohighlight">\(\mathcal V\)</span>-lifting, which extends polynomial functors on sets to <span class="math notranslate nohighlight">\(\mathcal V\)</span>-enriched functors on <span class="math notranslate nohighlight">\(\mathcal V\)</span>-enriched categories for commutative and unital quantales <span class="math notranslate nohighlight">\(\mathcal V\)</span>. This construction has been generalised to arbitrary set-functors in <span id="id6">[<a class="reference internal" href="intro.html#id6" title="Adriana Balan, Alexander Kurz, and Jiri Velebil. Extensions of functors from set to v-cat. In Lawrence S. Moss and Pawel Sobocinski, editors, 6th Conference on Algebra and Coalgebra in Computer Science, CALCO 2015, June 24-26, 2015, Nijmegen, The Netherlands, volume 35 of LIPIcs, 17–34. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2015. URL: https://doi.org/10.4230/LIPIcs.CALCO.2015.17, doi:10.4230/LIPIcs.CALCO.2015.17.">Balan <em>et al.</em>, 2015</a>, <a class="reference internal" href="intro.html#id5" title="Adriana Balan, Alexander Kurz, and Jiri Velebil. Extending set functors to generalised metric spaces. Log. Methods Comput. Sci., 2019. URL: https://doi.org/10.23638/LMCS-15(1:5)2019, doi:10.23638/LMCS-15(1:5)2019.">Balan <em>et al.</em>, 2019</a>]</span>, but these papers do not develop a coalgebraic logic parameterised by a quantale. From the point of view Stone duality, the missing step is a Stone duality parameterised by a quantale of truth values. While we know from general principles that such a duality exists, there is more work needed in presenting this duality in logical terms <span id="id7">[<a class="reference internal" href="intro.html#id3" title="Octavian Babus and Alexander Kurz. On the logic of generalised metric spaces. In Ichiro Hasuo, editor, Coalgebraic Methods in Computer Science - 13th IFIP WG 1.3 International Workshop, CMCS 2016, Colocated with ETAPS 2016, Eindhoven, The Netherlands, April 2-3, 2016, Revised Selected Papers, volume 9608 of Lecture Notes in Computer Science, 136–155. Springer, 2016. URL: https://doi.org/10.1007/978-3-319-40370-0\_9, doi:10.1007/978-3-319-40370-0\_9.">Babus and Kurz, 2016</a>, <a class="reference internal" href="intro.html#id2" title="Adriana Balan and Alexander Kurz. An equational approach to enriched distributivity. Revue Roumaine de Mathématiques Pures et Appliquées, 2021. URL: https://arxiv.org/abs/2112.13290, arXiv:2112.13290.">Balan and Kurz, 2021</a>]</span>.</p>
<p>From the point of view of quantale-enriched category theory, many-valued coalgebraic and coalgebraic logic over ordered sets are closely related. The latter have been studied in some detail by <span id="id8">[<a class="reference internal" href="intro.html#id10" title="Marta Bílková and Matej Dostál. Moss' logic for ordered coalgebras. Log. Methods Comput. Sci., 2022. URL: https://doi.org/10.46298/lmcs-18(3:18)2022, doi:10.46298/lmcs-18(3:18)2022.">Bílková and Dostál, 2022</a>]</span>.</p>
<p>A second systematic way to explore many-valued coalgebraic logic is to replace the dual adunction between sets and Boolean algebras by an adjunction between sets and a category of algebras that is represented by a many-valued logic of interest.</p>
<p><span id="id9">[<a class="reference internal" href="intro.html#id13" title="Chun-Yu Lin and Churn-Jung Liau. On coalgebraic many-valued modal logic. CoRR, 2020. URL: https://arxiv.org/abs/2012.05604, arXiv:2012.05604.">Lin and Liau, 2020</a>]</span> build a duality by homming into an <span class="math notranslate nohighlight">\(FL_{ew}\)</span>-algebra …</p>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-contents/Cospan-Bisimulation-Introduction"></span><section class="tex2jax_ignore mathjax_ignore" id="cospan-bisimulation-overview">
<h2>Cospan Bisimulation: Overview<a class="headerlink" href="#cospan-bisimulation-overview" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<hr class="docutils" />
<ul class="simple">
<li><p><a class="reference external" href="https://hackmd.io/&#64;alexhkurz/HyQxhrh_v">Cospan Bisimulation</a> <strong>suggests that cospan bisimulation is a better behaved alternative than tradiditional span bisimulation</strong>. It relies on the notion of posetification of a functor in order to apply Worrell’s cospan bisimulation for quantale-enriched coalgebras also to set coalgebras.</p></li>
<li><p><a class="reference external" href="https://hackmd.io/&#64;alexhkurz/SJZPcfMdv">Bisimulation for Ordered Coalgebras</a> recalls Worrell’s cospan bisimulations. This section presents various example of ordered coalgebras, with an emphasis on ordered neighbourhood coalgebras.</p></li>
<li><p><a class="reference external" href="https://hackmd.io/&#64;alexhkurz/BJfhgfLYv">Neighbourhood Coalgebras</a> and <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/HJM0YyZ_w">Monotone Neighbourhood Coalgebras</a> are standard examples of coalgebras for which span bisimulations fail to fully account for bisimilarity. We review some of the literature on this topic from the point of view of cospan bisimulation.</p></li>
<li><p><a class="reference external" href="https://hackmd.io/uvH1hEqBTE6uJKlI0qSRAA">Logic of Ordered Neighbourhood Coalgebras</a> <font color='lightgrey'>reviews the connection with modal logic. This section can be skipped. </font></p></li>
<li><p><a class="reference external" href="https://hackmd.io/&#64;alexhkurz/S1IWPOVKv">Cospan Bisimulation 2</a> lays out some of the basic results relating span and cospan (bi)simulation. In particular, <strong>every span bisimulation is a cospan bisimulation and the converse holds for weak pullback preserving functors</strong>.</p></li>
<li><p><em>Doctrinal Adjunction</em> reviews some category theory about lifting of functors from a base adjunction to coalgebras. These results are used in Section <a class="reference external" href="https://hackmd.io/jxfudz7SQpmj5BzZkyWZIA">Cospan Bisimulation 2</a>.</p></li>
<li><p><em>Exact Squares</em> <font color='lightgrey'>contain the beginning of a review of the histroy of exact squares. This material is not relevant for our present purposes, but should be expanded at some later point. Can be skipped.</font></p></li>
</ul>
<p><strong>Questions:</strong> More examples? More theorems? Is this just a nice observation or is there something new we can do with this? Maybe connect it with logic induced bisimulations? There are more technical questions at <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/S1IWPOVKv">Cospan Bisimulation 2</a>.</p>
<section id="summary-of-bisimulations">
<h3>Summary of Bisimulations<a class="headerlink" href="#summary-of-bisimulations" title="Permalink to this headline">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(T:Ord\to Ord\)</span> be a functor and <span class="math notranslate nohighlight">\(\xi:X\to TX\)</span> and <span class="math notranslate nohighlight">\(\nu:Y\to TY\)</span> and <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span>.</p>
<p><span class="math notranslate nohighlight">\(R\)</span> is a cospan-(bi)simulation iff <span class="math notranslate nohighlight">\(xRy\)</span> satisfies the conditions below for all <span class="math notranslate nohighlight">\(x\in X\)</span> and <span class="math notranslate nohighlight">\(y\in Y\)</span>.</p>
<hr class="docutils" />
<div class="math notranslate nohighlight">
\[T=\overline{2^{2^-}}\]</div>
<div class="amsmath math notranslate nohighlight" id="equation-a708a1f3-d048-4100-b7f4-d9fbab9266d2">
<span class="eqno">(25)<a class="headerlink" href="#equation-a708a1f3-d048-4100-b7f4-d9fbab9266d2" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in\xi(x).\exists b \in \nu(y). (\forall x\in a.\exists y\in b. xRy) \ \&amp; \ (\forall y\in b.\exists x\in a. xRy)\\[1ex]
\forall b\in\nu(y).\exists a \in \xi(x). (\forall x\in a.\exists y\in b. xRy) \ \&amp; \ (\forall y\in b.\exists x\in a. xRy)
\end{gather}\]</div>
<hr class="docutils" />
<div class="math notranslate nohighlight">
\[T=\overline{Up\mathcal P}\]</div>
<div class="amsmath math notranslate nohighlight">
\[\begin{gather*}
\forall a\in\xi(x)\,.\,\exists b\in\nu(y)\,.\,\forall y\in b\,.\,\exists x\in a\,.\, xRy\\ 
\forall b\in\nu(y)\,.\,\exists a\in\xi(x)\,.\,\forall x\in a\,.\,\exists y\in b\,.\, xRy
\end{gather*}\]</div>
<hr class="docutils" />
<div class="math notranslate nohighlight">
\[T=\mathcal D\mathcal U\]</div>
<div class="amsmath math notranslate nohighlight" id="equation-7cff56b2-d4ee-4d5b-8b53-8aa637e05fb3">
<span class="eqno">(26)<a class="headerlink" href="#equation-7cff56b2-d4ee-4d5b-8b53-8aa637e05fb3" title="Permalink to this equation">#</a></span>\[\begin{align}
\forall a\in\xi x.\exists b\in\nu y. \forall y\in b.\exists x\in a.\ xRy 
\end{align}\]</div>
<hr class="docutils" />
<div class="math notranslate nohighlight">
\[T=\mathcal U\mathcal D\]</div>
<div class="amsmath math notranslate nohighlight" id="equation-427ca35a-3948-41d0-b257-52c6eab43e88">
<span class="eqno">(27)<a class="headerlink" href="#equation-427ca35a-3948-41d0-b257-52c6eab43e88" title="Permalink to this equation">#</a></span>\[\begin{align}
\forall b\in\nu y.\exists a\in\xi x. \forall x\in a.\exists y\in b.\  xRy 
\end{align}\]</div>
</section>
</section>
<span id="document-contents/Cospan-Bisimulation"></span><section class="tex2jax_ignore mathjax_ignore" id="cospan-bisimulation">
<h2>Cospan Bisimulation<a class="headerlink" href="#cospan-bisimulation" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<p>One of the starting points of coalgebra was Aczel’s discovery, see also (Rutten, 2000), that span-bisimulation, also known as Aczel-Mendler bisimulation, can capture category theoretically the combinatorial notion of bisimulation.</p>
<p>From an axiomatic point of view, one drawback of span-bisimulations is that, in order to for span-bisimulations to capture the coalgebraic notion of equivalence (aka behavioural equivalence), the coalgebra-functor needs to weakly preserve pullbacks (=preserve weak pullbacks).</p>
<p>In their proof of the final coalgebra, in order to not depend on this assumption, Aczel and Mendler work with quotients and cospans instead of spans. What they call precongruences can be considered as a precursor to the notion of cospan-bisimulation, defined below.</p>
<p>One disadvantage of cospans in Set is that they do not allow us to capture general relations. This can be circumvented by working poset enriched.</p>
<p><a class="reference external" href="https://hackmd.io/V6m2cAy_TdagteE4RG_sbw">Recall</a> that</p>
<ul class="simple">
<li><p>for every relation <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> the collage <span class="math notranslate nohighlight">\(\mathbf R\)</span> is the poset on the disjoint union <span class="math notranslate nohighlight">\(X+Y\)</span> encoding <span class="math notranslate nohighlight">\(R\)</span> (with <span class="math notranslate nohighlight">\(x\le_{\bf R} y \ \Leftrightarrow \  xRy\)</span>),</p></li>
<li><p>for every functor <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> there is a preordification <span class="math notranslate nohighlight">\(\overline T:Pre\to Pre\)</span>. <a class="footnote-reference brackets" href="#preordification" id="id1">1</a></p></li>
</ul>
<p><strong>Definition (cospan-bisimulation):</strong> Let <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> be a functor. A relation <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> is a <em>cospan bisimulation</em> between coalgebras <span class="math notranslate nohighlight">\(X\stackrel\xi\longrightarrow TX\)</span> and  <span class="math notranslate nohighlight">\(Y\stackrel\nu\longrightarrow TY\)</span> if the unique arrow <span class="math notranslate nohighlight">\(\mathbf R\to\overline T \mathbf R\)</span> that makes the diagram</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{}
X  &amp; \rightarrow &amp; \mathbf R &amp; \leftarrow &amp; Y\\
\downarrow &amp;&amp;\downarrow &amp;&amp; \downarrow \\
TX  &amp; \rightarrow &amp; \overline T\mathbf R &amp; \leftarrow &amp; TY
\end{array}
\end{split}\]</div>
<p>commute is order preserving. As we will see now, this notion does also work well in case of set-functors that do not preserve weak pullbacks. But let us first start with the familiar case of Kripke frames.</p>
<section id="kripke-models">
<h3>Kripke models<a class="headerlink" href="#kripke-models" title="Permalink to this headline">#</a></h3>
<p>For a starter we can illustrate what happens in the case of Kripke frames, that is, <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> is the powerset functor.</p>
<p><strong>Proposition</strong> (Balan et al, 2015): The posetification of <span class="math notranslate nohighlight">\(\mathcal P\)</span> is the convex powerset functor <span class="math notranslate nohighlight">\(\mathcal{\overline P}\)</span>.</p>
<p>By definition, then, <span class="math notranslate nohighlight">\(R\)</span> is a cospan-bisimulation iff</p>
<div class="math notranslate nohighlight">
\[xRy \ \ \Rightarrow \ \ \xi x \le_{\mathcal{\overline P}R} \nu y,\]</div>
<p>which, by definition<a class="footnote-reference brackets" href="#eglimilner" id="id2">2</a> of the order on <span class="math notranslate nohighlight">\(\mathcal{\overline P}\mathbf R\)</span>, gives us the usual definition of a bisimulation on Kripke frames (to emphasise the coalgebraic nature of Kripke frames we write <span class="math notranslate nohighlight">\(x'\in\xi(x)\)</span> instead of <span class="math notranslate nohighlight">\(x\to x'\)</span> and <span class="math notranslate nohighlight">\(y'\in\nu(y)\)</span> instead of <span class="math notranslate nohighlight">\(y\to y'\)</span>).</p>
<p><strong>Corollary:</strong> <span class="math notranslate nohighlight">\(R\)</span> is a cospan-bisimulation between Kripke frames <span class="math notranslate nohighlight">\(\xi:X\to TX\)</span> and <span class="math notranslate nohighlight">\(\nu:Y\to TY\)</span> iff <span class="math notranslate nohighlight">\(xRy\)</span> implies</p>
<div class="amsmath math notranslate nohighlight" id="equation-351e73d8-bde9-4960-b231-63514e3e4d28">
<span class="eqno">(28)<a class="headerlink" href="#equation-351e73d8-bde9-4960-b231-63514e3e4d28" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall x'\in\xi(x).\exists y'\in\nu(y).  x'Ry' \\[1ex]
\textrm { and }\\[1ex]
\forall y'\in\nu(y).\exists x'\in\xi(x).  x'Ry' \\  
\end{gather}\]</div>
</section>
<section id="monotone-neighbourhood-coalgebras">
<h3>Monotone Neighbourhood Coalgebras<a class="headerlink" href="#monotone-neighbourhood-coalgebras" title="Permalink to this headline">#</a></h3>
<p>In this subsection we look at coalgebras for the functor <span class="math notranslate nohighlight">\(Up\mathcal P:Set\to Set\)</span> and the associated notion of cospan-bisimulation induced by its posetification <span class="math notranslate nohighlight">\(\overline{Up\mathcal P}\)</span>. For cospan-(bi)simulations for related functors <span class="math notranslate nohighlight">\(Pos\to Pos\)</span> see the section on <a class="reference external" href="https://hackmd.io/Kaf6xVVMRP2w7a9hTLjT2w">Montone Neighbourhood Coalgebras</a>.</p>
<p><strong>Proposition</strong> (Corollary 5 in Dahlqvist and Kurz, 2017): The preordification of the monotone neighbourhood functor <span class="math notranslate nohighlight">\(T=Up\mathcal P\)</span> is <span class="math notranslate nohighlight">\(\mathcal D \mathcal U\)</span> ordered by</p>
<div class="math notranslate nohighlight">
\[A\le B \quad\stackrel{def}\Longleftrightarrow\quad \forall a\in A.\exists b\in B. {\uparrow}b \subseteq {\uparrow} a \ \ \ \textrm{and} \ \ \  \forall b\in B.\exists a\in A. {\downarrow} a \subseteq {\downarrow} b\]</div>
<p>for all <span class="math notranslate nohighlight">\(A,B\in \mathcal D\mathcal UX\)</span>.</p>
<p>The proof relies on the following lemma, see also Proposition 8.25 in (Hansen, 2003).</p>
<p><strong>Lemma:</strong>  Let <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> with projections <span class="math notranslate nohighlight">\(\pi_1:R\to X\)</span>, <span class="math notranslate nohighlight">\(\pi_2:R\to Y\)</span> onto. There is a <span class="math notranslate nohighlight">\(C\in TR\)</span> s.t.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{gather*}
\forall a\in A\,.\,\exists c\in C\,.\, \pi_1[c]\subseteq a\\ 
\forall c\in C\,.\,\pi_1[c]\in A\\
\forall b\in B\,.\,\exists c\in C\,.\, \pi_2[c]\subseteq b\\
\forall c\in C\,.\,\pi_2[c]\in B
\end{gather*}\]</div>
<p>if and only if</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{gather*}
\forall a\in A\,.\,\exists b\in B\,.\,\forall y\in b\,.\,\exists x\in a\,.\, xRy\\ 
\forall b\in B\,.\,\exists a\in A\,.\,\forall x\in a\,.\,\exists y\in b\,.\, xRy
\end{gather*}\]</div>
<p><strong>Remark:</strong> “only if” does not need the <span class="math notranslate nohighlight">\(\pi_i\)</span> to be onto.</p>
<p><em>Proof of the Proposition:</em> Recall that <span class="math notranslate nohighlight">\(Tf={\uparrow}f[-]\)</span>. By definition (see Sec 3.3 in Dahlqvist and Kurz, 2017), the posetification has <span class="math notranslate nohighlight">\(A\le B\)</span> if there is <span class="math notranslate nohighlight">\(C\)</span> such that <span class="math notranslate nohighlight">\({\uparrow}\pi_1[C]=A\)</span> and <span class="math notranslate nohighlight">\({\uparrow}\pi_2[C]=B\)</span>, which is equivalent to the left-hand side of the lemma. On the other hand, the definition of <span class="math notranslate nohighlight">\(A\le B\)</span> in the proposition is equivalent to the right-hand side of the lemma. Finally, notice that the <span class="math notranslate nohighlight">\(\pi_i\)</span> are onto because the order is reflexive (and <span class="math notranslate nohighlight">\(T\)</span> preserves surjections).</p>
<p>We have shown that cospan-bisimulations capture Pauly’s notion of bisimulation for neighbourhood frames:</p>
<p><strong>Corollary:</strong> <span class="math notranslate nohighlight">\(R\)</span> is a cospan-bisimulation between monotone neighbourhood frames <span class="math notranslate nohighlight">\(\xi:X\to TX\)</span> and <span class="math notranslate nohighlight">\(\nu:Y\to TY\)</span> iff <span class="math notranslate nohighlight">\(xRy\)</span> implies</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{gather*}
\forall a\in\xi(x)\,.\,\exists b\in\nu(y)\,.\,\forall y\in b\,.\,\exists x\in a\,.\, xRy\\ 
\forall b\in\nu(y)\,.\,\exists a\in\xi(x)\,.\,\forall x\in a\,.\,\exists y\in b\,.\, xRy
\end{gather*}\]</div>
</section>
<section id="neighbourhood-coalgebras">
<h3>Neighbourhood Coalgebras<a class="headerlink" href="#neighbourhood-coalgebras" title="Permalink to this headline">#</a></h3>
<p>In this subsection we take <span class="math notranslate nohighlight">\(TX=2^{2^{X}}\)</span>.</p>
<p><strong>Proposition</strong> (Theorem 8 in Dahlqvist and Kurz, 2017): The posetification of the neighbourhood functor <span class="math notranslate nohighlight">\(2^{2^-}\)</span> maps a poset <span class="math notranslate nohighlight">\(X\)</span> to the <span class="math notranslate nohighlight">\(2^{2^{CX}}\)</span> where <span class="math notranslate nohighlight">\(C\)</span> takes connected components. (CHECK whether this is also true for the preordification.)</p>
<p>Recall that, given <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span>, we have <a class="footnote-reference brackets" href="#pr" id="id3">3</a></p>
<div class="math notranslate nohighlight">
\[(a,b)\in \overline{\mathcal P}R \quad \Longleftrightarrow \
(\forall x\in a.\exists y\in b. xRy) \ \&amp; \  
(\forall y\in b.\exists x\in a. xRy)\]</div>
<p><strong>Corollary:</strong> <span class="math notranslate nohighlight">\(R\)</span> is a cospan-bisimulation between neighbourhood frames <span class="math notranslate nohighlight">\(\xi:X\to TX\)</span> and <span class="math notranslate nohighlight">\(\nu:Y\to TY\)</span> iff <span class="math notranslate nohighlight">\(xRy\)</span> implies</p>
<div class="math notranslate nohighlight">
\[\forall a\in\xi(x).\exists b \in \nu(y). (a,b)\in\overline{\mathcal P}R \quad \textrm{and}\quad
\forall b\in\nu(y).\exists a \in \xi(x). (a,b)\in\overline{\mathcal P}R\]</div>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(D:Set\to Pos\)</span> be the discrete functor (apologies for using the same letter for the downset-functor). <span class="math notranslate nohighlight">\(R\)</span> is a cospan-bisimulation if the middle arrow in the diagram below is order-preserving.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{}
DX  &amp; \stackrel{i}\longrightarrow &amp; \quad \mathbf R \quad &amp; \stackrel{j}\longleftarrow &amp; DY\\
D\xi\Bigg\downarrow \quad &amp;&amp;\Bigg\downarrow &amp;&amp; \quad\Bigg\downarrow D\nu \\
DTX\cong\overline TDX  &amp; \stackrel{\overline Ti}\longrightarrow &amp; \overline T\mathbf R &amp; \stackrel{\overline Tj}\longleftarrow &amp; \overline TDY\cong DTY
\end{array}
\end{split}\]</div>
<p><span class="math notranslate nohighlight">\(\mathbf R\to \overline T\mathbf R\)</span> is order-preserving iff <span class="math notranslate nohighlight">\(xRy\)</span> implies that <span class="math notranslate nohighlight">\(\overline Ti (D\xi(x))=\overline Tj(D\nu(y))\)</span>, that is,</p>
<div class="math notranslate nohighlight">
\[\{c\subseteq C\mathbf R \mid \exists a\in\xi(x). i^{-1}(c)=a\} 
\quad =\quad 
\{c\subseteq C\mathbf R \mid \exists b\in\nu(y). j^{-1}(c)=a\}\]</div>
<p>where <span class="math notranslate nohighlight">\(C\)</span> takes connected components. “<span class="math notranslate nohighlight">\(\subseteq\)</span>” can be written as</p>
<div class="math notranslate nohighlight">
\[\forall a\in\xi(x). \exists b\in\nu(y).i^{-1}(a) = j^{-1}(b)\]</div>
<p>which is equivalent to</p>
<div class="math notranslate nohighlight">
\[\forall a\in\xi(x).\exists b\in\nu(y).
\ (\forall x\in a.\exists y\in b. xRy) \ \&amp; \ 
(\forall y\in b.\exists x\in a. xRy) \]</div>
<p>and similarly for “<span class="math notranslate nohighlight">\(\supseteq\)</span>”.</p>
</section>
<section id="probabilistic-bisimulation">
<h3>Probabilistic bisimulation<a class="headerlink" href="#probabilistic-bisimulation" title="Permalink to this headline">#</a></h3>
<p>Probabilistic bisimulation also provides an example of cospan bisimulations. If <span class="math notranslate nohighlight">\(\mathcal D\)</span> is the functor of  finitely supported probability distributions, then the posetification <span class="math notranslate nohighlight">\(\overline{\mathcal D}\)</span> is given as follows. Let <span class="math notranslate nohighlight">\(p,q\)</span> be two probability distributions in <span class="math notranslate nohighlight">\(\mathcal DX\)</span>. Then define <span class="math notranslate nohighlight">\(p\sqsubseteq q\)</span> if <span class="math notranslate nohighlight">\(p[U]\le q[U]\)</span> for all upsets <span class="math notranslate nohighlight">\(U\)</span> of <span class="math notranslate nohighlight">\(X\)</span>.</p>
</section>
<section id="more-examples">
<h3>More Examples?<a class="headerlink" href="#more-examples" title="Permalink to this headline">#</a></h3>
<p>… other, less well-known, examples?</p>
</section>
<section id="results">
<h3>Results<a class="headerlink" href="#results" title="Permalink to this headline">#</a></h3>
<p>We will get the expected results. For <span class="math notranslate nohighlight">\(T:Set\to Set\)</span>, cospan bisimulation</p>
<ul class="simple">
<li><p>agrees with span bisimulation if <span class="math notranslate nohighlight">\(T\)</span> preserves weak pullbacks</p></li>
<li><p>captures behavioural equivalence without assumptions on <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p>coalgebraic logic is invariant under cospan-bisimulations</p></li>
<li><p>…</p></li>
</ul>
<p>Could there be theorems linking cospan-bisimulations to cospan-simulations?</p>
<ul class="simple">
<li><p>What are conditions on <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> so that there is a forward version <span class="math notranslate nohighlight">\(T^\rightarrow:Pos\to Pos\)</span> and a backward version <span class="math notranslate nohighlight">\(T^\leftarrow:Pos\to Pos\)</span>? Can we say sth general here or must this be done on an adhoc basis for particlar <span class="math notranslate nohighlight">\(T\)</span>?</p></li>
<li><p>…</p></li>
</ul>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Balan, Kurz and Velebil: <a class="reference external" href="https://arxiv.org/pdf/1402.5922.pdf">Positive Fragments of Coalgebraic Logics</a>. LMCS 2015.</p>
<p>Dahlqvist and Kurz: <a class="reference external" href="http://drops.dagstuhl.de/opus/volltexte/2017/8042/pdf/LIPIcs-CALCO-2017-9.pdf">The Positivication of Coalgebraic Logics</a>. CALCO 2017. (Section 3.3 and 3.4)</p>
<p>Hansen: <a class="reference external" href="https://eprints.illc.uva.nl/id/document/264">Monotonic modal logics</a>. 2003. (Def 4.10, Def 8.20, Prop 8.25)</p>
<p>Hansen, Kupke and Pacuit: <a class="reference external" href="https://arxiv.org/pdf/0901.4430">Neighbourhood Structures: Bisimilarity and Basic Model Theory</a>. LMCS 2009. (Def 3.5, Thm 3.12)</p>
<p>Pauly: <a class="reference external" href="https://hdl.handle.net/11245/1.194561">Logic for Social Software</a>. 2001. (Thm 6.5)</p>
<p>Rutten, Turi: <a class="reference external" href="https://homepages.cwi.nl/~janr/papers/files-of-papers/1993-LNCS.pdf"></a>, 1993. In particular, Def 5.4 of an <em>ordered F-bisimulation</em>.</p>
<p>Worrell: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1571066105803561">Coinduction for recursive data types: partial orders, metric spaces and <span class="math notranslate nohighlight">\(\Omega\)</span>-categories</a>, CMCS 2000. (Def 5.2)</p>
</section>
<section id="further-reading">
<h3>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">#</a></h3>
<p>Aczel:</p>
<p>Aczel, Mendler:</p>
<p>Hansen, Kupke and Pacuit: <span class="xref myst">Neighbourhood Structures: Bisimilarity and Basic Model Theory</span>. LMCS 2009.</p>
<p>Lawvere:</p>
<p>Rutten:</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="preordification"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Much of the following would also work for the posetification <span class="math notranslate nohighlight">\(\overline T:Pos\to Pos\)</span>. The one property that we only have for the preordification is <span class="math notranslate nohighlight">\(V\overline T \cong TV\)</span> where <span class="math notranslate nohighlight">\(V\)</span> the forgetful functor to <span class="math notranslate nohighlight">\(Set\)</span>.</p>
</dd>
<dt class="label" id="eglimilner"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Given a preorder/poset <span class="math notranslate nohighlight">\(X\)</span>, the order on the convex powerset of <span class="math notranslate nohighlight">\(X\)</span> is defined by <span class="math notranslate nohighlight">\((a,b)\in \mathcal{\overline P}X\)</span> if <span class="math notranslate nohighlight">\(\forall x\in a.\exists y\in b. x\le y\)</span> and <span class="math notranslate nohighlight">\(\forall y\in b.\exists x\in a. x\le y\)</span>.</p>
</dd>
<dt class="label" id="pr"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p><span class="math notranslate nohighlight">\(a\subseteq R^{-1}[b]\)</span> and <span class="math notranslate nohighlight">\(b\subseteq R[a]\)</span>.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Neighbourhood-Coalgebras"></span><section class="tex2jax_ignore mathjax_ignore" id="neighbourhood-coalgebras">
<h2>Neighbourhood Coalgebras<a class="headerlink" href="#neighbourhood-coalgebras" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<p>The idea of the following is to run through (Hansen, Kupke, Pacuit, 2009) and analyse it from the point of view of cospan bisimulation.</p>
<p><strong>Def:</strong> Let <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span>. The dual relation <span class="math notranslate nohighlight">\(R^\partial:2^X\looparrowright 2^Y\)</span> is defined by <span class="math notranslate nohighlight">\(R[a]\subseteq b\)</span>.</p>
<p><strong>Remark:</strong> <span class="math notranslate nohighlight">\((a,b)\)</span> are called <span class="math notranslate nohighlight">\(R\)</span>-coherent in Def 2.1 of Hansen-Kupke-Pacuit if <span class="math notranslate nohighlight">\((a,b)\in R^\partial\)</span> and <span class="math notranslate nohighlight">\((b,a)\in (R^{-1})^\partial\)</span>.</p>
<p>Recall that the connected component functor <span class="math notranslate nohighlight">\(C:Ord\to Set\)</span> is left-adjoint to the discrete functor <span class="math notranslate nohighlight">\(D:Set\to Ord\)</span>. Also recall that the ordification of the neighbourhood functor is $D2^{2^{C-}}, see Theorem 8 in [DK17] and the section on <a class="reference external" href="https://hackmd.io/6Ehr9bIQQgSZKeeasdSKoQ#Neighbourhood-Coalgebras">Cospan Bisimulation</a>.</p>
<p><strong>Definition:</strong> A neighbourhood frame is a set <span class="math notranslate nohighlight">\(X\)</span> with a function <span class="math notranslate nohighlight">\(X\to 2^{2^X}\)</span>. An ordered neighbourhood frame is an ordered set <span class="math notranslate nohighlight">\(X\)</span> with an order-preserving function <span class="math notranslate nohighlight">\(X\to D2^{2^{CX}}\)</span>.</p>
<p><strong>Remark:</strong> The function <span class="math notranslate nohighlight">\(f:X\to Y\)</span> in <span class="math notranslate nohighlight">\(Set\)</span> <a class="footnote-reference brackets" href="#ordmorph" id="id1">1</a> is a coalgebra morphism from <span class="math notranslate nohighlight">\(\xi:X\to 2^{2^X}\)</span> to <span class="math notranslate nohighlight">\(\nu:Y\to 2^{2^Y}\)</span> iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-eaca76b3-e65a-4675-a4ef-e3794ce01f70">
<span class="eqno">(29)<a class="headerlink" href="#equation-eaca76b3-e65a-4675-a4ef-e3794ce01f70" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in\xi(x).\exists b \in \nu(y). (\forall x\in a.\exists y\in b. fx=y) \ \&amp; \ (\forall y\in b.\exists x\in a. fx=y)\\[1ex]
\forall b\in\nu(y).\exists a \in \xi(x). (\forall x\in a.\exists y\in b. fx=y) \ \&amp; \ (\forall y\in b.\exists x\in a. fx=y)
\end{gather}\]</div>
<p><strong>Remark:</strong> Similarly, <span class="math notranslate nohighlight">\(R\)</span> is a bisimulation if <span class="math notranslate nohighlight">\(xRy\)</span> implies</p>
<div class="amsmath math notranslate nohighlight" id="equation-d74b4601-5b29-4a3d-a94d-7cb65b038b89">
<span class="eqno">(30)<a class="headerlink" href="#equation-d74b4601-5b29-4a3d-a94d-7cb65b038b89" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in\xi(x).\exists b \in \nu(y). (\forall x\in a.\exists y\in b. xRy) \ \&amp; \ (\forall y\in b.\exists x\in a. xRy)\\[1ex]
\forall b\in\nu(y).\exists a \in \xi(x). (\forall x\in a.\exists y\in b. xRy) \ \&amp; \ (\forall y\in b.\exists x\in a. xRy)
\end{gather}\]</div>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Hansen, Kupke, Pacuit: <a class="reference external" href="https://arxiv.org/pdf/0901.4430">Neighbourhood Structures: Bisimilarity and Basic Model Theory</a>. 2009. (Definition 2.1., …)</p>
<p>Dahlqvist and Kurz: <a class="reference external" href="http://drops.dagstuhl.de/opus/volltexte/2017/8042/pdf/LIPIcs-CALCO-2017-9.pdf">The Positivication of Coalgebraic Logics</a>. CALCO 2017. (Section 3.3 and 3.4)</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="ordmorph"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>The function <span class="math notranslate nohighlight">\(f:X\to Y\)</span> in <span class="math notranslate nohighlight">\(Ord\)</span> is a coalgebra morphism from <span class="math notranslate nohighlight">\(\xi:X\to D2^{2^{CX}}\)</span> to <span class="math notranslate nohighlight">\(\nu:Y\to D2^{2^{CY}}\)</span> iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-8d661c78-79ab-4f91-8ef4-f36120a9b0df">
<span class="eqno">(31)<a class="headerlink" href="#equation-8d661c78-79ab-4f91-8ef4-f36120a9b0df" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in\xi(x).\exists b \in \nu(y). (\forall x\in a.\exists y\in b. fx=y) \ \&amp; \ (\forall y\in b.\exists x\in a. \overline{fx}=\overline y)\\[1ex]
\forall b\in\nu(y).\exists a \in \xi(x). (\forall x\in a.\exists y\in b. fx=y) \ \&amp; \ (\forall y\in b.\exists x\in a. \overline{fx}=\overline y)
\end{gather}\]</div>
<p>where <span class="math notranslate nohighlight">\(\overline{y}\)</span> denotes the connected component of  <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Bisimulation-for-Order-Enriched-Coalgebras"></span><section class="tex2jax_ignore mathjax_ignore" id="bisimulation-for-ordered-coalgebras">
<h2>Bisimulation for Ordered Coalgebras<a class="headerlink" href="#bisimulation-for-ordered-coalgebras" title="Permalink to this headline">#</a></h2>
<p>(draft … reference to be added) … (<a class="reference external" href="https://hackmd.io/&#64;alexhkurz/ryrkkYZZc">up</a>)</p>
<p>The basic observation about ordinary, set-based coalgebras, due to Aczel’s monograph “Non-Well Founded Sets”, is the following:</p>
<p>Given a coalgebra <span class="math notranslate nohighlight">\(X\)</span>, the largest bisimulation on <span class="math notranslate nohighlight">\(X\)</span> is the kernel of the unique morphism <span class="math notranslate nohighlight">\(X\to Z\)</span> into the final coalgebra <span class="math notranslate nohighlight">\(Z\)</span>.</p>
<p>Aczel observed this as a fact for special coalgebras such as Kripke models and then took it as a starting point for a general definition, known today as Aczel-Mendler bisimulation.</p>
<p>Moving to the ordered setting, that is, enriching over preorders or posets, one can generalise by either formalising kernels as pullbacks (as before) or as order-pullbacks, which we call comma objects or comma squares or just commas, following terminology introduced by Lawvere in the category-enriched situation.</p>
<p>Choosing pullbacks, one only recovers the equality on the final coalgebra. On the other hand, choosing comma squares leads to a richer theory of bisimulations that includes simulations as special cases of bisimulations.</p>
<p>In fact, in preorders and posets, comma and cocomma squares are exact, that is, weakening relations can be both tabulated and cotabulated. This leads us to Definition 5.2 of (Worrell 2000), which, btw, does work for more general enrichments. Also note that because of the use of co-spans there is no need to restrict to weak-pullback preserving functors.</p>
<p>We first need to recall that every weakening relation <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> can be represented as a preorder/poset <span class="math notranslate nohighlight">\(\overline R\)</span> such that</p>
<ul class="simple">
<li><p>the underling set of <span class="math notranslate nohighlight">\(\overline R\)</span> is the disjoint union of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> and</p></li>
<li><p>the order on <span class="math notranslate nohighlight">\(\overline R\)</span> is the one inherited from <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> plus <span class="math notranslate nohighlight">\(x\overline Ry  \ \Leftrightarrow \  xRy\)</span>.</p></li>
</ul>
<p>In other words, we encode the relation <span class="math notranslate nohighlight">\(R\)</span> via the order of the preorder/poset <span class="math notranslate nohighlight">\(\overline R\)</span>, also known as the <em>collage</em> of <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>.</p>
<p><strong>Definition:</strong> Let <span class="math notranslate nohighlight">\(T\)</span> be a (locally monotone) functor on preorders or posets. The weakening relation <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> is an <em><strong>order-bisimulation</strong></em> between coalgebras <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> if there is  <span class="math notranslate nohighlight">\(\overline R\to T\overline R\)</span> such that
$<span class="math notranslate nohighlight">\(
\begin{array}{}
X  &amp; \rightarrow &amp; \overline R &amp; \leftarrow &amp; Y\\
\downarrow &amp;&amp;\downarrow &amp;&amp; \downarrow \\
TX  &amp; \rightarrow &amp; T\overline R &amp; \leftarrow &amp; TY
\end{array}
\)</span>$</p>
<p><strong>Remark:</strong> Equivalently, <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> is an order-bisimulation if the unqiuely determined function  <span class="math notranslate nohighlight">\(\overline R\to T\overline R\)</span> in <span class="math notranslate nohighlight">\(\sf Set\)</span> is order-preserving.</p>
<p><strong>Remark:</strong> It follows from the definition that <span class="math notranslate nohighlight">\(R\)</span> is a weakening relation. In other words, the pullback and the comma of the cospan <span class="math notranslate nohighlight">\(X \rightarrow \overline R \leftarrow Y\)</span> coincide. (<strong>Notation:</strong> I am tempted to drop the overline over the <span class="math notranslate nohighlight">\(R\)</span> in the following, because of the ugly extra space it introduces between lines.)</p>
<p><strong>Example:</strong> The identity cospan <span class="math notranslate nohighlight">\(X \rightarrow X \leftarrow X\)</span> is not isomorphic to the collage of a relation unless <span class="math notranslate nohighlight">\(X\)</span> is discrete. The collage of the order on <span class="math notranslate nohighlight">\(X\)</span> can be obtained as the cocomma of the comma of the identity cospan. <a class="footnote-reference brackets" href="#comma" id="id1">1</a> In fact, in posets, every collage is the cocomma of its comma.</p>
<p><strong>Example:</strong> If we instantiate the definition above with the downset functor and the upset functor, we obtain that <span class="math notranslate nohighlight">\(T\)</span>-bisimulation is simulation.</p>
<ul>
<li><p>Let <span class="math notranslate nohighlight">\(D\)</span> be the downset functor. A bisimulation between <span class="math notranslate nohighlight">\(D\)</span>-coalgebras <span class="math notranslate nohighlight">\((X,\xi)\)</span> and <span class="math notranslate nohighlight">\((Y,\nu)\)</span> is a relation <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> such that $<span class="math notranslate nohighlight">\(xRy\ \Rightarrow \ \xi x \subseteq \nu y,\)</span>$</p>
<p>or, more explicitely, <a class="footnote-reference brackets" href="#xtox" id="id2">2</a></p>
</li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-c396ddf1-eb31-4a80-ba7b-32320925285b">
<span class="eqno">(32)<a class="headerlink" href="#equation-c396ddf1-eb31-4a80-ba7b-32320925285b" title="Permalink to this equation">#</a></span>\[\begin{align}
xRy \ \Rightarrow \ &amp; \forall x\to x'.\exists y\to y'. x' R\, y' 
\end{align}\]</div>
<ul>
<li><p>Let <span class="math notranslate nohighlight">\(U\)</span> be the upset functor. Recall that <span class="math notranslate nohighlight">\(UX=[X,2]^o\)</span> is ordered by reverse inclusion. A bisimulation between <span class="math notranslate nohighlight">\(U\)</span>-coalgebras <span class="math notranslate nohighlight">\((X,\xi)\)</span> and <span class="math notranslate nohighlight">\((Y,\nu)\)</span> is a relation <span class="math notranslate nohighlight">\(R\subseteq X\times Y\)</span> such that $<span class="math notranslate nohighlight">\(xRy\ \Rightarrow \ \xi x \supseteq \nu y,\)</span>$</p>
<p>or, more explicitely,</p>
</li>
</ul>
<div class="amsmath math notranslate nohighlight" id="equation-dab7a2c0-c8a7-4900-85cd-f199c0b65bb8">
<span class="eqno">(33)<a class="headerlink" href="#equation-dab7a2c0-c8a7-4900-85cd-f199c0b65bb8" title="Permalink to this equation">#</a></span>\[\begin{align}
xRy \ \Rightarrow \ &amp; \forall y\to y'.\exists x\to x'. x' R y' 
\end{align}\]</div>
<p>Intuitively, a <span class="math notranslate nohighlight">\(D\)</span>-bisimulation is forward simulation: Every move in the domain can be simulated by a “larger” move in the codomain. Conversely, <span class="math notranslate nohighlight">\(U\)</span>-bisimulation is backward simulation: Every move in the codomain can be simulated by “smaller” move in the domain. (The words “smaller” and “larger” are intended to remind us of the fact that <span class="math notranslate nohighlight">\(R\)</span> is a weakening relation closed under the order in <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span>.)</p>
<p><strong>Remark:</strong> Notice that even if <span class="math notranslate nohighlight">\(X\)</span> and <span class="math notranslate nohighlight">\(Y\)</span> are discrete, we do not obtain ordinary bisimulation, but rather ordinary forward and backward simulation. On the other hand, if we take <span class="math notranslate nohighlight">\(T\)</span> to be the convex powerset functor, then <span class="math notranslate nohighlight">\(T\)</span>-bisimulation is ordinary bisimulation.</p>
<p><strong>Remark:</strong> The framework of functorial modal logic guarantees that for every functor <span class="math notranslate nohighlight">\(T\)</span> there is a sound, complete and bisimilarity preserving logic. In this case, these are the familiar <span class="math notranslate nohighlight">\((\Diamond,\bot,\vee)\)</span>-logic for the downset functor and the <span class="math notranslate nohighlight">\((\Box,\top,\wedge)\)</span>-logic for the upset functor. In case of the convex powerset functor we obtain Dunn’s positive modal logic.</p>
<section id="ordered-neighbourhood-coalgebras">
<h3>Ordered neighbourhood coalgebras<a class="headerlink" href="#ordered-neighbourhood-coalgebras" title="Permalink to this headline">#</a></h3>
<p>Recall from <a class="reference external" href="https://hackmd.io/Kaf6xVVMRP2w7a9hTLjT2w?both">Monotone Neighbourhood Coalgebras</a> and <a class="reference external" href="https://hackmd.io/P5xaVUGBRPemOviyHyJnQQ">Neighbourhood Coalgebras</a> the various ways in which neighbourhood coalgebras can be extended to the ordered setting. For the proofs below, we will need the following.</p>
<p>In <span class="math notranslate nohighlight">\(\mathcal D(X,\le)\)</span> we have
$<span class="math notranslate nohighlight">\(a \le b\ \Longleftrightarrow \ \forall x\in a.\exists y\in b.\ x\le y.\)</span>$</p>
<p>In <span class="math notranslate nohighlight">\(\mathcal U(X,\le)\)</span> we have
$<span class="math notranslate nohighlight">\(a \le b\ \Longleftrightarrow \ \forall y\in b.\exists x\in a.\ x\le y.\)</span>$</p>
<section id="mathcal-d-mathcal-u-coalgebras">
<h4><span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalgebras<a class="headerlink" href="#mathcal-d-mathcal-u-coalgebras" title="Permalink to this headline">#</a></h4>
<p>Recall <span class="math notranslate nohighlight">\(\mathcal D\mathcal UX = [[X,2],2]\)</span> for ordered sets <span class="math notranslate nohighlight">\(X\)</span>. In particular <span class="math notranslate nohighlight">\(\mathcal D\mathcal UX\)</span> is <span class="math notranslate nohighlight">\(Up\mathcal P X\)</span> for discrete <span class="math notranslate nohighlight">\(X\)</span> (when <span class="math notranslate nohighlight">\(Up\mathcal P X\)</span> is ordered by inclusion).</p>
<p><strong>Lemma:</strong> Let <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> be a weakening relation and <span class="math notranslate nohighlight">\(R'\)</span> its collage. Then the order of <span class="math notranslate nohighlight">\(\mathcal D\mathcal UR'\)</span> is given by
$<span class="math notranslate nohighlight">\( A\le B \ \Longleftrightarrow \ \forall a\in A.\exists b\in B.\forall y\in b.\exists x\in a.\ xRy\)</span>$</p>
<p><strong>Corollary:</strong> A weakening relation <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> is a cospan-(bi)simulation between <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalgebras <span class="math notranslate nohighlight">\((X,\xi)\)</span> and <span class="math notranslate nohighlight">\((Y,\nu)\)</span> iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-6888b456-7494-478c-92ad-9cdec6e119a6">
<span class="eqno">(34)<a class="headerlink" href="#equation-6888b456-7494-478c-92ad-9cdec6e119a6" title="Permalink to this equation">#</a></span>\[\begin{align}
xRy \ \ \Rightarrow \ \ &amp; 
\forall a\in\xi x.\exists b\in\nu y. \forall y'\in b.\exists x'\in a.\ x'Ry' 
\end{align}\]</div>
</section>
<section id="mathcal-u-mathcal-d-coalgebras">
<h4><span class="math notranslate nohighlight">\(\mathcal U\mathcal D\)</span>-coalgebras<a class="headerlink" href="#mathcal-u-mathcal-d-coalgebras" title="Permalink to this headline">#</a></h4>
<p>Recall <span class="math notranslate nohighlight">\(\mathcal U\mathcal DX = [[X^o,2],2]^o\)</span> for ordered sets <span class="math notranslate nohighlight">\(X\)</span>.</p>
<p><strong>Lemma:</strong> Let <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> be a weakening relation and <span class="math notranslate nohighlight">\(R'\)</span> its collage. Then the order of <span class="math notranslate nohighlight">\(\mathcal U\mathcal DR'\)</span> is given by
$<span class="math notranslate nohighlight">\( A\le B \ \Longleftrightarrow \ \forall b\in B.\exists a\in A.\forall x\in a.\exists y\in b.\ xRy\)</span>$</p>
<p><strong>Corollary:</strong> A weakening relation <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> is a cospan-(bi)simulation between <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalgebras <span class="math notranslate nohighlight">\((X,\xi)\)</span> and <span class="math notranslate nohighlight">\((Y,\nu)\)</span> iff
or, more explicitely,</p>
<div class="amsmath math notranslate nohighlight" id="equation-f0046a16-376c-4038-ab3f-0602bab9adc0">
<span class="eqno">(35)<a class="headerlink" href="#equation-f0046a16-376c-4038-ab3f-0602bab9adc0" title="Permalink to this equation">#</a></span>\[\begin{align}
xRy \ \ \Rightarrow \ \ &amp; \forall b\in\nu y.\exists a\in\xi x. \forall x'\in a.\exists y'\in b.\  x'Ry' 
\end{align}\]</div>
</section>
<section id="order-dual-of-r-coherent-pairs">
<h4>Order dual of R-coherent pairs<a class="headerlink" href="#order-dual-of-r-coherent-pairs" title="Permalink to this headline">#</a></h4>
<p>Can these characterisations be rephrased using the ordered version of <span class="math notranslate nohighlight">\(R\)</span>-coherent pairs? <a class="footnote-reference brackets" href="#r-coherent" id="id3">3</a></p>
<p>No, because <span class="math notranslate nohighlight">\(\forall x\in a. \exists y\in b.xRy\)</span> is equivlant to <span class="math notranslate nohighlight">\(a\subseteq R^o[b]\)</span>. <a class="footnote-reference brackets" href="#ro" id="id4">4</a> On the other hand, the dual [JKM20] <span class="math notranslate nohighlight">\(R^\partial\)</span>  of a relation <span class="math notranslate nohighlight">\(R\)</span>  is defined as <span class="math notranslate nohighlight">\((a,b)\in R^\partial \Leftrightarrow R[a]\subseteq b\)</span>, that is, <span class="math notranslate nohighlight">\(\forall x\in a.xRy\Rightarrow y\in b\)</span>.</p>
<p><strong>Remark:</strong> The weakening relation <span class="math notranslate nohighlight">\(R:(X,\xi)\looparrowright (Y,\nu)\)</span>  is a <span class="math notranslate nohighlight">\(\mathcal U\mathcal D\)</span>-bisimulation iff
$<span class="math notranslate nohighlight">\(xRy \ \ \Rightarrow \ \ 
\forall y\to b.\exists x\to a. 
R[a]\supseteq b\)</span>$</p>
<p>and <span class="math notranslate nohighlight">\(R\)</span> is a <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-bisimulation iff
$<span class="math notranslate nohighlight">\(xRy \ \ \Rightarrow \ \ 
\forall x\to a.\exists y\to b. 
a\subseteq R^o[b]\)</span>$</p>
</section>
</section>
<section id="other-functors">
<h3>Other Functors<a class="headerlink" href="#other-functors" title="Permalink to this headline">#</a></h3>
<section id="ordification-of-the-neighbourhood-functors">
<h4>Ordification of the Neighbourhood Functors<a class="headerlink" href="#ordification-of-the-neighbourhood-functors" title="Permalink to this headline">#</a></h4>
<p>For the Ordification of the neighbourhood functor and the monotone neighbourhood functor see the note on <a class="reference external" href="https://hackmd.io/6Ehr9bIQQgSZKeeasdSKoQ">Cospan Bisimulation</a>.</p>
</section>
<section id="downsets">
<h4>Downsets<a class="headerlink" href="#downsets" title="Permalink to this headline">#</a></h4>
<div class="amsmath math notranslate nohighlight" id="equation-c003f1b1-4efa-43c0-8a0f-7203ded19411">
<span class="eqno">(36)<a class="headerlink" href="#equation-c003f1b1-4efa-43c0-8a0f-7203ded19411" title="Permalink to this equation">#</a></span>\[\begin{align} 
xRy \ \Longrightarrow \ 
&amp; \forall x\in\xi(x). \exists y \in b. xRy 
\quad\quad
(\Leftrightarrow \xi(x)\subseteq R^o[\nu(y)])
\end{align}\]</div>
</section>
<section id="upsets">
<h4>Upsets<a class="headerlink" href="#upsets" title="Permalink to this headline">#</a></h4>
<div class="amsmath math notranslate nohighlight" id="equation-412bea88-a994-449d-8b55-871008851153">
<span class="eqno">(37)<a class="headerlink" href="#equation-412bea88-a994-449d-8b55-871008851153" title="Permalink to this equation">#</a></span>\[\begin{align} 
xRy \ \Longrightarrow \ 
&amp; \forall y\in\nu(y). \exists x \in \xi(x). xRy 
\quad\quad
(\Leftrightarrow R[\xi(x)]\supseteq \nu(y))
\end{align}\]</div>
</section>
<section id="convex-subsets">
<h4>Convex subsets<a class="headerlink" href="#convex-subsets" title="Permalink to this headline">#</a></h4>
<p>Is obtained from the conjunction of the two conditions above.</p>
</section>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Hansen, Kupke and Pacuit: <a class="reference external" href="https://arxiv.org/pdf/0901.4430">Neighbourhood Structures: Bisimilarity and Basic Model Theory</a>. LMCS 2009. (Def 3.5, Thm 3.12)</p>
<p>Worrell: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1571066105803561">Coinduction for recursive data types: partial orders, metric spaces and <span class="math notranslate nohighlight">\(\Omega\)</span>-categories</a>, CMCS 2000. (Def 5.2)</p>
</section>
<section id="further-reading">
<h3>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">#</a></h3>
<p>Aczel:</p>
<p>Aczel, Mendler:</p>
<p>Lawvere:</p>
<p>Rutten:</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="comma"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>This observation is useful for working with abstract order-enriched categories. If they admit commas of identity cospans, then for each object there is a span representing the order on that object.</p>
</dd>
<dt class="label" id="xtox"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>We write <span class="math notranslate nohighlight">\(x\to x'\)</span> for <span class="math notranslate nohighlight">\(x'\in\xi x\)</span> and similarly for <span class="math notranslate nohighlight">\(y\to y'\)</span> etc.</p>
</dd>
<dt class="label" id="r-coherent"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>R-coherent pairs were introduced in [HKR09].</p>
</dd>
<dt class="label" id="ro"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>If <span class="math notranslate nohighlight">\(R:X\looparrowright Y\)</span> is a weakening relation then <span class="math notranslate nohighlight">\(R:Y^o\looparrowright X^o\)</span> is the opposite relation. In the discrete case it coincides with <span class="math notranslate nohighlight">\(R^{-1}\)</span>.</p>
</dd>
</dl>
</section>
</section>
<span id="document-contents/Cospan-Bisimulation-2"></span><section class="tex2jax_ignore mathjax_ignore" id="cospan-bisimulation-2">
<h2>Cospan Bisimulation 2<a class="headerlink" href="#cospan-bisimulation-2" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added)</p>
<hr class="docutils" />
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h3>
<p>We collect some results on cospan bisimulations. These results invariable relate ordinary bisimulations on sets with ordered bisimulation on ordered sets. Since bisimulations on ordered sets include simulations as well as bisimulations we will call them <strong>(bi)simulations</strong>.</p>
<section id="overview">
<h4>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">#</a></h4>
<p>We first review <strong>notation</strong> and define the notion of an <strong>order-extension</strong> of a set-functor.</p>
<p>The subsection <strong>span and cospan bisimulations</strong> investigates the relationship between cospan bisimulations and span bisimulations.</p>
<p>The subsection <strong>cospan (bi)simulations and change of base</strong> looks at cospan (bi)simulations enriched over different quantales.</p>
</section>
<section id="summary">
<h4>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">#</a></h4>
<p>Together this shows that cospan (bi)simulation works uniformly over sets, orders, metric spaces and <span class="math notranslate nohighlight">\(\Omega\)</span>-categories. For example, Rutten’s final coalgebra theorem for sets can now be seen as a special case of Worrell’s final coalgebra theorem for <span class="math notranslate nohighlight">\(\Omega\)</span>-categories.</p>
</section>
</section>
<section id="questions">
<h3>Questions<a class="headerlink" href="#questions" title="Permalink to this headline">#</a></h3>
<p>If <span class="math notranslate nohighlight">\(f_\diamond\)</span> and <span class="math notranslate nohighlight">\(f^\diamond\)</span> are cospan-bisimulations, is then <span class="math notranslate nohighlight">\(f\)</span> a coalgebra morphism?</p>
<p>Connections with <em>logic induced bisimulations</em>?</p>
</section>
<section id="notation">
<h3>Notation<a class="headerlink" href="#notation" title="Permalink to this headline">#</a></h3>
<p>In this section,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Ord\)</span> denotes the category <span class="math notranslate nohighlight">\(Pre\)</span> of preorders or the category <span class="math notranslate nohighlight">\(Pos\)</span> of posets.</p></li>
<li><p><span class="math notranslate nohighlight">\(D:Set\to Ord\)</span> denotes the discrete functor and we write
$<span class="math notranslate nohighlight">\(C\dashv D\dashv V\)</span>$ for the induced chain of adjoints.</p></li>
<li><p><span class="math notranslate nohighlight">\(T\)</span> denotes a functor <span class="math notranslate nohighlight">\(Set\to Set\)</span>.</p></li>
</ul>
</section>
<section id="order-extensions">
<h3>Order-Extensions<a class="headerlink" href="#order-extensions" title="Permalink to this headline">#</a></h3>
<p>Following on from <a class="reference external" href="https://hackmd.io/6Ehr9bIQQgSZKeeasdSKoQ">part one</a>, we are interested in preordification <span class="math notranslate nohighlight">\(T'\)</span> of <span class="math notranslate nohighlight">\(T\)</span>. Preordifictions are universal solutions to the problem of finding a <span class="math notranslate nohighlight">\(T'\)</span> together with a transformation <span class="math notranslate nohighlight">\(DT\to T'D\)</span>. In fact, the preordification <span class="math notranslate nohighlight">\(T'\)</span> of <span class="math notranslate nohighlight">\(T\)</span> can be defined as the <span class="math notranslate nohighlight">\(Ord\)</span>-enriched left Kan extension of <span class="math notranslate nohighlight">\(DT\)</span> along <span class="math notranslate nohighlight">\(D\)</span>. But some results hold more generally for any ordered extension <span class="math notranslate nohighlight">\(DT\to T'D\)</span>.</p>
<p><strong>Definition:</strong> We call <span class="math notranslate nohighlight">\(T':Ord\to Ord\)</span> an <strong>order-extension</strong> of <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> if there is a natural transformation</p>
<div class="math notranslate nohighlight">
\[DT\to T'D.\]</div>
<p><strong>Remark:</strong> Equivalently, <span class="math notranslate nohighlight">\(T'\)</span> is an order-extension of <span class="math notranslate nohighlight">\(T\)</span> if there is a natural tranformation <span class="math notranslate nohighlight">\(T\to DT'V\)</span>. This also captures the intuition that <span class="math notranslate nohighlight">\(T'\)</span> adds ordering to <span class="math notranslate nohighlight">\(T\)</span>. If one insists on <span class="math notranslate nohighlight">\(T\to DT'V\)</span> being an iso, this notion is equivalent to the one of Jacobs and Jacobs-Hughes (ADD REFERENCES).</p>
<p><strong>Question:</strong> <span class="math notranslate nohighlight">\(T\to DT'V\)</span> iso is equivalent to <span class="math notranslate nohighlight">\(DT\to T'D\)</span> being bijective. Is there an interesting example of an order-extension for which <span class="math notranslate nohighlight">\(DT\to T'D\)</span> is not bijective?</p>
<p><strong>Remark:</strong> The mate of <span class="math notranslate nohighlight">\(DT\to T'D\)</span> is <span class="math notranslate nohighlight">\(TV\to VT'\)</span>. If <span class="math notranslate nohighlight">\(T'\)</span> is the preordification then <span class="math notranslate nohighlight">\(TV\to VT'\)</span> is an iso, but for posetifications this does not need to be the case as the example of convex powerset (=the posetification of  powerset) shows. We summarise some of the relationships between properties of these natural transformations in the table below.</p>
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
<th class="head"><p></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p><span class="math notranslate nohighlight">\(DT\to T'D\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(T\)</span>’ is an order-extension of <span class="math notranslate nohighlight">\(T\)</span></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p><span class="math notranslate nohighlight">\(DT\to T'D\)</span> iso</p></td>
<td><p><span class="math notranslate nohighlight">\(T'\)</span> a strict order-extension of <span class="math notranslate nohighlight">\(T\)</span></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p><span class="math notranslate nohighlight">\(T'\)</span> left Kan extension,</p></td>
<td><p><span class="math notranslate nohighlight">\(T'\)</span> is the ordification of <span class="math notranslate nohighlight">\(T\)</span></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>4</p></td>
<td><p><span class="math notranslate nohighlight">\(TV\to VT'\)</span> iso</p></td>
<td><p><span class="math notranslate nohighlight">\(T\)</span>’ is an order-lifting of <span class="math notranslate nohighlight">\(T\)</span></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>5</p></td>
<td><p><span class="math notranslate nohighlight">\(T\to VT'D\)</span> iso</p></td>
<td><p><span class="math notranslate nohighlight">\(T'D\)</span> is an order on <span class="math notranslate nohighlight">\(T\)</span></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<p><span class="math notranslate nohighlight">\(3\Rightarrow 2\Rightarrow 1\)</span> and <span class="math notranslate nohighlight">\(2\Rightarrow 5\)</span> and <span class="math notranslate nohighlight">\(4\Rightarrow 5\)</span>. If <span class="math notranslate nohighlight">\(Ord=Pre\)</span>, then also <span class="math notranslate nohighlight">\(3\Rightarrow 4\)</span>.</p>
</section>
<section id="span-and-cospan-bisimulations">
<h3>Span and cospan bisimulations<a class="headerlink" href="#span-and-cospan-bisimulations" title="Permalink to this headline">#</a></h3>
<p>The following result makes precise that every span bisimulation is a cospan (bi)simulation.</p>
<p><strong>Proposition:</strong> Let <span class="math notranslate nohighlight">\(T'\)</span> be an order-extension of <span class="math notranslate nohighlight">\(T\)</span>. If two states in two <span class="math notranslate nohighlight">\(T\)</span>-coalgebras are <span class="math notranslate nohighlight">\(T\)</span>-span-bisimilar then they are <span class="math notranslate nohighlight">\(T'\)</span>-cospan-(bi)similar.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(X\to TX\)</span> and <span class="math notranslate nohighlight">\(Y\to TY\)</span> be two <span class="math notranslate nohighlight">\(T\)</span>-caolgebras. Let <span class="math notranslate nohighlight">\(X\leftarrow R \rightarrow Y\)</span> be a <span class="math notranslate nohighlight">\(T\)</span>-span bisimulation. Let <span class="math notranslate nohighlight">\(R'\)</span> be the cocomma of <span class="math notranslate nohighlight">\(X\leftarrow R \rightarrow Y\)</span>. Applying <span class="math notranslate nohighlight">\(T'\)</span> to the square</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{}
&amp;&amp;DR&amp;&amp;\\
&amp;\swarrow&amp;&amp;\searrow&amp;\\
DX&amp;&amp;&amp;&amp;DY\\
&amp;\searrow&amp;&amp;\swarrow&amp;\\
&amp;&amp;R'&amp;&amp;
\end{array}
\end{split}\]</div>
<p>and using the arrow <span class="math notranslate nohighlight">\(R\to TR\)</span> from the span-bisimulation the universal property of the cocomma <span class="math notranslate nohighlight">\(R'\)</span> gives the required arroe <span class="math notranslate nohighlight">\(R'\to T'R'\)</span>. QED</p>
<p><strong>Examples:</strong> A number of familiar examples arise as instances of this proposition.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(T=\mathcal P\)</span> and <span class="math notranslate nohighlight">\(T'\)</span> the downset or upset or convex powerset functor: Every span-bisimulation is also a cospan-bisimulation. Moreover, if two points are bisimilar then they are forward-similar and backward-similar.</p></li>
<li><p><span class="math notranslate nohighlight">\(T=Up\mathcal P\)</span> is the monotone neibhbourhood frame functor. <span class="math notranslate nohighlight">\(T'\)</span> is its ordification or also <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span> or also <span class="math notranslate nohighlight">\(U^oD^o\)</span>.</p></li>
<li><p>…</p></li>
</ul>
<p><strong>Questions:</strong> Is there something more one can say about structural relationships between bisimulation and simulation? For example, one could try to isolate those functors for which forward simulation plus backward simulation is bisimulation, but I do not know how interesting this would be (is there a good abstract notion of “deterministic” functor?). Anything else?</p>
<p>For weak pullback preserving functors, we also have the converse of the previous proposition.</p>
<p><strong>Proposition:</strong> Let <span class="math notranslate nohighlight">\(T:Set\to Set\)</span> preserve weak pullbacks. If two states in two <span class="math notranslate nohighlight">\(T\)</span>-coalgebras are cospan-bisimilar then they are span-bisimilar.</p>
<p><em>Proof:</em> Let <span class="math notranslate nohighlight">\(R\)</span> be a cospan bisimulation and <span class="math notranslate nohighlight">\(X\to R' \leftarrow Y\)</span> be the collage, hence cocomma, of <span class="math notranslate nohighlight">\(R\)</span>.  Let <span class="math notranslate nohighlight">\(T'\)</span> be the ordification of <span class="math notranslate nohighlight">\(T\)</span>. With the help of the iso <span class="math notranslate nohighlight">\(DT\to T'D\)</span> we can consider the <span class="math notranslate nohighlight">\((R,R')\)</span>-square as a cocomma in ordered sets. Cocommas are exact. Since ordifications <span class="math notranslate nohighlight">\(T'\)</span> preserve exact squares if <span class="math notranslate nohighlight">\(T\)</span> preserves weak pullbacks [Theorem 4.11,BKV15] , the <span class="math notranslate nohighlight">\((TR,T'R')\)</span>-square is exact. But exact squares in posets are weak comma squares, hence there is an <span class="math notranslate nohighlight">\(R\to TR\)</span> making <span class="math notranslate nohighlight">\(R\)</span> into a span bisimulation. QED</p>
</section>
<section id="morphisms-and-bisimulations">
<h3>Morphisms and Bisimulations<a class="headerlink" href="#morphisms-and-bisimulations" title="Permalink to this headline">#</a></h3>
<p>In sets every function is a relation and every coalgebra morphism a bisimulation. In ordered sets every function <span class="math notranslate nohighlight">\(f:X\to Y\)</span> gives rise to two relation <span class="math notranslate nohighlight">\(f_\diamond:X\looparrowright Y\)</span> and <span class="math notranslate nohighlight">\(f^\diamond: Y\looparrowright X\)</span> with
$<span class="math notranslate nohighlight">\( (x,y)\in f_\diamond \ \Leftrightarrow \ fx\le y
\quad\quad\quad\quad
(y,x)\in f^\diamond \ \Leftrightarrow \ y\le fx\)</span>$</p>
<p><strong>Proposition:</strong> Let <span class="math notranslate nohighlight">\(T:Ord\to Ord\)</span>. If <span class="math notranslate nohighlight">\(f\)</span> is a <span class="math notranslate nohighlight">\(T\)</span>-coalgebra morphism, then <span class="math notranslate nohighlight">\(f_\diamond\)</span> and <span class="math notranslate nohighlight">\(f^\diamond\)</span> are cospan-(bi)simulations.</p>
<p><em>Proof:</em> <span class="math notranslate nohighlight">\(f_\diamond\)</span> and <span class="math notranslate nohighlight">\(f^\diamond\)</span> are the weakening closures of the spans <span class="math notranslate nohighlight">\((id,f)\)</span> and <span class="math notranslate nohighlight">\((f,id)\)</span>, respectively. Recall the definition of cospan-(bi)simulation and the fact that the collage of the weakening closure of a relation represented by a span <span class="math notranslate nohighlight">\((p,q)\)</span> is the cocomma of <span class="math notranslate nohighlight">\((p,q)\)</span>. Now the proposition follows from the universal property of cocommas. QED</p>
<p><strong>Example:</strong> <a class="reference external" href="https://hackmd.io/V6m2cAy_TdagteE4RG_sbw#mathcal-Dmathcal-U-coalgebras">Recall</a> that <span class="math notranslate nohighlight">\(R\)</span> is a <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-cospan-(bi)simulation iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-3190a453-c380-4a08-ad5f-64334e90a9f1">
<span class="eqno">(38)<a class="headerlink" href="#equation-3190a453-c380-4a08-ad5f-64334e90a9f1" title="Permalink to this equation">#</a></span>\[\begin{align}
xRy \ \ \Rightarrow \ \ &amp; 
\forall a\in\xi x.\exists b\in\nu y. \forall y'\in b.\exists x'\in a.\ x'Ry' 
\end{align}\]</div>
<p>We also <a class="reference external" href="https://hackmd.io/Kaf6xVVMRP2w7a9hTLjT2w">know</a> that <span class="math notranslate nohighlight">\(f:X\to Y\)</span> is a morphism <span class="math notranslate nohighlight">\((X,\xi)\to(Y,\nu)\)</span> of <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalegbras iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-886ac7ee-5ecc-4ebe-af8e-5d91d03dcc26">
<span class="eqno">(39)<a class="headerlink" href="#equation-886ac7ee-5ecc-4ebe-af8e-5d91d03dcc26" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in \xi x.\exists b\in\nu(fx).\forall y\in b.\exists x\in a. fx \le y\\[1ex]
\forall b\in \nu(fx).\exists a\in\xi(x).\forall x\in a.\exists y\in b. \ y\le fx
\end{gather}\]</div>
<p>It is now easy to check that the first clause says precisely that <span class="math notranslate nohighlight">\(f_\diamond\)</span> is a (bi)simulation and the second clause that <span class="math notranslate nohighlight">\(f^\diamond\)</span> is a (bi)simulation. (I find this very pretty.)</p>
<p><strong>Question:</strong> Can we prove the converse of the proposition?  - - - This is interesting, I wrote out the obvious diagrams, but I didn’t see how to proceed. - - - Maybe the converse is only true in special cases?</p>
</section>
<section id="cospan-bi-simulations-and-change-of-base">
<h3>Cospan (bi)simulations and change of base<a class="headerlink" href="#cospan-bi-simulations-and-change-of-base" title="Permalink to this headline">#</a></h3>
<p>Cospan (bi)simulations allow us to see ordinary coalgebraic bisimulations as well as quantale enriched ones in the same framwork. The basic picture, taken from Section 4 of [BKV19] is as follows. <span class="math notranslate nohighlight">\(C\dashv D\dashv V\)</span> take, respectively, connected components, discrete preorders and underlying sets. They lift via <a class="reference external" href="https://hackmd.io/V-YOMuAZTOSZpZUC8mC2tw">doctrinal adjunction</a> to coalgebras since the right adjoints satisfy <span class="math notranslate nohighlight">\(DT_{Set}\cong T_{Pre}D\)</span> and <span class="math notranslate nohighlight">\(VT_{Pre}\cong T_{Set}V\)</span>.</p>
<p><img alt="" src="https://i.imgur.com/LCIbNBE.png" /></p>
<p>On the right-hand side, <span class="math notranslate nohighlight">\(d'\)</span> is the top and bottom preserving embedding with a right adjoint <span class="math notranslate nohighlight">\(v'\)</span> and, if <span class="math notranslate nohighlight">\(\Omega\)</span> is non-trivial and integral<a class="footnote-reference brackets" href="#integral" id="id1">1</a>, a left adjoint <span class="math notranslate nohighlight">\(c'\)</span>. The left ajoint <span class="math notranslate nohighlight">\(c'\)</span> maps all elements other than bottom to <span class="math notranslate nohighlight">\(1\)</span> and the right adjoint <span class="math notranslate nohighlight">\(v'\)</span> maps all elements other than top to <span class="math notranslate nohighlight">\(0\)</span>. The adjunction <span class="math notranslate nohighlight">\(d'\dashv v'\)</span> lifts to a <span class="math notranslate nohighlight">\(Pre\)</span>-enriched adjunction between the categories of coalgebras. If the quantale <span class="math notranslate nohighlight">\(\Omega\)</span> has no zero-divisors, then <span class="math notranslate nohighlight">\(c'\)</span> is a quantale-morphism and <span class="math notranslate nohighlight">\(c'\dashv d'\)</span> lifts to <span class="math notranslate nohighlight">\(\Omega\)</span>-cat enriched adjunction between categories of coalgebras. See Propositions 4.9 and 4.10 of [BKV19] for details.</p>
<p><strong>Propositions ??</strong> … I think, mutatis mutandis, we can move the two propositions above from the left Set/Pre column to the right Pre/<span class="math notranslate nohighlight">\(\Omega\)</span>-cat column …</p>
<p><strong>Examples ??</strong> Can we make an example of ordinary transition systems and bisimulation and then a metric example? Are there scenarios where one would want an orderd coalgebra as an abstraction of a metric coalgebra? I never really looked so much at Kripke frames over metric spaces … any ideas?</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Balan, Kurz, Velebil: <a class="reference external" href="https://arxiv.org/pdf/1402.5922v4">Positive fragments of coalgebraic logics</a>. 2015.</p>
<p>Balan, Kurz, Velebil: <a class="reference external" href="https://lmcs.episciences.org/5132/pdf">Extending set functors to generalised metric spaces</a>. 2019.</p>
<p>Jacobs</p>
<p>Hughes-Jacobs</p>
</section>
<section id="further">
<h3>Further<a class="headerlink" href="#further" title="Permalink to this headline">#</a></h3>
<p>Scratch notes on <a class="reference external" href="https://hackmd.io/uGb9AQJnRsCWk3yd_kE1lw">exact squares</a></p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="integral"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>A quantale is integral if the neutral element of the multiplication is the top element.</p>
</dd>
</dl>
</section>
</section>
</div>
<div class="toctree-wrapper compound">
<span id="document-contents/Coalgebras-over-Preorders"></span><section class="tex2jax_ignore mathjax_ignore" id="coalgebras-over-preorders">
<h2>Coalgebras over Preorders<a class="headerlink" href="#coalgebras-over-preorders" title="Permalink to this headline">#</a></h2>
<p>(draft … reference to be added)</p>
<p>The notion of “bisimulation” canonically associated to a functor <span class="math notranslate nohighlight">\(T:\sf Ord\to Ord\)</span> on ordered sets is typically not a <strong>bi</strong>simulation but a (forward or backward) <strong>simulation</strong>. But, depending on the choice of <span class="math notranslate nohighlight">\(T\)</span>, it can include ordinary bisimulation as well. I therefore decided to call it (bi)simulation.</p>
<p>Simulations are one of the main reasons to be interested in coalgebras over orders. Of course, orders are also interested in their own right. Moreover, order-enriched category theory is similar to quantale-enriched category theory, which allows to include metric bisimulations in the coalgebraic setting.</p>
<p>For the remainder of this introduction, we review some of the material of the note on <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/r1SJ8lizO">powerdomains</a> with the category of preorders instead of posets. We start again with</p>
<p><img alt="" src="https://i.imgur.com/wpaU0or.png" /></p>
<p>but we now allow <span class="math notranslate nohighlight">\(X,X'\)</span> to be preorders (and require all maps to be order-preserving). We consider three versions of <span class="math notranslate nohighlight">\(\mathcal P\)</span> according to whether <span class="math notranslate nohighlight">\(\mathcal PX\)</span> is equipped with any of the following orders:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{array}{|c|c|c|l|}
\hline
\mathcal P &amp; (\mathcal PX, \equiv) 
&amp; \textrm{bisimulation} 
&amp; a \equiv b \ \Longleftrightarrow \ \forall x\in a\exists y\in b(x\le y) \ \&amp; \ \forall y\in b\exists x\in a(x\le y) \\ \hline
\mathcal U &amp; (\mathcal PX, \sqsubseteq) 
&amp; \textrm{forward simulation} 
&amp; a \sqsubseteq b \ \Longleftrightarrow \ \forall x\in a\exists y\in b(x\le y) 
\\ \hline
\mathcal D &amp; (\mathcal PX, \sqsupseteq) 
&amp; \textrm{backward simulation} 
&amp; a \sqsupseteq b \ \Longleftrightarrow \ \forall y\in b\exists x\in a(x\le y) \\ \hline
\end{array}
\end{split}\]</div>
<p>Coalgebra homomorphisms are still (functional) bisimulations in all cases but (bi)simulations and the final coalgebra  can now have a richer structure.</p>
<p><strong>Remark:</strong> Note that <span class="math notranslate nohighlight">\(\mathcal U\)</span> and <span class="math notranslate nohighlight">\(\mathcal D\)</span> are on preorders (as opposed to on posets) not defined by taking up- or downsets. Both take arbitrary subsets preordered as indicated. If these preorders are quotiented by equivalence, then the order on the quotient of <span class="math notranslate nohighlight">\(\mathcal UX\)</span> is isomorphic to inclusion of upsets and  and the order on the quotient of <span class="math notranslate nohighlight">\(\mathcal DX\)</span> is isomorphic to reverse inclusion of downsets.</p>
<p><strong>Remark:</strong> The forgetful functor <span class="math notranslate nohighlight">\(V:\sf Pre\to Set\)</span> has the discrete functor <span class="math notranslate nohighlight">\(D\)</span> as an ordinary left adjoint. Moreover, in the three examples above, <span class="math notranslate nohighlight">\(VT\cong\mathcal PV\)</span>. It follows by <a class="reference external" href="https://hackmd.io/&#64;alexhkurz/rk41nDC_w">doctrinal adjunction</a> that <span class="math notranslate nohighlight">\(V\)</span> lifts to right-adjoint between categories of coalgebras. Since right adjoints preserve final objects, forgetting the order of the final <span class="math notranslate nohighlight">\(T\)</span>-coalgebra gives us the final <span class="math notranslate nohighlight">\(\mathcal P\)</span>-coalgebra. In other words, in each of the three cases, equality on the final coalgebra is ordinary bisimilarity. (This is not true if we replace preorders by posets because bisimulation is stronger than forward and backward simulation.)</p>
</section>
<span id="document-contents/Poset-Functors"></span><section class="tex2jax_ignore mathjax_ignore" id="examples-of-poset-functor">
<h2>Examples of Poset-Functor<a class="headerlink" href="#examples-of-poset-functor" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added)</p>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h3>
<p>Ideally, coalgebraic logic over posets should follow the same lines as coalgebraic logic over sets. Just replace the category <span class="math notranslate nohighlight">\(\sf Set\)</span> everywhere by the category <span class="math notranslate nohighlight">\(\sf Ord\)</span> of ordered sets (posets or preorders) and order-preserving (aka monotone) maps.</p>
<p>Really many new phenomena arise. One general interesting question is how much knowledge we can transfer from set-coalgebras to poset-coalgebras in a systematic way.</p>
<p>One approach to answer this question is to study relationships between set and poset-functors systematically. So let us start by recalling the notion of an <a class="reference external" href="https://hackmd.io/jxfudz7SQpmj5BzZkyWZIA?both#Order-Extensions">order-extension</a> (posetification, preordification) <span class="math notranslate nohighlight">\(T'\)</span> of a set functor <span class="math notranslate nohighlight">\(T:\sf Set\to Set\)</span>.</p>
</section>
<section id="functors-on-posets">
<h3>Functors on Posets<a class="headerlink" href="#functors-on-posets" title="Permalink to this headline">#</a></h3>
<p><strong>Powerset:</strong> Let <span class="math notranslate nohighlight">\(T=\mathcal P\)</span> be the powerset functor. There are the following three extensions to <span class="math notranslate nohighlight">\(Pos\)</span>-enriched functors.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal D\)</span> with <span class="math notranslate nohighlight">\(\mathcal DX=[X^o,2]\)</span> on objects. For <span class="math notranslate nohighlight">\(f:X\to Y\)</span>, one defines <span class="math notranslate nohighlight">\(\mathcal Df:[X^o,2]\to [Y^o,2]\)</span> as the left Kan extension of <span class="math notranslate nohighlight">\(Yon_Y\circ f\)</span> along <span class="math notranslate nohighlight">\(Yon_X\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal UX= (\mathcal DX^o)^o\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal P\)</span> is the convex powerset.</p></li>
</ul>
<p><strong>Double Powerset:</strong></p>
<p><img alt="" src="https://i.imgur.com/HhM5Qbw.png" /></p>
</section>
<section id="id1">
<h3>…<a class="headerlink" href="#id1" title="Permalink to this headline">#</a></h3>
</section>
</section>
<span id="document-contents/Montone-Neighbourhood-Coalgebras"></span><section class="tex2jax_ignore mathjax_ignore" id="montone-neighbourhood-coalgebras">
<h2>Montone Neighbourhood Coalgebras<a class="headerlink" href="#montone-neighbourhood-coalgebras" title="Permalink to this headline">#</a></h2>
<p>(draft)</p>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h3>
<p>The idea of this section is to run through parts of [HK04] and adapt it to <em>ordered</em> neighbourhood frames. It could also be interesting to study <em>metric</em> neighbourhood frames.</p>
<p>The neighbourhood frames of modal logic are coalgebras for the functor <span class="math notranslate nohighlight">\(Up\mathcal P\)</span> [HK04,Lem.3.4]. Here, <span class="math notranslate nohighlight">\(Up\mathcal P X=\{A\subseteq \mathcal P(\mathcal PX) \mid a\in A, a\subseteq a' \Rightarrow a'\in A\}\)</span>. On functions, we have</p>
<div class="math notranslate nohighlight">
\[Up\mathcal P\  f\ A = {\uparrow}\{f[a] \mid a\in A\}.\]</div>
<p>There are three well-known ways of extending powerset to orders. In domain theory, they are known as the upper, lower and convex powerdomain, and also known under the names of Hoare, Smyth and Plotkin, respectively. They correspond to the downset functor <span class="math notranslate nohighlight">\(\mathcal D\)</span>, the upset functor <span class="math notranslate nohighlight">\(\mathcal U\)</span> and the convex powerset functor <span class="math notranslate nohighlight">\(\overline{\mathcal P}\)</span>. The first two arise from ordering powerset by inclusion and reverse inclusion. The third arises as the posetification of the powerset.</p>
<p>Similarly, there are three ways to extend the monotone neighbourhood functor <span class="math notranslate nohighlight">\(Up\mathcal P\)</span> to posets.</p>
<p>Recall that on objects <span class="math notranslate nohighlight">\(\mathcal UX=[X,2]^o\)</span> and <span class="math notranslate nohighlight">\(\mathcal DX = [X^o,2]\)</span>. As a functor (and as a monad)</p>
<div class="math notranslate nohighlight">
\[\mathcal D\mathcal U X=[[X,2],2]\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\mathcal U\mathcal DX=[[X^o,2],2]^o.\]</div>
<p>On discrete <span class="math notranslate nohighlight">\(X\)</span>, we have <span class="math notranslate nohighlight">\(\mathcal D\mathcal UX = (\mathcal U\mathcal DX)^o\)</span>, so both are legitimate order generalisations of the functor <span class="math notranslate nohighlight">\(Up\mathcal P\)</span>.</p>
<p>Finally, there is also the posetification <span class="math notranslate nohighlight">\(\overline{Up\mathcal P}\)</span>.</p>
<p>We derive the notions of <a class="reference external" href="https://hackmd.io/MMxanF1vQ1KgZ7BThVCoGw">cospan (bi)simulation</a> of the functors <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span> and <span class="math notranslate nohighlight">\(\mathcal U\mathcal D\)</span> and <span class="math notranslate nohighlight">\(Up\mathcal P\)</span>.</p>
</section>
<section id="coalgebra-morphisms">
<h3>Coalgebra Morphisms<a class="headerlink" href="#coalgebra-morphisms" title="Permalink to this headline">#</a></h3>
<p><strong>Proposition:</strong> <span class="math notranslate nohighlight">\(f\)</span> is a morphism of <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalgebras iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-780060d2-6621-4445-91e9-99de4f94b1a4">
<span class="eqno">(40)<a class="headerlink" href="#equation-780060d2-6621-4445-91e9-99de4f94b1a4" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in \xi x.\exists b\in\nu(fx).\forall y\in b.\exists x\in a. fx \le y\\[1ex]
\forall b\in \nu(fx).\exists a\in\xi(x).\forall x\in a.\exists y\in b. \ y\le fx
\end{gather}\]</div>
<p><span class="math notranslate nohighlight">\(f\)</span> is a morphism of <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalgebras iff</p>
<div class="amsmath math notranslate nohighlight" id="equation-da9e31c9-3b0b-45b4-87f4-db5e81e7cf19">
<span class="eqno">(41)<a class="headerlink" href="#equation-da9e31c9-3b0b-45b4-87f4-db5e81e7cf19" title="Permalink to this equation">#</a></span>\[\begin{gather}
\forall a\in \xi x.\exists b\in\nu(fx).\forall y\in b.\exists x\in a. fx \ge y\\[1ex]
\forall b\in \nu(fx).\exists a\in\xi x.\forall x\in a.\exists y\in b. y \ge fx 
\end{gather}\]</div>
<p><span class="math notranslate nohighlight">\(f\)</span> is a morphism of <span class="math notranslate nohighlight">\(\overline{Up\mathcal P}\)</span>-coalgebras if</p>
<p>Morphisms of <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span> and <span class="math notranslate nohighlight">\(\mathcal U\mathcal D\)</span>-coalgebras coincide on discrete coalgebras. Here is an attempt at a visual summary:</p>
<p>![](https://i.imgur.com/a1wXKKp.png =400x600)</p>
</section>
<section id="morphisms-as-relations">
<h3>Morphisms as Relations<a class="headerlink" href="#morphisms-as-relations" title="Permalink to this headline">#</a></h3>
<p>In sets every function is a relation and every coalgebra morphism a bisimulation. In ordered sets every function <span class="math notranslate nohighlight">\(f:X\to Y\)</span> gives rise to two relation <span class="math notranslate nohighlight">\(f_\diamond:X\looparrowright Y\)</span> and <span class="math notranslate nohighlight">\(f^\diamond: Y\looparrowright X\)</span> with</p>
<div class="math notranslate nohighlight">
\[ (x,y)\in f_\diamond \ \Leftrightarrow \ fx\le y
\quad\quad\quad\quad
(y,x)\in f^\diamond \ \Leftrightarrow \ y\le fx\]</div>
<p>We have shown in <a class="reference external" href="https://hackmd.io/jxfudz7SQpmj5BzZkyWZIA">Cospan Bisimulations 2</a> that these relations are cospan (bi)simulations if <span class="math notranslate nohighlight">\(f\)</span> is a coalgebra morphism. This example suggests that more is true.</p>
<p><strong>Proposition:</strong> <span class="math notranslate nohighlight">\(f\)</span> is a morphism of <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-coalgebras iff <span class="math notranslate nohighlight">\(f_\diamond\)</span> and <span class="math notranslate nohighlight">\(f^\diamond\)</span> are cospan-(bi)simulations.</p>
<p><em>Proof:</em> We only need to instantiate the characterisation of <span class="math notranslate nohighlight">\(\mathcal D\mathcal U\)</span>-cospan-(bi)simulation from the section on <a class="reference external" href="https://hackmd.io/V6m2cAy_TdagteE4RG_sbw#Ordered-neighbourhood-coalgebras">Bisimulation for Ordered Coalgebras</a>.</p>
<p>An analogous statement is true for <span class="math notranslate nohighlight">\(\mathcal U\mathcal D\)</span>-coalgebras (CHECK).</p>
</section>
<section id="modal-logic">
<h3>Modal Logic<a class="headerlink" href="#modal-logic" title="Permalink to this headline">#</a></h3>
<p>![](https://i.imgur.com/1FLZ0fs.png =80x80)</p>
<p>(WHERE DO WE SEE THE DIFFERENCE BETWEEN THE TYPES OF COALGEBRAS IN THE LOGICS?)</p>
<p><strong>Def:</strong>  The two-sorted modal logic for ordered neighbourhood frames has point-formulas <span class="math notranslate nohighlight">\(\phi\)</span> and set-formulas <span class="math notranslate nohighlight">\(\psi\)</span> given as</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\phi &amp;::= \Box\psi \mid \phi\wedge\phi \mid \phi\vee\phi \mid p \\[1ex]
\psi &amp;::= \Diamond\phi \mid \psi\wedge\psi \mid \psi\vee\psi
\end{align*}\]</div>
<p>and axioms saying that <span class="math notranslate nohighlight">\(\Box\)</span> preserves finite meets and <span class="math notranslate nohighlight">\(\Diamond\)</span> preserves finite joins.</p>
<p><strong>Remark:</strong> This logic can be derived from the semantics using the principles of functorial modal logic (FML). This construction then guarantees the following proposition.</p>
<p><strong>Prop:</strong> Formulas are invariant under morphisms and behavioural equivalence. Moreover, the logic is sound and complete for ordered neighbourhood models.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Dahlqvist and Kurz: <a class="reference external" href="http://drops.dagstuhl.de/opus/volltexte/2017/8042/pdf/LIPIcs-CALCO-2017-9.pdf">The Positivication of Coalgebraic Logics</a>. CALCO 2017. (Section 3.3 and 3.4)</p>
<p>Hansen, Kupke: <a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S1571066104051722/pdf">A Coalgebraic Perspective on Monotone Modal Logic</a>. 2004.</p>
<p>M. Pauly. Bisimulation for general non-normal modal logic. Manuscript, 1999.</p>
</section>
</section>
<span id="document-contents/Logic-of-Ordered-Neighbourhood-Coalgebras"></span><section class="tex2jax_ignore mathjax_ignore" id="logic-of-ordered-neighbourhood-coalgebras">
<h2>Logic of Ordered Neighbourhood Coalgebras<a class="headerlink" href="#logic-of-ordered-neighbourhood-coalgebras" title="Permalink to this headline">#</a></h2>
<p>(draft … references to be added) … (<a class="reference external" href="https://hackmd.io/&#64;alexhkurz/ryrkkYZZc">up</a>)</p>
<section id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h3>
<p>We write <span class="math notranslate nohighlight">\(2\)</span> for the 2-chain <span class="math notranslate nohighlight">\(0&lt;1\)</span> in various ordered categories such as posets or bounded distributed lattices.</p>
<p>Let</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(U:Pos\to Pos\)</span> take upsets ordered by reverse inclusion: <span class="math notranslate nohighlight">\(UX=[X,2]^o\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(D:Pos\to Pos\)</span> take downsets ordered by inclusion: <span class="math notranslate nohighlight">\(DX=[X^o,2]\)</span></p></li>
</ul>
<p>Let</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal X\)</span> be the category of poset</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal A\)</span> be the category of bounded distributive lattices</p></li>
<li><p><span class="math notranslate nohighlight">\(T=DU\)</span></p></li>
</ul>
<p>Then <span class="math notranslate nohighlight">\(Coalg(T)\)</span> is category of (monotone) neighbourhood frames (over posets). In particular <span class="math notranslate nohighlight">\(DUX=Up\mathcal PX\)</span> for discrete <span class="math notranslate nohighlight">\(X\)</span>. Note that <span class="math notranslate nohighlight">\(DUX=2^{2^X}\)</span> if we define <span class="math notranslate nohighlight">\(2^X\)</span> as the poset of monotone maps <span class="math notranslate nohighlight">\(X\to 2\)</span>.</p>
<p>Let</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P:\mathcal X\to\mathcal A\)</span> be the contravariant functor <span class="math notranslate nohighlight">\(X\mapsto 2^X\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(S:\mathcal A\to\mathcal X\)</span> the contravariant functor <span class="math notranslate nohighlight">\(A\mapsto DL(A,2)\)</span>.</p></li>
</ul>
<p>Then</p>
<ul class="simple">
<li><p>the dual <span class="math notranslate nohighlight">\(U^\partial:DL\to DL\)</span> of <span class="math notranslate nohighlight">\(U\)</span> is presented by operations and equations as follows. <span class="math notranslate nohighlight">\(U^\partial A\)</span> is generated by <span class="math notranslate nohighlight">\(\{\Box a\mid a\in PX\}\)</span> and the equations stating that <span class="math notranslate nohighlight">\(\Box\)</span> preserves finite meets.  This gives an isomorphism</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ U^\partial PX\to UPX\]</div>
<p>for finite posets <span class="math notranslate nohighlight">\(X\)</span>.</p>
<ul class="simple">
<li><p>the dual <span class="math notranslate nohighlight">\(D^\partial:DL\to DL\)</span> of <span class="math notranslate nohighlight">\(D\)</span> is presented by operations and equations as follows. <span class="math notranslate nohighlight">\(D^\partial A\)</span> is generated by <span class="math notranslate nohighlight">\(\{\Diamond a\mid a\in PX\}\)</span> and the equations stating that <span class="math notranslate nohighlight">\(\Diamond\)</span> preserves finite meets.  This gives an isomorphism</p></li>
</ul>
<div class="math notranslate nohighlight">
\[ D^\partial PX\to DPX\]</div>
<p>for finite posets <span class="math notranslate nohighlight">\(X\)</span>.</p>
</section>
<section id="the-2-sorted-view">
<h3>The 2-sorted view<a class="headerlink" href="#the-2-sorted-view" title="Permalink to this headline">#</a></h3>
<p>We can also think of coalgebras</p>
<div class="math notranslate nohighlight">
\[X \to UDX\]</div>
<p>as special 2-dimensional coalgebras</p>
<div class="math notranslate nohighlight">
\[(X,Y) \to (UY,DX).\]</div>
<p>The dual of these coalgebras on the algebraic side are algebras</p>
<div class="math notranslate nohighlight">
\[(D^\partial B,U^\partial A)\to (A,B)\]</div>
<p><strong>Remark:</strong> Given functors <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>,  <a class="reference external" href="https://alexhkurz.github.io/papers/cmcs08-j.pdf">Kurz-Petrisan</a> calls the functor which maps <span class="math notranslate nohighlight">\((X,Y)\)</span> to <span class="math notranslate nohighlight">\((FY,GX)\)</span> the symmetric composition of <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>. While the presentation of the functor <span class="math notranslate nohighlight">\(FG\)</span> is typically not compositional in the presentations of <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(G\)</span>, the symmetric composition does have the obvious componentwise presentation.</p>
</section>
<section id="an-adjunction">
<h3>An adjunction<a class="headerlink" href="#an-adjunction" title="Permalink to this headline">#</a></h3>
<p>Let <span class="math notranslate nohighlight">\(Coalg(F,G)\)</span> be the category of 2-sorted coalgebras of the kind</p>
<div class="math notranslate nohighlight">
\[(X,Y)\to (FY,GX).\]</div>
<p><strong>Theorem</strong>: <span class="math notranslate nohighlight">\(Coalg(FG)\)</span> is a full reflective subcategory of <span class="math notranslate nohighlight">\(Coalg(F,G)\)</span>.</p>
<p><em>Proof</em>: We map <span class="math notranslate nohighlight">\(X\to FGX\)</span> to <span class="math notranslate nohighlight">\((X,GX)\to (FGX,GX)\)</span> where the second component is the identity. This functor has a left adjoint which maps  <span class="math notranslate nohighlight">\((X,Y)\to (FY,GX)\)</span> to <span class="math notranslate nohighlight">\(X\to FY\to FGX\)</span>.</p>
<p>The unit of the adjunction is the obvious coalgebra morphism from <span class="math notranslate nohighlight">\((X,Y)\to (FY,GX)\)</span> to <span class="math notranslate nohighlight">\((X,GX)\to (FGX,GX)\)</span>. The counit is the identity.</p>
<p>Moreover, the right-adjoint is full and faithful. QED</p>
<p><strong>Corollary</strong>: <span class="math notranslate nohighlight">\(Coalg(FG)\)</span> is closed under limits in <span class="math notranslate nohighlight">\(Coalg(F,G)\)</span>. In particular, the final coalgebra in <span class="math notranslate nohighlight">\(Coalg(F,G)\)</span> is also the final coalgebra in <span class="math notranslate nohighlight">\(Coalg(FG)\)</span>.</p>
<p><strong>Corollary:</strong> <span class="math notranslate nohighlight">\(Alg(FG)\)</span> is a full co-reflective subcategory of <span class="math notranslate nohighlight">\(Alg(F,G)\)</span>.</p>
<p><strong>Corollary</strong>: The category of <span class="math notranslate nohighlight">\(D^\partial U^\partial\)</span>-algebras is a full coreflective subcategory of <span class="math notranslate nohighlight">\(Alg(D^\partial, U^\partial)\)</span>.</p>
<p><strong>Corollary</strong>: <span class="math notranslate nohighlight">\(Alg(FG)\)</span> is closed under colimits in <span class="math notranslate nohighlight">\(Alg(F,G)\)</span>. In particular, the initial algebra in <span class="math notranslate nohighlight">\(Alg(F,G)\)</span> is also the initial algebra in <span class="math notranslate nohighlight">\(Alg(FG)\)</span>.</p>
</section>
<section id="references">
<h3>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h3>
<p>Pauly: …</p>
<p>Hansen, Kupke: …</p>
<p>Kurz, Petrisan: …</p>
<p>…</p>
</section>
</section>
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

            </article>
            

            
            
            <footer class="bd-footer-article">
                <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
            </footer>
            
          </div>
          
          
          
          
        </div>
        <footer class="bd-footer-content">
          <div class="bd-footer-content__inner">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Alexander Kurz
</p>

  </div>
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2022.<br>

</p>

  </div>
  
  <div class="footer-item">
    <p class="last-updated">
Last updated on None.<br>
</p>
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </div>
        </footer>
        

      </main>
    </div>
  </div>

  
    
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>

  </body>
</html>